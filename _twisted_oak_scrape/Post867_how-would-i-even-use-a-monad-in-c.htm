<!DOCTYPE html>
<!-- paulirish.com/2008/conditional-stylesheets-vs-css-hacks-answer-neither/ -->
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!-- Consider adding an manifest.appcache: h5bp.com/d/Offline -->
<!--[if gt IE 8]><!-->
<html class=" js flexbox canvas canvastext webgl no-touch geolocation postmessage no-websqldatabase indexeddb hashchange history draganddrop websockets rgba hsla multiplebgs backgroundsize borderimage borderradius boxshadow textshadow opacity cssanimations csscolumns cssgradients no-cssreflections csstransforms csstransforms3d csstransitions fontface generatedcontent video audio localstorage sessionstorage webworkers applicationcache svg inlinesvg smil svgclippaths" xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" xmlns:fb="https://www.facebook.com/2008/fbml" lang="en"><script id="bug.surrogate">var urchinTracker=function(){},_gaq={push:function(){try {if(arguments[0][0]=='_link')window.location.href=arguments[0][1]}catch(er){}}},_gat={_createTracker:function(){}, _getTracker:function(){return{__noSuchMethod__:function(){},_link:function(o){if(o)location.href=o;},_linkByPost:function(){return true;},_getLinkerUrl:function(o){return o;},_trackEvent:function(){}}}}; if (document.location.host == 'www.salon.com') {var _ga_ = document.querySelectorAll('script[src$=ga\\.js]')[0], ga_e = document.createEvent('Event'); ga_e.initEvent('load', true, true);_ga_.dispatchEvent(ga_e);}</script><!--<![endif]--><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
   <!-- blog feed link -->
  <link href="http://twistedoakstudios.com/blog/?feed=rss" rel="alternate" type="application/rss+xml" title="Twisted Oak Studios Blog">

  <!-- Use the .htaccess and remove these lines to avoid edge case issues.
       More info: h5bp.com/b/378 -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">

  <title>Twisted Oak Studios | Game Developers | Unity 3D Development</title>
  <meta name="description" content="As a lean co-operative team of seasoned developers, Twisted Oak is able to offer efficient, flexible remote and on-the-floor development and consulting without any middle-man or excessive administrivia.">
  <meta name="author" content="/humans.txt">

  <meta name="viewport" content="width=device-width,initial-scale=1">

  <link rel="shortcut icon" href="http://twistedoakstudios.com/blog/favicon.ico">
  <link rel="apple-touch-icon-precomposed" href="http://twistedoakstudios.com/blog/apple-touch-icon-precomposed.png">

  	<!-- The 1140px Grid - http://cssgrid.net/ -->
	<link rel="stylesheet" href="Post867_how-would-i-even-use-a-monad-in-c_files/1140.css">
    <link rel="stylesheet" href="Post867_how-would-i-even-use-a-monad-in-c_files/style.css">
    <link rel="stylesheet" href="Post867_how-would-i-even-use-a-monad-in-c_files/blogstyle.css">
<link rel="stylesheet" href="Post867_how-would-i-even-use-a-monad-in-c_files/prettify.css" media="all">
<link rel="stylesheet" href="Post867_how-would-i-even-use-a-monad-in-c_files/sunburst.css" media="all">
<script type="text/javascript" src="Post867_how-would-i-even-use-a-monad-in-c_files/prettify.js"></script>

	<!-- Webfonts! -->
	<link href="Post867_how-would-i-even-use-a-monad-in-c_files/css.css" rel="stylesheet" type="text/css">

	<!-- Open Graph -->
	<meta property="og:title" content="Twisted Oak Studios">
	<meta property="og:type" content="company">
	<meta property="og:url" content="http://www.twistedoakstudios.com/">
	<meta property="og:image" content="http://www.twistedoakstudios.com/images/logo.png">
	<meta property="og:description" content="As a lean co-operative team of seasoned developers, Twisted Oak is able to offer efficient, flexible remote and on-the-floor development and consulting without any middle-man or excessive administrivia.">
  
  <script src="Post867_how-would-i-even-use-a-monad-in-c_files/modernizr-2.js"></script>
</head>
<body onload="prettyPrint()">
<!-- begin header -->
<div class="container header-container">
	<div class="row">
		<header>
			<div class="threecol">
				<a href="#"><img class="logo" src="Post867_how-would-i-even-use-a-monad-in-c_files/logo.png"></a>
			</div><!-- .threecol -->
		
			<div class="fourcol navcol">
				<nav>
					<ul class="primary-nav clearfix">
						<li><a href="http://twistedoakstudios.com/">Home</a></li>
						<li><a href="http://twistedoakstudios.com/portfolio/">Portfolio</a></li>
						<li><a class="scroll" href="#contact">Contact</a></li>
						<li><a href="http://twistedoakstudios.com/blog/">Blog</a></li>
					</ul>
				</nav>
			</div>    

    	</header>
	</div><!-- .row -->
</div><!-- .container -->


	<div id="main">
<span class="blog">
<div class="container home-container" id="home">
	<div class="row">
		<section>
			
			<div class="ninecol">


<h2><a href="http://twistedoakstudios.com/blog/Post867_how-would-i-even-use-a-monad-in-c" rel="bookmark" title="Permanent Link to How would I even use a monad (in C#)?">How would I even use a monad (in C#)?</a></h2>
<div class="meta">posted by Craig Gidney on October 30, 2012</div>

<p>As you may have guessed, based on <em>everyone ever</em> trying to 
explain what they are, monads are an interesting concept. I assume the 
difficulty in explaining them stems from the high level of abstraction, 
compared to related ideas like “being enumerable”, but I won’t be trying
 to explain what a monad is in this post. Instead I’m going to show you 
how, in C#, you can take advantage of a type being a monad.</p>
<p>If you do want an explanation of what a monad is, I recommend <a href="http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">the marvels of monads</a>, an old post that made the concept “click” for me. It even covers some of the same content I’ll be presenting here.</p>
<h3>Querying your Monad</h3>
<p>Language integrated query (LINQ) was a major feature introduced way 
back in C#3. Instead of manually looping over a list to create another 
list of transformed results, you could suddenly write a much more 
concise query expression:</p>
<pre><code class="prettyprint"><span class="com">// before linq</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> transformedList </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">List</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> inputList</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    transformedList</span><span class="pun">.</span><span class="typ">Add</span><span class="pun">(</span><span class="pln">item </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// after linq</span><span class="pln">
</span><span class="kwd">var</span><span class="pln"> transformedSequence </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> inputList </span><span class="kwd">select</span><span class="pln"> item </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span></code></pre>
<p>You probably already know about query expressions, but you may not 
have known that you can query over more than just lists and other 
enumerables. In fact, you can make your own custom types queryable. You 
do this by implementing extension methods corresponding to the various 
parts of the query expression.</p>
<p>For example, suppose we want to be able to query and transform tasks 
(a.k.a. Futures / Promises / Eventual Results). Queryable tasks would 
let us write code like this:</p>
<pre><code class="prettyprint"><span class="kwd">public</span><span class="pln"> async </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="typ">PrintQueryTasks</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// needs Task.Select, prints "7" one second after being invoked</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="pln">await </span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> </span><span class="lit">5.DelayOneSecond</span><span class="pun">()</span><span class="pln">
                             </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">));</span><span class="pln">
    </span><span class="com">// needs Task.SelectMany, prints "7" two seconds after being invoked</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="pln">await </span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> </span><span class="lit">2.DelayOneSecond</span><span class="pun">()</span><span class="pln">
                             </span><span class="kwd">from</span><span class="pln"> r </span><span class="kwd">in</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">).</span><span class="typ">DelayOneSecond</span><span class="pun">()</span><span class="pln">
                             </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">*</span><span class="pln"> r </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> </span><span class="typ">DelayOneSecond</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> T result</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">.</span><span class="typ">Delay</span><span class="pun">(</span><span class="lit">1000</span><span class="pun">).</span><span class="typ">ContinueWith</span><span class="pun">(</span><span class="pln">x </span><span class="pun">=&gt;</span><span class="pln"> result</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>The C# compiler implements these queries by transforming them into 
code that invokes methods called Select and SelectMany. In this case 
Select should take a task, as well as a function to apply to the task’s 
eventual result, and should return a task representing the function’s 
eventual output when eventually given the input task’s result. 
SelectMany should have corresponding functionality, but allowing for an 
intermediate task. We can implement these methods by delegating to the 
existing ContinueWith and Unwrap methods, like this:</p>
<pre><code class="prettyprint"><span class="com">///&lt;summary&gt;Transforms a task's result, or propagates its exception or cancellation.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> </span><span class="typ">Select</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">&gt;</span><span class="pln"> task</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> projection</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">TaskCompletionSource</span><span class="pun">&lt;</span><span class="typ">TOut</span><span class="pun">&gt;();</span><span class="pln">
    task</span><span class="pun">.</span><span class="typ">ContinueWith</span><span class="pun">(</span><span class="kwd">self</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">self</span><span class="pun">.</span><span class="typ">IsFaulted</span><span class="pun">)</span><span class="pln"> r</span><span class="pun">.</span><span class="typ">SetException</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">.</span><span class="typ">Exception</span><span class="pun">.</span><span class="typ">InnerExceptions</span><span class="pun">);</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">self</span><span class="pun">.</span><span class="typ">IsCanceled</span><span class="pun">)</span><span class="pln"> r</span><span class="pun">.</span><span class="typ">SetCanceled</span><span class="pun">();</span><span class="pln">
        </span><span class="kwd">else</span><span class="pln"> r</span><span class="pun">.</span><span class="typ">SetResult</span><span class="pun">(</span><span class="pln">projection</span><span class="pun">(</span><span class="kwd">self</span><span class="pun">.</span><span class="typ">Result</span><span class="pun">));</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> r</span><span class="pun">.</span><span class="typ">Task</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">///&lt;summary&gt;Transforms a task's result and then does a combined transform, propagating any exceptions or cancellation.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> </span><span class="typ">SelectMany</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="pln">
        </span><span class="kwd">this</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">&gt;</span><span class="pln"> task</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TMid</span><span class="pun">&gt;&gt;</span><span class="pln"> midProjection</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> outProjection</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> task</span><span class="pun">.</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">inp </span><span class="pun">=&gt;</span><span class="pln"> midProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">).</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">mid </span><span class="pun">=&gt;</span><span class="pln"> outProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">))).</span><span class="typ">Unwrap</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Once we’ve placed these extension methods inside of a static class, the task querying code from above should compile and run.</p>
<p>Another common type of thing to make queryable is nullable values. 
Querying a nullable value will propagate any nulls, instead of failing 
with an exception, but otherwise act normally. Unfortunately, the fact 
that, in C#, all references are nullable means we can only reasonably 
define this query for value types. However, it still makes a good 
example. So, in order to write nullable querying code like this:</p>
<pre><code class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="typ">PrintQueryNullables</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pun">?</span><span class="pln"> five </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">int</span><span class="pun">?</span><span class="pln"> six </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">int</span><span class="pun">?</span><span class="pln"> noValue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// needs T?.Select, prints "true"</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> five
                      </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">==</span><span class="pln"> </span><span class="lit">5</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// needs T?.Select, prints "" (meaning null)</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> noValue
                      </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">==</span><span class="pln"> </span><span class="lit">5</span><span class="pun">);</span><span class="pln">

    </span><span class="com">// needs T?.SelectMany, prints "false"</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> five
                      </span><span class="kwd">from</span><span class="pln"> n </span><span class="kwd">in</span><span class="pln"> six
                      </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// needs T?.SelectMany, prints "" (meaning null)</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> noValue
                      </span><span class="kwd">from</span><span class="pln"> n </span><span class="kwd">in</span><span class="pln"> six
                      </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// needs T?.SelectMany, prints "" (meaning null)</span><span class="pln">
    </span><span class="typ">Console</span><span class="pun">.</span><span class="typ">WriteLine</span><span class="pun">(</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> five
                      </span><span class="kwd">from</span><span class="pln"> n </span><span class="kwd">in</span><span class="pln"> noValue
                      </span><span class="kwd">select</span><span class="pln"> e </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>We can implement the corresponding extension methods like this:</p>
<pre><code class="prettyprint"><span class="com">///&lt;summary&gt;Transforms non-null values while propagating nulls.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">?</span><span class="pln"> </span><span class="typ">Select</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> </span><span class="typ">TIn</span><span class="pun">?</span><span class="pln"> nullable</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> projection</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">where</span><span class="pln"> </span><span class="typ">TIn</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln">
        </span><span class="kwd">where</span><span class="pln"> </span><span class="typ">TOut</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nullable </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> projection</span><span class="pun">((</span><span class="typ">TIn</span><span class="pun">)</span><span class="pln">nullable</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">///&lt;summary&gt;Transforms a value and then does a combined transform involving the intermediate result, propagating any nulls.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">?</span><span class="pln"> </span><span class="typ">SelectMany</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="pln">
        </span><span class="kwd">this</span><span class="pln"> </span><span class="typ">TIn</span><span class="pun">?</span><span class="pln"> nullable</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">?&gt;</span><span class="pln"> midProjection</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> outProjection</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">where</span><span class="pln"> </span><span class="typ">TIn</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln">
        </span><span class="kwd">where</span><span class="pln"> </span><span class="typ">TMid</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln">
        </span><span class="kwd">where</span><span class="pln"> </span><span class="typ">TOut</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nullable </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">var</span><span class="pln"> mid </span><span class="pun">=</span><span class="pln"> midProjection</span><span class="pun">((</span><span class="typ">TIn</span><span class="pun">)</span><span class="pln">nullable</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mid </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> outProjection</span><span class="pun">((</span><span class="typ">TIn</span><span class="pun">)</span><span class="pln">nullable</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="typ">TMid</span><span class="pun">)</span><span class="pln">mid</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Once again, placing these extension methods in a static class should 
allow the nullable querying code from above to compile and run.</p>
<p>I hope these two examples have made it clear: to make some type M 
queryable, you implement Select and SelectMany methods that work with 
type M. You may be wondering how this all related to monads. Well here’s
 the important part: Select and SelectMany can be expressed in terms of 
Bind, which is a monad method. That means <em>any type that is a monad is queryable with linq</em>
 (you just need to implement Select/SelectMany). So you can use linq 
query expressions to inspect and produce sets, maps, tuples, pairs, 
maybes, parsers, futures, arrays, linked lists, trees, functions, 
observables, events, lists of trees, state, continuations, lists of 
trees, etc, etc, and etc (a lot of things are monads).</p>
<p><strong>Use #1: Types that are monads can be made queryable.</strong></p>
<p>Side note: implementing Bind is equivalent to implementing 
SelectMany. Both can be expressed in terms of the other. Given 
SelectMany, Bind is implemented as “from value in input from result in 
projection(value) select result”. Therefore, by writing an 
implementation of SelectMany for a type M, you are doing some of the 
work of explaining to the compiler how M is a monad.</p>
<h3>Hybrid Queries</h3>
<p>One thing you might notice, if you get on a “query everything” bender
 due to the information in the previous section, is that queries don’t 
work across different types. For example, this code fails to compile 
even if we can query lists and tasks:</p>
<pre><code class="prettyprint"><span class="com">// list then task</span><span class="pln">
</span><span class="kwd">from</span><span class="pln"> e </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">from</span><span class="pln"> r </span><span class="kwd">in</span><span class="pln"> e</span><span class="pun">.</span><span class="typ">DelayOneSecond</span><span class="pun">()</span><span class="pln"> </span><span class="com">// compile error</span><span class="pln">
</span><span class="kwd">select</span><span class="pln"> r </span><span class="pun">+</span><span class="pln"> e
</span><span class="com">// task then list</span><span class="pln">
</span><span class="kwd">from</span><span class="pln"> n </span><span class="kwd">in</span><span class="pln"> </span><span class="lit">10.DelayOneSecond</span><span class="pun">()</span><span class="pln">
</span><span class="kwd">from</span><span class="pln"> r </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">)</span><span class="pln"> </span><span class="com">// compile error</span><span class="pln">
</span><span class="kwd">select</span><span class="pln"> r </span><span class="pun">+</span><span class="pln"> n</span></code></pre>
<p>The problem is that the intermediate result is not the same type of 
monad as the input, and we don’t have a SelectMany defined for that 
case. The compiler is unable to guess what we want, which is to wait for
 all results to complete and then return a combined eventual result 
composed of all the final outputs. We need to explain what we want by 
implementing two hybrid SelectMany methods, which we will do by using 
our Task.Select extension method and Task.WhenAll from the base class 
library:</p>
<pre><code class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">TOut</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">SelectMany</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="pln">
        </span><span class="kwd">this</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">&gt;</span><span class="pln"> sequence</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TMid</span><span class="pun">&gt;&gt;</span><span class="pln"> midProjection</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> outProjection</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence
        </span><span class="pun">.</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">inp </span><span class="pun">=&gt;</span><span class="pln"> midProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">).</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">mid </span><span class="pun">=&gt;</span><span class="pln"> outProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">)))</span><span class="pln">
        </span><span class="pun">.</span><span class="typ">WhenAll</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">TOut</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">SelectMany</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="pln">
        </span><span class="kwd">this</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">&gt;</span><span class="pln"> sequence</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">TMid</span><span class="pun">&gt;&gt;</span><span class="pln"> midProjection</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> outProjection</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence
        </span><span class="pun">.</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">inp </span><span class="pun">=&gt;</span><span class="pln"> midProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">).</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">mid </span><span class="pun">=&gt;</span><span class="pln"> outProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">)));</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>For consistency I chose to give both of these variants of SelectMany 
the same output signature: eventual enumerable results (the query 
expression syntax doesn’t place constraints on the return type of 
SelectMany). However, note that if I’d instead tried to make them both 
return enumerable eventual results, I would have failed. I would have 
come up against the impossibility of determining (without blocking) if a
 sequence that wasn’t available yet had a first item.</p>
<p>It’s interesting that we can “flip” from enumerable eventual results 
to eventual enumerable results, but we can’t flip back. Lets explore 
other cases where we can flip the nesting of two monads. We’ll start 
with a peek at an (inefficient but correct) implementation of WhenAll, 
which we used to do the one “flip” we know can be done so far:</p>
<pre><code class="prettyprint"><span class="com">///&lt;summary&gt;Eventually returns all of the eventual results from the sequence.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">Task</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">WhenAll</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">Task</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> sequence</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence</span><span class="pun">.</span><span class="typ">Aggregate</span><span class="pun">(</span><span class="pln">
        </span><span class="typ">Task</span><span class="pun">.</span><span class="typ">FromResult</span><span class="pun">(</span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Empty</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;()),</span><span class="pln">
        </span><span class="pun">(</span><span class="pln">eventualAccumulator</span><span class="pun">,</span><span class="pln"> eventualItem</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
            </span><span class="kwd">from</span><span class="pln"> accumulator </span><span class="kwd">in</span><span class="pln"> eventualAccumulator
            </span><span class="kwd">from</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> eventualItem
            </span><span class="kwd">select</span><span class="pln"> accumulator</span><span class="pun">.</span><span class="typ">Concat</span><span class="pun">(</span><span class="kwd">new</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> item </span><span class="pun">}).</span><span class="typ">ToArray</span><span class="pun">().</span><span class="typ">AsEnumerable</span><span class="pun">());</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Notice that there are only two constructs in this method that are 
specific to tasks: Task.FromResult and Task.SelectMany (implicit in the 
query expression). I wonder what happens if we replace them by the 
equivalent constructs for nullable values / an option type? (Note: we 
need an option type that applies to any type equally, because 
IEnumerable is not a value type, so just imagine an option type called 
May.) Well, we get a method that returns no-value if any item in the 
list is a no-value and otherwise returns a normal list of values:</p>
<pre><code class="prettyprint"><span class="com">///&lt;summary&gt;Returns the potential values' values from the sequence, unless one of them is a lack-of-value, in which case the result is lack-of-value.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">May</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">MayGetAll</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">May</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> sequence</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence</span><span class="pun">.</span><span class="typ">Aggregate</span><span class="pun">(</span><span class="pln">
        </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">May</span><ienumerable<t><span class="pun">&gt;(</span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Empty</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;()),</span><span class="pln">
        </span><span class="pun">(</span><span class="pln">maybeAccumulator</span><span class="pun">,</span><span class="pln"> maybeItem</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
            </span><span class="kwd">from</span><span class="pln"> accumulator </span><span class="kwd">in</span><span class="pln"> maybeAccumulator
            </span><span class="kwd">from</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> maybeItem
            </span><span class="kwd">select</span><span class="pln"> accumulator</span><span class="pun">.</span><span class="typ">Concat</span><span class="pun">(</span><span class="kwd">new</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> item </span><span class="pun">}).</span><span class="typ">ToArray</span><span class="pun">().</span><span class="typ">AsEnumerable</span><span class="pun">());</span><span class="pln">
</span><span class="pun">}</span></ienumerable<t></code></pre>
<p>Seems like a useful method to have around.</p>
<p>Something even more interesting happens if we replace the Task 
constructs with their IEnumerable equivalents. We get a method that 
enumerates all the ways you can choose one item from each enumerated 
sequence from a sequence:</p>
<pre><code class="prettyprint"><span class="com">///&lt;summary&gt;Returns all of the ways you can choose one item from each sequence in a sequence.&lt;/summary&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">AllPossibilitiesForChoosingOneFromEach</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> sequence</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence</span><span class="pun">.</span><span class="typ">Aggregate</span><span class="pun">(</span><span class="pln">
        </span><span class="kwd">new</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Empty</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;()</span><span class="pln"> </span><span class="pun">}.</span><span class="typ">AsEnumerable</span><span class="pun">(),</span><span class="pln">
        </span><span class="pun">(</span><span class="pln">sequenceOfAccumulator</span><span class="pun">,</span><span class="pln"> sequenceOfItem</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
            </span><span class="kwd">from</span><span class="pln"> accumulator </span><span class="kwd">in</span><span class="pln"> sequenceOfAccumulator
            </span><span class="kwd">from</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> sequenceOfItem
            </span><span class="kwd">select</span><span class="pln"> accumulator</span><span class="pun">.</span><span class="typ">Concat</span><span class="pun">(</span><span class="kwd">new</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> item </span><span class="pun">}).</span><span class="typ">ToArray</span><span class="pun">().</span><span class="typ">AsEnumerable</span><span class="pun">());</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>I find this really interesting. Our method for awaiting a bunch of 
tasks is almost identical to a method that can be used to flatten nested
 loops:</p>
<pre><code class="prettyprint"><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i0 </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i1 </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i2 </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
            </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i3 </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                </span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> i4 </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
                    </span><span class="kwd">var</span><span class="pln"> I </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln">i0</span><span class="pun">,</span><span class="pln">i1</span><span class="pun">,</span><span class="pln">i2</span><span class="pun">,</span><span class="pln">i3</span><span class="pun">,</span><span class="pln">i4</span><span class="pun">};</span><span class="pln">
                    </span><span class="pun">...</span><span class="pln">
                </span><span class="pun">}</span><span class="pln">
            </span><span class="pun">}</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="com">// is functionally equivalent to</span><span class="pln">
</span><span class="kwd">foreach</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">var</span><span class="pln"> I </span><span class="kwd">in</span><span class="pln"> </span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Repeat</span><span class="pun">(</span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Range</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">),</span><span class="pln"> </span><span class="lit">5</span><span class="pun">)</span><span class="pln">
                  </span><span class="pun">.</span><span class="typ">AllPossibilitiesForChoosingOneFromEach</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>All of these apparently different methods are implemented in almost 
exactly the same way. It seems like as long as we have a type M that 
supports SelectMany and allows us to wrap the empty sequence into an 
instance, we can write a method that “flips” enumerable from being 
nested outside of M to being nested inside of M. Of course, as you may 
have guessed, <em>any type that is a monad supports both of the operations we need to “flip” enumerable inside of that type</em>.
 I’ve already mentioned monads have Bind, allowing us to implement 
SelectMany, but they also have ‘Return’ (wraps any value into the 
monad), which is exactly what we need to wrap our empty sequence as an 
M.</p>
<p><strong>Use #2: Types that are monads can be queried in combination with enumerable.</strong></p>
<p>There are other types of monads which allow this sort of “flipping” 
operation, but also some monads that don’t. As I’ve already mentioned, 
it doesn’t work with Task (it’s impossible to make an eventual result 
non-eventual). From what I’ve tried, it only seems to work on 
“collection-like” monads (in order to allow the aggregate call). So you 
can “flip” sets, maps, lists, trees, pairs, tuples, and options but not 
tasks, observables, parsers, or functions.</p>
<h3>Hypothetical Usage</h3>
<p>If the C# type system allowed us to represent monad as an interface 
(it doesn’t), we could implement all of the apparently distinct “flip 
enumerable” methods as a single method, which I will call BindAll:</p>
<pre><code class="prettyprint"><span class="com">///&lt;summary&gt;Pulls the monad type outside of the list type by binding across the list's elements.&lt;/summary&gt;</span><span class="pln">
</span><span class="com">///&lt;remarks&gt;Not actually possible to compile in C# today.&lt;/remarks&gt;</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> M</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">BindAll</span><span class="pun">&lt;</span><span class="pln">M</span><span class="pun">,</span><span class="pln"> T</span><span class="pun">&gt;(</span><span class="kwd">this</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="pln">M</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;&gt;</span><span class="pln"> sequence</span><span class="pun">)</span><span class="pln">
    </span><span class="kwd">where</span><span class="pln"> M </span><span class="pun">:</span><span class="pln"> </span><span class="typ">Monad</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">//&lt;-- Type parameter M takes a type parameter T. Not currently possible.</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence</span><span class="pun">.</span><span class="typ">Aggregate</span><span class="pun">(</span><span class="pln">
        M</span><span class="pun">.</span><span class="typ">Return</span><span class="pun">(</span><span class="typ">Enumerable</span><span class="pun">.</span><span class="typ">Empty</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;()),</span><span class="pln"> </span><span class="com">//&lt;-- Static interface method. Not currently possible.</span><span class="pln">
        </span><span class="pun">(</span><span class="pln">wrappedAccumulator</span><span class="pun">,</span><span class="pln"> wrappedNextItem</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
            </span><span class="kwd">from</span><span class="pln"> accumulator </span><span class="kwd">in</span><span class="pln"> wrappedAccumulator
            </span><span class="kwd">from</span><span class="pln"> item </span><span class="kwd">in</span><span class="pln"> wrappedNextItem
            </span><span class="kwd">select</span><span class="pln"> accumulator</span><span class="pun">.</span><span class="typ">Concat</span><span class="pun">(</span><span class="kwd">new</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> item </span><span class="pun">}).</span><span class="typ">ToArray</span><span class="pun">().</span><span class="typ">AsEnumerable</span><span class="pun">());</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>BindAll is a great example of the power a flexible type system can 
give. If we could only represent monads then we could fuse WhenAll, 
MayGetAll, AllPossibilitiesForChoosingOneFromEach, and plenty of other 
useful methods (for other types of monads) into a single method. Plus, 
we could implement a single SelectMany method to enable all hybrid 
queries where the input type is an enumerable:</p>
<pre><code class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">static</span><span class="pln"> M</span><span class="pun">&lt;</span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">TOut</span><span class="pun">&gt;&gt;</span><span class="pln"> </span><span class="typ">SelectMany</span><span class="pun">&lt;</span><span class="pln">M</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;(</span><span class="pln">
        </span><span class="kwd">this</span><span class="pln"> </span><span class="typ">IEnumerable</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">&gt;</span><span class="pln"> sequence</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> M</span><span class="pun">&lt;</span><span class="typ">TMid</span><span class="pun">&gt;&gt;</span><span class="pln"> midProjection</span><span class="pun">,</span><span class="pln">
        </span><span class="typ">Func</span><span class="pun">&lt;</span><span class="typ">TIn</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TMid</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TOut</span><span class="pun">&gt;</span><span class="pln"> outProjection</span><span class="pun">)</span><span class="pln">
        </span><span class="kwd">where</span><span class="pln"> M </span><span class="pun">:</span><span class="pln"> </span><span class="typ">Monad</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> sequence
        </span><span class="pun">.</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">inp </span><span class="pun">=&gt;</span><span class="pln"> midProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">).</span><span class="typ">Select</span><span class="pun">(</span><span class="pln">mid </span><span class="pun">=&gt;</span><span class="pln"> outProjection</span><span class="pun">(</span><span class="pln">inp</span><span class="pun">,</span><span class="pln"> mid</span><span class="pun">)))</span><span class="pln">
        </span><span class="pun">.</span><span class="typ">BindAll</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span></code></pre>
<p>Side note: this could potentially create an ambiguity with respect to
 what enumerating over two sequences means. Will it flatten the sequence
 of sequences via Enumerable.SelectMany or will it enumerate choice 
possibilities via our generic SelectMany using BindAll? Presumably the 
compiler would prefer the more specific overload: Enumerable.SelectMany.</p>
<h3>Conclusion</h3>
<p>LINQ allows you to take advantage of the fact that a particular type 
is a monad, by consuming and producing instances of that type via query 
expressions. You can even query (some) combinations of types. That might
 not seem like a lot of different uses, but the uses are very flexible 
and a great way to ease into functional programming. If C# had a type 
system capable of representing monads directly, instead of indirectly 
through compiler checks like "is there a SelectMany method?", there 
would be even more use cases.</p>
<p>---</p>
<h3><a href="http://www.reddit.com/r/programming/comments/12by2w/how_would_i_even_use_a_monad_in_c/">Discuss on Reddit</a></h3>
<p>---</p>

<blockquote><p>
<span style="color:#4A9EC2"><em><br>
Twisted Oak Studios offers efficient, flexible remote and on-the-floor 
development and consulting without any middle-man or excessive 
administrivia. <a href="mailto:contact@twistedoakstudios.com">Give us a shout</a> if you have anything you think some really rad engineers should help you with.<br>
</em></span>
</p></blockquote>
<h2>Older Posts</h2>
<p></p><ul>
     <li><a href="http://twistedoakstudios.com/blog/Post1295_publish-your-net-library-as-a-nuget-package" rel="bookmark" title="Permanent Link to Publish your .Net library as a NuGet package">Publish your .Net library as a NuGet package</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post1130_when-null-is-not-enough-an-option-type-for-c" rel="bookmark" title="Permanent Link to When null is not enough: an option type for C#">When null is not enough: an option type for C#</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post1473_unfathomable-bugs-5-readonly-or-not" rel="bookmark" title="Permanent Link to Unfathomable Bugs #5: Readonly or not">Unfathomable Bugs #5: Readonly or not</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post667_minkowski-sums-examples" rel="bookmark" title="Permanent Link to Minkowski sums: examples">Minkowski sums: examples</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post1080_my-bug-my-bad-1-fractal-spheres" rel="bookmark" title="Permanent Link to My Bug, My Bad #1: Fractal Spheres">My Bug, My Bad #1: Fractal Spheres</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post1007_working-around-the-brittle-ui-virtualization-in-windows-8" rel="bookmark" title="Permanent Link to Working around the brittle UI Virtualization in Windows 8">Working around the brittle UI Virtualization in Windows 8</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post938_encapsulating-angles" rel="bookmark" title="Permanent Link to Encapsulating Angles">Encapsulating Angles</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post925_unfathomable-bugs-4-keys-that-arent" rel="bookmark" title="Permanent Link to Unfathomable Bugs #4: Keys that aren’t">Unfathomable Bugs #4: Keys that aren’t</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post822_useful-methods-1-observable-wheneach" rel="bookmark" title="Permanent Link to Useful/Interesting Methods #1: Observable.WhenEach">Useful/Interesting Methods #1: Observable.WhenEach</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post818_unfathomable-bugs-3-stringing-you-along" rel="bookmark" title="Permanent Link to Unfathomable Bugs #3: Stringing you along">Unfathomable Bugs #3: Stringing you along</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post774_anonymous-implementation-classes-a-design-pattern-for-c" rel="bookmark" title="Permanent Link to Anonymous Implementation Classes – A Design Pattern for C#">Anonymous Implementation Classes – A Design Pattern for C#</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post532_tasks-for-action-script-3" rel="bookmark" title="Permanent Link to Tasks for ActionScript 3 – Improving on Event-Driven Programming">Tasks for ActionScript 3 – Improving on Event-Driven Programming</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post554_minkowski-sums-and-differences" rel="bookmark" title="Permanent Link to Minkowski sums and differences">Minkowski sums and differences</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post330_non-nullable-types-vs-c-fixing-the-billion-dollar-mistake" rel="bookmark" title="Permanent Link to Non-Nullable Types vs C#: Fixing the Billion Dollar Mistake">Non-Nullable Types vs C#: Fixing the Billion Dollar Mistake</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post384_unfathomable-bugs-2-slashing-out" rel="bookmark" title="Permanent Link to Unfathomable Bugs #2: Slashing Out">Unfathomable Bugs #2: Slashing Out</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post404_script-templates-and-base-classes" rel="bookmark" title="Permanent Link to Script templates and base classes">Script templates and base classes</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post373_unity-font-extraction" rel="bookmark" title="Permanent Link to Unity font extraction">Unity font extraction</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post341_abusing-phantom-types-to-encode-list-lengths-into-their-type" rel="bookmark" title="Permanent Link to Abusing “Phantom Types” to Encode List Lengths Into Their Type">Abusing “Phantom Types” to Encode List Lengths Into Their Type</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post261_constructive-criticism-of-the-reactive-extensions-api" rel="bookmark" title="Permanent Link to Constructive Criticism of the Reactive Extensions API">Constructive Criticism of the Reactive Extensions API</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post241_quaternions-part-3-2" rel="bookmark" title="Permanent Link to Quaternions part 3">Quaternions part 3</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post204_quaternions-part-2" rel="bookmark" title="Permanent Link to Quaternions part 2">Quaternions part 2</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post144_quaternions-part-1" rel="bookmark" title="Permanent Link to Quaternions part 1">Quaternions part 1</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post157_unfathomable-bugs-1-you-can-have-things-you-can-have-things-in-things-you-can-have" rel="bookmark" title="Permanent Link to Unfathomable Bugs #1: You can have things! You can have things IN things! You can have …">Unfathomable Bugs #1: You can have things! You can have things IN things! You can have …</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post83_coroutines-more-than-you-want-to-know" rel="bookmark" title="Permanent Link to Coroutines – More than you want to know">Coroutines – More than you want to know</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post74_asset-bundle-helper" rel="bookmark" title="Permanent Link to Asset Bundle Helper">Asset Bundle Helper</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post60_the-visual-studio-goes-away" rel="bookmark" title="Permanent Link to The Visual Studio goes away">The Visual Studio goes away</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post57_nets-time-traveling-stopwatch" rel="bookmark" title="Permanent Link to .Net’s time traveling StopWatch">.Net’s time traveling StopWatch</a></li>
     <li><a href="http://twistedoakstudios.com/blog/Post29_introducing-catalyst" rel="bookmark" title="Permanent Link to Introducing Catalyst">Introducing Catalyst</a></li>
  </ul>
<p></p>


			</div><!-- #content -->
			</section>

			</div>
		</div><!-- #container -->


</span></div><!-- .container -->


<!-- BEGIN footer-type stuff -->
<div class="container footer-container">
	<div class="row">
		
		<div class="fourcol last"><!-- .last b/c it's floated right -->
			<nav>
				<ul class="primary-nav clearfix">
					<li><a href="http://www.twistedoakstudios.com/">Home</a></li>
					<li><a href="http://twistedoakstudios.com/portfolio">Portfolio</a></li>
				</ul>
			</nav>
		</div>
		
		<div class="eightcol" id="contact">
			<p>Twisted Oak Studios<br>
				6082 Shirley Street<br>
				Halifax, NS, Canada B3H 2M8</p>
			
			<p>001-902-237-7326<br>
			<a href="mailto:contact@twistedoakstudios.com">contact@twistedoakstudios.com</a></p>
		</div>
		
		<div class="twelvecol">
			<footer>
				<small>©2012
					<script>
						var d=new Date(); 
						yr=d.getFullYear();
						if (yr!=2012)
						document.write("- "+yr);
					</script> Twisted Oak Studios Ltd. -- All Rights Reserved -- All images and logos are property of their respective owners.
				</small>
			</footer>
		</div>
		
		
	</div><!-- .row -->
</div><!-- .container -->
<!-- END footer stuff-->

<!-- jQuery and scrolly script for contact link -->
<script src="Post867_how-would-i-even-use-a-monad-in-c_files/jquery.js"></script>
  <script>window.jQuery || document.write('<script src="../js/libs/jquery-1.6.2.min.js"><\/script>')</script>

<script src="Post867_how-would-i-even-use-a-monad-in-c_files/scrolly.js"></script>


  <!-- Don't forget Analytics! -->



  <!-- Prompt IE 6 users to install Chrome Frame. Remove this if you want to support IE 6.
       chromium.org/developers/how-tos/chrome-frame-getting-started -->
  <!--[if lt IE 7 ]>
    <script src="//ajax.googleapis.com/ajax/libs/chrome-frame/1.0.3/CFInstall.min.js"></script>
    <script>window.attachEvent('onload',function(){CFInstall.check({mode:'overlay'})})</script>
  <![endif]-->
  

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-31441525-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script></body></html>