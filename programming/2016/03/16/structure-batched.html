<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="author" content="Craig Gidney">
    <meta name="keywords" content="computer science,algorithms,quantum computing,blog">
    <meta name="description" content="Craig Gidney's computer science blog">
    <title>Wrapping Structure Around Batched Methods</title>
    <link rel="shortcut icon" href="/assets/favicon.ico">
    <meta name="viewport" content="width=device-width">

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

    <!-- RSS autodiscovery -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

    <!-- Analytics -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-48771413-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="header">
      <a href="/"><img src="/assets/banner.png" alt="Algorithmic Assertions - Craig Gidney's Computer Science Blog" id="site_banner"/></a>
    </div>
    <div class="site">

      <h1 class="post_title">Wrapping Structure Around Batched Methods</h1>
<p class="meta">16 Mar 2016</p>

    <!-- MathJax latest -->
    <script async type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$']],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        TeX: {
          Macros: {
            ket: ["\\left|{#1}\\right\\rangle", 1],
            bra: ["\\left\\langle{#1}\\right|", 1],
            parens: ["\\left({#1}\\right)", 1],
            bracket: ["\\left[{#1}\\right]", 1],
            brace: ["\\left\\{ {#1} \\right\\}", 1],
            Sum: ["\\underset{#1}{\\overset{#2}{\\Sigma}}", 2],
            bimat: ["\\begin{bmatrix} {#1} & {#2} \\\\ {#3} & {#4} \\end{bmatrix}", 4]
          }
        }
      });
    </script>
    <noscript>
      <font color=red>
        MathJax was blocked.
        Formulas like <strong>$\frac{a}{b}$</strong> won't render into <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAYCAIAAACjjJBEAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFnSURBVDhPY/hPCCBU/P1wamJqZFpBTnJcqLl9142fUHGYip93Znopuc55+Pv/zyv16kJ+W99DJaAq/r3bGiLA67cFJPxuo5eI8bSHf8ASQABR8e1krhSr+ZwnQOGvx9LlFPNPvnv37vs/sBxExc/rrToy8Ye+/P/7ekeKFK/H2guLsvuvQlwCdcefF1sKPX3ic8qaJkzKsTcPSKzY8PQ3RArmUtyAWioYcAOoCvyAyiq+nusIVGdl0O6+/QsqAgYoZnw5nCSlkHfqG5QLAcgqflyuVZeI3PMJyoUCJBV/Hk43YRFySSvIDHXyrNr75i9EGKHi35t1HvxKxUc+/vv/cYe/qNGEu5CIQaj4cjBBSrn03HewYUZsStWXfoDF4Sp+351gKB688yMwOb5c4cwlmngA6h64ir9P59lr5Jz89v/nrQnWsl4LH0MjH8mWvx9OdEUFJ6TEhGXPu/IFkr5AAKECO/j/HwCRTZMPA+AaqQAAAABJRU5ErkJggg==" />.
      </font>
      <br>
      Allow scripts from <strong>algorithmicassertions.com</strong> and <strong>mathjax.org</strong> to fix.
      <hr/>
    </noscript>

<div class="post">
<p>In this post: working around WebGL&#39;s slow <code>readPixels</code> method by using batching, and a simple trick for avoiding error-prone concatenation and slicing by wrapping some structure around the resulting batched method.</p>

<h1>Motivation</h1>

<p>One of the side projects I work on is <a href="https://github.com/Strilanc/Quantum-Circuit-Inspector">an HTML5 quantum circuit simulator</a>.
It lets you drag gates around, and shows details about what a quantum circuit is doing.</p>

<p>Originally, the simulator did all the number-crunching in javascript.
However, since javascript isn&#39;t exactly fast and applying a gate to an $n$ qubit system takes $O(2^n)$ operations behind the scenes, the code wasn&#39;t scaling.
To keep things snappy, I decided to try doing the heavy work on the GPU via WebGL.</p>

<p>The main problem I ran into, when trying to use WebGL, besides the fact that shader compiler errors are totally useless, is that getting at the results of operations is very expensive.
Pulling data into javascript-land from GPU-land requires calling <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/readPixels"><code>WebGLRenderingContext.readPixels</code></a>, and <code>readPixels</code> is <em>slooooow</em>.
Every call takes a solid ten milliseconds.
When you&#39;re pulling dozens of different pieces of data off of the GPU, that adds up fast.</p>

<p>However, <code>readPixels</code> is basically the same speed regardless of how much data you read.
The slowness is not a bandwidth problem, it&#39;s a latency problem.
So a simple workaround is to batch the reads: instead of calling <code>readPixels</code> on ten individual textures, tack on some more shaders to merge all the data onto a single large texture then call <code>readPixels</code> just once on that.</p>

<p>Doing a single giant read fixed my WebGL performance problems, but introduced coding problems.
For example, having to split the code into a pixel-producing/processing phase followed by a pixel-consuming phase creates code duplication.
More importantly, it&#39;s difficult to abstract away the fact that results are textures under the hood when the centerpiece of the code is everyone putting their desired textures into a bucket.
The code has to collect all of those textures, concatenate them into a single array, run that array through the merged-read process, then carefully slice out the individual results.</p>

<p>Basically the code ended up looking like this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// === PRODUCE ===</span>
<span class="kd">let</span> <span class="nx">textures</span> <span class="o">=</span> <span class="p">[];</span>
<span class="kd">let</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">...</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">col</span> <span class="nx">of</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">cols</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nx">textures</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">wireProbabilities</span><span class="p">());</span> <span class="c1">// Intermediate wire probabilities.</span>
<span class="p">}</span>
<span class="nx">textures</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">amplitudes</span><span class="p">());</span> <span class="c1">// Final state.</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">numWires</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">textures</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">densityMatrixForWires</span><span class="p">([</span><span class="nx">i</span><span class="p">]));</span> <span class="c1">// Single-wire density matrices.</span>
<span class="p">}</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">numWires</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">textures</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">densityMatrixForWires</span><span class="p">([</span><span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]);</span> <span class="c1">// Paired-wire density matrices.</span>
<span class="p">}</span>

<span class="c1">// === ACQUIRE ===</span>
<span class="kd">let</span> <span class="nx">pixelDatas</span> <span class="o">=</span> <span class="nx">mergedReadPixels</span><span class="p">(</span><span class="nx">textures</span><span class="p">);</span>

<span class="c1">// === CONSUME ===</span>
<span class="kd">let</span> <span class="nx">probabilityDatas</span> <span class="o">=</span> <span class="nx">pixelDatas</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">cols</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">finalStateData</span> <span class="o">=</span> <span class="nx">pixelDatas</span><span class="p">[</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">cols</span><span class="p">.</span><span class="nx">length</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">singleWireDensities</span> <span class="o">=</span> <span class="nx">pixelDatas</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">cols</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">cols</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">numWires</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">pairedWireDensities</span> <span class="o">=</span> <span class="nx">pixelDatas</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="nx">circuit</span><span class="p">.</span><span class="nx">cols</span><span class="p">.</span><span class="nx">length</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">circuit</span><span class="p">.</span><span class="nx">numWires</span><span class="p">);</span> <span class="c1">// URGH.</span>
</code></pre></div>
<p>The big problem with the above code is those last four statements.
They are <em>very finnicky</em>.
Every time you change what&#39;s being computed, all those slice indices need to be updated.
Updating the indices is boring error-prone boilerplate work, and only gets worse as you think of more things to compute.</p>

<p>After making a slice mistake for the unpteen&#39;th time when touching this code, I decided something needed to be done about it.
I realized that, instead of taking an array, the method could take something with a bit more structure.
Even better, I realized that this structuring process could be done without touching the <code>mergedReadPixels</code> method.</p>

<h1>Batched to Structured</h1>

<p>Javascript makes it very easy to explore the fields of an object.
Just iterate over <code>Object.keys(obj)</code>, making sure to <a href="http://stackoverflow.com/questions/35878015/does-javascript-guarantee-that-enumerating-the-same-object-twice-will-go-over-th">do it in the same order each time</a>, and peek at <code>obj[key]</code> for each key.</p>

<p>By iterating over the fields of an object, and potentially exploring further inside each field, we can build up a mapping between those fields and the indices of an array.
Then, later, we can run that mapping in reverse to create a modified version of the object using values from a new array.
A caller can then use this process to wrap object-like structure around an array-like method.</p>

<p>Let&#39;s implement that.</p>

<p>First, we need a method to pull the values out of an object.
I arbitrarily decided to call it <code>decomp</code>.</p>

<p><em>(There&#39;s a lot of arbitrary design choices we can make in terms of the exact behavior of <code>decomp</code>. 
For example: should we only explore the top-level fields, or should we explore the whole tree looking for objects of a specified leaf type?
For simplicity, we&#39;ll limit <code>decomp</code>&#39;s exploration of the object to just top-level fields and arrays.)</em></p>

<p>Here&#39;s some code for <code>decomp</code>, in ES6 javascript.
We just iterate over the keys, and the items of array fields, while appending values into the result:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">decomp</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">object</span><span class="p">).</span><span class="nx">sort</span><span class="p">())</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">object</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">val</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// Array fields represent batches of work.</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="nx">of</span> <span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">val</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Second, we need an inverse method.
I called this method <code>recomp</code>.
It takes the original object, to guarantee the same field-index mapping happens, and the array of updated values.
It then creates a modified version of the object, with field keys defined by the given object and field values defined by the given array:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">recomp</span><span class="p">(</span><span class="nx">originalObject</span><span class="p">,</span> <span class="nx">updatedValsArray</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">key</span> <span class="nx">of</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">originalObject</span><span class="p">).</span><span class="nx">sort</span><span class="p">())</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">originalVal</span> <span class="o">=</span> <span class="nx">originalObject</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">originalVal</span><span class="p">))</span> <span class="p">{</span>
            <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="nx">of</span> <span class="nx">originalVal</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">updatedValsArray</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">result</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">updatedValsArray</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>Finally, we want a convenience method for wrapping <code>decomp</code> and <code>recomp</code> around arbitrary batched functions:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">structure</span><span class="p">(</span><span class="nx">batchedFunc</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span> <span class="o">=&gt;</span> <span class="nx">recomp</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">batchedFunc</span><span class="p">(</span><span class="nx">decomp</span><span class="p">(</span><span class="nx">obj</span><span class="p">)));</span>
<span class="p">}</span>
</code></pre></div>
<p>That&#39;s it!
Code that looked like this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">in_a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">in_b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">in_c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">22</span><span class="p">];</span>

<span class="kd">let</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">batchSquare</span><span class="p">(</span><span class="nx">in_a</span><span class="p">.</span><span class="nx">concat</span><span class="p">(</span><span class="nx">in_b</span><span class="p">,</span> <span class="nx">in_c</span><span class="p">));</span>
<span class="kd">let</span> <span class="nx">out_a</span> <span class="o">=</span> <span class="nx">out</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">out_b</span> <span class="o">=</span> <span class="nx">out</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">out_c</span> <span class="o">=</span> <span class="nx">out</span><span class="p">.</span><span class="nx">slice</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span> <span class="c1">// BLERGH</span>
</code></pre></div>
<p>Can now look like this:</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">inputs</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">3</span><span class="p">,</span>
  <span class="nx">b</span><span class="o">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span>
  <span class="nx">c</span><span class="o">:</span> <span class="mi">22</span>
<span class="p">};</span>

<span class="kd">let</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">structure</span><span class="p">(</span><span class="nx">batchSquare</span><span class="p">);</span>
<span class="kd">let</span> <span class="nx">out</span> <span class="o">=</span> <span class="nx">f</span><span class="p">(</span><span class="nx">inputs</span><span class="p">);</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">out</span><span class="p">);</span>
<span class="o">&gt;&gt;&gt;</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span><span class="mi">9</span><span class="p">,</span> <span class="nx">b</span><span class="o">:</span><span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">36</span><span class="p">,</span><span class="mi">25</span><span class="p">],</span> <span class="nx">c</span><span class="o">:</span><span class="mi">484</span><span class="p">}</span>
</code></pre></div>
<p>You can confirm the code works for yourself by running <a href="https://jsfiddle.net/sug6tj69/">the code on jsfiddle</a>.
(As long as your browser supports the basics of ES6.
I had to replace the <code>let</code>s with <code>var</code>s to make it work when I tested in firefox.)</p>

<h1>Summary</h1>

<p>Calling <code>readPixels</code> is expensive, but you can workaround the problem by batching many calls into one.</p>

<p>Concatenating and slicing data to/from batchable pieces is error-prone when done manually, but can be automated in a nice way without any help from the batched method.</p>

<p><em>(I&#39;m not sure if a simple trick like this &quot;deserves&quot; a post.
But as programmers we solve little problems like this every day; sometimes it&#39;s nice to write down the re-usable solutions.)</em></p>

</div>

<!-- IntenseDebate comments -->

  <script>
  var idcomments_acct = '7d0006bd6a016f9a2892cc2ecc64de01';
  var idcomments_post_id = '/programming/2016/03/16/structure-batched.html';
  var idcomments_post_url = 'http://algorithmicassertions.com/programming/2016/03/16/structure-batched.html';
  </script>
  <span id="IDCommentsPostTitle" style="display:none"></span>
  <script type='text/javascript' src='http://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
  <noscript>
    <hr>
    <font color=red>
      Comments script blocked. Comments won't work.
    </font>
    <br/>
    Allow scripts from <strong>algorithmicassertions.com</strong> and <strong>intensedebate.com</strong> to fix.
  </noscript>




    </div>

    <table style="width: 100%;">
      <tr>
        <td align="left">
          <a href="/quantum/2016/03/01/paper-as-problem-nonlocal-measurements-via-quantum-erasure.html">&laquo; Paper as Problem: 'Non-local measurements via quantum erasure'</a>
        </td>
        <td align="right">
          <a href="/programming/2016/03/27/protecting-control-flow-with-nested-evals.html">Protecting Control Flow with Nested Evals &raquo;</a>
        </td>
      </tr>
    </table>

    <div class="footer-container">
      <div class="site">
        <div class="footer">
          <div class="contact">
            by: Craig Gidney<br />
            more: <a href="/">All Posts</a>, <a href="/feed.xml">Posts Feed<img src="/assets/feed-icon.png" width="16px" alt="Posts Feed" title="Posts Feed" /></a><br/>
            meta: <a href="/about.html">About the Author/Blog</a><br/>
          </div>
          <div class="license">
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
              <img alt="Creative Commons License" style="border-width:0" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAYAAABjyArgAAAFOklEQVRo3u1aTU8bRxj2OVIs7lw4hhttlR5TpPQHkB+QiH9Q1FskqqCIVIpUCVmuoubQUKm3JrDG5sNfeA1rY3vX9noh5MpP4Ce81fOu32V2WfAHzhoTRhqx3pmdHZ595nk/ZmJEFI/FYnRfR1+J8Kf7Yye/TXvFXcqVslQ8KFDJKNFBtUxG3aAjs0r1Zo0arQZZbZOatkXNTtOttkWWbZLZanAf9K3UDX5WN0o8Vq6U47Hxjkw2TVt7KUrtaLS5vUEbmU9cP6U/0set/+5MVYC+ADev52j/sEjlik5G7ZDBarTqDGDbaVHnxCbnc4eOT4/p5Itbce18drgNfSzb4mfwLMYoV3UeE2MHQdZ2Nj2QAfAdBTnmB7daZgbWrBqzFaAB1NU3q/T056f0MP7w0lLAPbSt/r7KfdvHbf4oYHSlUWE27x/u+0BOZ7cotau5IGc2Rsbil8svaXZ29tIccQ9tYwEYsqCCC2CaHYtZmUgmaHp6um/dQd/Enwl+FhICNlc9kIueXGznMpTec0EeBYuTfyXp0ewjbx7z8/O0tLTEFddyH33QN1KAoZOQhQtwm8zEhWcLPvCmpqZocXGRVlZWSNd1rrjGPbSpffFspWZQy3FBBpMhF64mZ2m3sOOXihuweP3fDxSPx933LizQ2dkZBQvuoQ190DcKkD2AYdCgl5AFMDcILsADkOfn53RdWV9f9wENtgBkfDB8OLwDhq9QzlN2f8+VihAWD/qPCHPxodWiWHPfHGVukQGM5QujBM3F0lbBnZubC2XEVQUfAc+oTMaY0GS840IqFBbvpkjb3hxKJqCrwtwvp6c9AUYRJn9tTfYANlga6mzQoLkquL1Y2w/I0GQYPpaKukF6xWUxa3He1WKRiUEBFoM2CAnQVwxfJAAze22TpUEMGpa6bds0bAHIIhcYE2PDhRMWFw9cFqsexTAyIQYtWCAX8oGD0oEihi8SgKGPLafFrphMCpp70yJ6hwoXDitEtLjUddtUmRgWYHgKwRISVfkKnokMYERo9onNvqywV5UGeAvQLXx1VBX8YNva2prvHxEWY2xoMSK+SzKRy7jehKLDdwpgGDcsYQki1CUFAMP8XYCpaVpom/q8LFWMjYgPUlTtumyFcoG9CeiwuGt3UiKQTzg+dbwJqSwUYzUzM8PGAYDjGstf2sTTAODSFiYTCKubPh0u+Ny1YQC+zshdxd7IjRx8X+QVZEIAMTjJME3uR6/VFYB3wCc+Mo9GBrDqpvULcORu2iQDPGigIdobaaDRr0TA8MF1wzVAVSUi2BaVRExEqHydkbvOkPVj5IQxrpHr8LtGaeRUkNVkDz465oH3q0HPWJI94qZJiAzXKrjMr3LTALLcD7ahgNGqm9ZQ3LS8fnM3bSLSlRJoqGFy0J8dZaBx2A00kLqUQOOmCZ9bnXCvNsJD5UHi+3GFyhMBsJrs+fDP36NP9iQTPDaSPXiXpCzVxPuwyZ6JABh1+dWyl658/uK5D+RBkj5gfWi6sm3S6zevv8Xd5YsfS7/+wm5UZ4iEO9rQR024P/7xMUsD/Gx8wG90+95/47dXyxwMAGSVycNsGQHcVqdJ796/i+ocQmiQEewzVoA9kG130xOaPPCmZ1I2Pa3IwA2CF3Y9BnDDARa5ULftAVqvbXvsXPC2Pc5HtM3IZaFXuvJWSIRav//hO9LSGrtw8JNt7+CJoxw8cfieevAkldHoyU9PxnFU6TZJQ2+ApQKst3+8pWK5qByd6lYcnWqb3IY+4wB2Yhl8X0dQiejBPRBf73Tl/8YjNDN/aKmsAAAAAElFTkSuQmCC" />
            </a><br />
            This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
