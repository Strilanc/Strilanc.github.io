<!DOCTYPE html>
<html>
    <head lang="en">
        <meta charset="utf-8" />
        <link rel="shortcut icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAC4jAAAuIwF4pT92AAAOLklEQVR42u2de3BcVR3HP7vZNq+m9N5CCBCltFALVCRWnE61QyzgWF6tLTugM42M2IkNjBYF1mGojlMs3Ri0Y7ElMFYMIxbSgDiKONOROMhQQajYQh9KaLGWNMV7+8ijaZJd/zjn0m0mSfdu7j333t37ndnZZHfv63y/55zf+Z3fOb+IYRiEKFxEwyIIBRAiFECIUAAhQgGECAUQIhRAiFAAIUIBhAgFECIUgD0kk8l0MplMh8XqLOrr69P19fWulGvMYfKtf9OJRCISUucM+a2trR+Va3Nzc8R3LcAw8kkmk4QtgePk09raitMtQdRp8jNF4FazVQhIJpOnke+WCGJOkV8BXAWcDewE/iNv1o1mqxDIH6lSZYrAqXKN5BoPYN3kTGAesFy+98jv24FDwNuAtmgRDzz//Pnyq6JRhDcRmApUA5Xysy7gDeAAMGgaRqrQyc9EPB5nvCLISQCNyWSaZJKrgDnAhWP81hJEpKqKss5Op8rpOPAu8BrwKrAD+EBerhhIAd3AySCJxg75TonAtgCa1q5N39/YSLn1QVsb1NRAVRWUlMCJE9DZCdu3w9KlXpbnSWAvsAV4CegEBmQLNJrtMwD0yfcJQKl8zwa9QJdpGCedMPhUicCWAB5euzZ9fWMj8wDWrYO6OtC00Q8wTWhpgZUrC6HrPgnsB94C3pOC6AfeB96RPWKfbJ1SQDlQBsS+tWTJnvXPPjuui+cqgqwF8PM1a9ILm5qYA7BhA6xYkf1VNm6EhobQuhsB/ZpGiWk6cq5cRJDVMDCZTKYrm5q4FKC2VtR8O6irE8eFOA19lZWOkZ/rEDGaDfnJZJK/WAbdqlVQXm7vzsrLxXEhPsLBWbMo6+py/Lx2RRDN1iq9WY7xmT07tzuTx/XJjnEISAPpsjJkn2gXgXUyDZWWcsHu3a6d344IotkOScqBCICu53ZX8rhBaYYXWefr7YVIJBePZGCdS7G+Ptevka0IsvYEHnHoxiYNYy4CkC4cj7HfVDtqzUskEpFEIvHR/3+w2ulcVxLJ4wrZJ6zy2bMdEYzZ9GaKYDPCL8vOnbndUa7H5QOiUV+Sn9UoIJFIROLxOACPAqxeDT099u6op0ccV6g1P6XOG51IJGz5ArIyvpqbmyPxeJwfAgfb24V3zw5aWqC9PWz2FZBvNxDHliu4vr4+Pbm1lfVAaegKDjz5tgVgiaC2tZVliBgAH08GheS7IQDLRzAhmeQrwCVyLBnJ8M6kEA4fgBLELMlEOfY/DhxFzNkek/6FSvkdGec4bWA4aRLR7u4BeZloxs9OyBeIGbxu4ENgN7AdMSFTA3wK0IddphiYIm+hyEnOVJG/ALjm5ptZ8cQT6qaDM0WQTCZ5ALg6g8QPgF2IiXpNvqYC5wMG8Fvgr1IIqlQ+Hmi6Pg24HaiXIpqogvw7gMXAJ4FzEZ7TblluPbKS1YifdgG3m4bxR6UCyBSBH4c3qjHesqgAvg3UARdhK1avC1hsGsaruVx3XDGBskYqE4FfYwztkl8BzAJmyJp9sWzOryb76JMMfD9X8sctgFAE2ZN/GXAN8GXg08BZ4790D7AJeHw8J3FkYUihimAk8iuAc4DPIGZQr5Rkl8vXRGcu3Q38GPjReGMeI07uEjaeuDbVwx8nn3U68A1Zu6c7R/JYff7DQJMTAa8xJ+9M1khlIpC1T8kyNE3XI8B3gTlvzJ1726Jt2/g4MBe4zpkmPRucBNYDP3Eq2jnixj6B+dgSaLp+BdAmbTZSKF9a3QU8AjxkGsagUyeNuXGn+dYSaLq+APiZRT7qyT8C3A1sdnqdg2vP0dzcfFo8gQoRuLEgVdP1ZQj/1eUe2Zo9wB2mYTzlxiIXV4U8PKgkaCLQdH2RrPkVHpJ/u2kYz7p1gYiKvYKD5jHUdL0SaAKWeTjK7AHuMQ3jUTcvElPxJEHxE2i6XgU8BtyEt9gn7+Mxty8UU/VEfhaBputFkvSfAtM8Jv8gcKNpGG+ruJhSY1a1TZBNaLSm6xOAu3xAfjfQDMxURb4Ho5nTYwxViWA0w1DT9cnAn4F1HpOfRjh47jQNo0flhT3ZJs6KMfRydKDpehnQCnxe1X1YgTImYseLHYsXA3wBqDAN437TMIZUc+HZPoE+EMG9wBfdvu4J4B9AI2I2sAwRVfJIIkH1pk0R0zDaVdd6T4zA0USABx7DtcmkhojycQxWPFofwmf7L+BNYBtiu5xh3SB+2UYv4oecQar9BK/edhtzN292jPhdwC+lIeG2jyIvBeCFCKy+YEg201YQ60RZk/cAhxFxjhcAkxGrmg/LcdqeUWp3kMj3vAvw0k9gsXAY+L0cA/5TflYpm3En4dd4xpifbka1CEBE7wxHoZDv6ShgLBGodBa5DT+T70sB5JMI/E6+bwVgiUCln8CF+ycIW+T6OmGEameRk+QHZbt832cMCZoIgkR+IAQQJBEEjfzACMASgZ8Nw3g8ThCzpAQqaZRfRwdBsPbzQgB+FEGQyQ+kAPwkgqCTH1gB+EEE+UB+oAXgpQjyhfzACwCgo6ND+TWnT59OviDQAlC9CNVCPuVFjIbkF7YIoiH5hS2CaEh+YYsgGpJf2CIIjABGy6XrJxEEMVdyNCjkq4wTzBVuZPcueAEEhfygiiAakl/YIvCtAOrr6wNJfqYIgmAYRv1Kvp8NvnwaHUQLlfzPhSLwnwBUkb8QsTV72BL4aGmYKvLvBb4KzKiuJn3ggLLsHiq3tbUDX6wOdor8+YgMG1MQW2vuQOzKcTliU4YrgOs5bV/ffS8tWzZtwZNPKntWv0UOey6A8Q715gM3IhIufAKxA0cRYpO944hUtaWyrxuh1O8G1n8vkRgs1MwnMb+SPx+Yh8isoUsiz0bkzzkLsY4/gljnP5IhY+3PPwb2Ab8wDWMoIU9ViEkvPBPAI2vWpPWmJl4BLpS1NI3YsKFUvrJJ5ZVjCb4DfM00jOMZTXNBikB5F6Dp+rTtS5e+N6utjVL1z3sSeAH4pmkYh9zokoLWHSgVgKbrtceqq1+afOCAV8/bIsnv88OIxA+GoTIBaLpetH/27MELvcsivg+oMQ3jiJ+GpV6LIKqA+HM0XW/rq6z0kvxuYHm25IM/NrMMvAA0XT8XeCYdjS4p7eryivx3gAWmYWy1e2AhiCDqEvFFMtnCFqA2kkp5QXwP8BAwzzSM13M9Sb5kPlE2DNR0/WzEHry1HtX4g9LYe8g0jGMO9c9Kh4gq3caOGoGars8BHkXkTVSGFHB45kzO3bv3TuAp4KhpGGkXiMm7IWLMQfJjssmfprqd/9O117Jk69aPA/91I7GSVy2BCmeRk13AdarJ7wX+Pn8+S7ZurTANo1vRcC2vROCkEfgDp040gNhT/xBwFOEeTsumfkh+vwf4zcKFXP3yy5oq8jNF4LfMJ57aAJqux1LFxQPR/v6siH0f2Au8K/8fBI4hpm/flL+tQMzmXYWY3n0X6PCB4yQT+eAscqQL+PottwzcumULmxDJEQaHnXgQ4YQ/KknNBtbvXldUELkOEQl4htSYE7XgxS1b2I9IvuM2HrjvPr4jC0DT9aibRl8hiMC2DaDpenR4E3hcEfnPLV/O6sbG4oyPfBFnF2SPoS0bQNP1iUDKNIxB1f2ffFpT2oHFiHABq2c5IW3EAfl5TH7+N0Q6gB3A/xBxJDOAS4FqRABRnzQv3gLeNw3jpMwjOLxypMZK6qTpeulzy5f31jz+OP3SxikGqoCpQAmnYhcinApmGcr4PyqPmSC7zUOIGSxrAqMIManxAvCkQ11h1gLQdD1iOVc8In+8vqLMUxWN8L016LgA73IFZ4U3gSTwjAMiyLoLsMhXvUrXoTY+Kl9FI5BvfX8eIgLNP+S3tUFHB/T2Qiol3js6uKytjeWIrFe/HueqZFtdgFd5fQoO69ZBXR1o2hg10oSWFrauXMmvgP4c3cZZCyAkXxE2bIAVK7L+ee/GjextaOB5YFc8zkabIoiG5PsItbWi5ttAWV0dV9bWcgOwIweP4RkFoHqVbsGSD7BqFZSX2zumvBxWrWIaMBv7q5KjZyI/gAZfcDF7ds7HacBiYLpNP0E0JN9H0PWcjysCaqRjxI6zyBerg0PynUGlFIEjNoAq92ZIfgZynZmVxx1BZEKF7B1EY7YAbosgJH8Ycg2b37mTIWAz8Db2vINn7ALcEkFI/ghYvRp6euwd09MDq1djAhuBBpuu4aymg52e8ozH49DaGhtDgDFOrfQeQsyPlMn3IsQC4RnARYhFwNa8y6Xy80mBFEB7O7S02HIE0dLCUHs7u4BliQT32pwXsOUKdmJk4Hak6ygzeWdCyjSMIU3XSxETd6VSUJchth24WKm4bLiCWbmSD4EXGxq44cEH3XMFOyGCoGfakLEQ1nTzoPy7BrgLuAGYDA7uOtPWBjU1UFUFJSVw4gR0dsL27bB0Kf2IqOh/33orn3366SmmYRx1XQC5iiCISRVtiqNcthqXAJ3Ae7LbmiZblfOAm4AvIcIcc4KJCLt7DdgNTL/nHlY1NU0AhnJZC5FzUKgdEeQ7+SN0QSmLDCuOQrYemhRJlexWPoZw3k1FhEEeemPu3IaJ27YxGRG9UowImH0FEXW1A9gPdKE4ICRXERQS+VkKxAr+iUqjdjIiWgnTMAYAGurr0/2trRxA7GdYAvwOscrV6XIdd1j4WCIIyc9OECM13ZnlaoXIu1GujqwLGEkEfjP4ZM0bF8bqYzOa+pjsAlJjEZwNRpqGd7pSObY4NFMEmeRbBe/GYs1CQKYI3GhRHV0dbAUj5EtSRT+JQArA8XL1xU6hIbxDNCyCwobSjSLlGPksOR6ewKlFHlOAbaZhDIaUqMX/AX4zKOopgq7pAAAAAElFTkSuQmCC">
        <title>ZigXag</title>
    </head>
    <body style="margin: 0">
        <!-- Buttons -->
        <div style="margin: 5px;">
            <button id="export-button" style="min-width: 50px; min-height: 30px;">Export</button>
            &nbsp;
            &nbsp;
            <button id="clear-button" style="min-width: 50px; min-height: 30px;">Clear</button>
            &nbsp;
            &nbsp;
            <button id="undo-button" style="min-width: 50px; min-height: 30px;">Undo</button>
            <button id="redo-button" style="min-width: 50px; min-height: 30px;">Redo</button>
            &nbsp;
            &nbsp;
            &nbsp;
            &nbsp;
            <span style="color:#BBB">Version 0.1.dev</span>
        </div>

        <div id="err_div" style="display: none">
            <div style="color:red;" id="err_msg"></div>
            <div id="err_line"></div>
            <div id="err_gen"></div>
            <div id="err_time"></div>
            <button id="ack-error">ack</button>
        </div>
        <div id="main-canvas-div" style="width: 100%; touch-action: manipulation; tab-index: 0; position: relative; background: #fff;">
            <canvas id="main-canvas"></canvas>
        </div>

        <div><strong>In→Out Stabilizers for graph:</strong></div>
        <div id="stabilizers-div" style="font: 16px monospace; margin: 10px;">
        </div>

        <div id="export-div" style="display:none;">
    <div id="export-overlay" style="position:fixed; left: 0; top: 0; height: 100vh; width: 100vw; background: rgba(0, 0, 0, 0.7);">
    </div>
    <div style="position: absolute; top: 20px; left: 50px; padding: 20px; background-color: white; border: 1px solid black;">
        <strong>Text Diagram</strong>
        <div style="margin: 10px 0 0 20px;">
            <button tabindex="105" id="export-diagram-button">Generate and Copy to Clipboard</button>&nbsp;<span id="export-diagram-outcome"></span>
            <br>
            <pre tabindex="107" id="export-diagram-output" style="overflow:auto; max-width:600px; max-height:60px; border: 1px solid black; padding:5px; margin:2px;"></pre>
        </div>

        <br>
        <strong>QASM</strong>
        <div style="margin: 10px 0 0 20px;">
            <button tabindex="105" id="export-qasm-button">Generate and Copy to Clipboard</button>&nbsp;<span id="export-qasm-outcome"></span>
            <br>
            <pre tabindex="107" id="export-qasm-output" style="overflow:auto; max-width:600px; max-height:60px; border: 1px solid black; padding:5px; margin:2px;"></pre>
        </div>

        <br>
        <strong>Quirk URL</strong>
        <div style="margin: 10px 0 0 20px;">
            <button tabindex="105" id="export-quirk-button">Generate and Copy to Clipboard</button>&nbsp;<span id="export-quirk-outcome"></span>
            <br>
            <pre tabindex="107" id="export-quirk-output" style="overflow:auto; max-width:600px; max-height:60px; border: 1px solid black; padding:5px; margin:2px;"></pre>
        </div>
    </div>
</div>


        <script>

"use strict";
let _gen_packages_vals = new Map();
let _gen_packages_inits = new Map();
function _gen_package_export(key, vals) {
    let dict = _gen_packages_vals.get(key);
    for (let valKey of Object.keys(vals)) {
        dict[valKey] = vals[valKey];
    }
}
function _gen_package_get(key) {
    if (!_gen_packages_vals.has(key)) {
        _gen_packages_vals.set(key, new Map());
        if (!_gen_packages_inits.has(key)) {
            throw new Error(`Unknown import: "${key}"`);
        }
        _gen_packages_inits.get(key)();
    }
    return _gen_packages_vals.get(key);
}


///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Complex.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {Format} = _gen_package_get("src/base/Format.js");
const {Util} = _gen_package_get("src/base/Util.js");

/**
 * Represents a complex number like `a + b i`, where `a` and `b` are real values and `i` is the square root of -1.
 */
class Complex {
    /**
     * @param {!number} real The real part of the Complex number. The 'a' in a + bi.
     * @param {!number} imag The imaginary part of the Complex number. The 'b' in a + bi.
     */
    constructor(real, imag) {
        /**
         * The real part of the Complex number. The 'a' in a + bi.
         * @type {!number}
         */
        this.real = real;
        /**
         * The imaginary part of the Complex number. The 'b' in a + bi.
         * @type {!number}
         */
        this.imag = imag;
    }

    /**
     * Determines if the receiving complex value is equal to the given complex, integer, or float value.
     * This method returns false, instead of throwing, when given badly typed arguments.
     * @param {!number|!Complex|*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (other instanceof Complex) {
            return this.real === other.real && this.imag === other.imag;
        }
        if (typeof other === "number") {
            return this.real === other && this.imag === 0;
        }
        return false;
    }

    /**
     * Determines if the receiving complex value is near the given complex, integer, or float value.
     * This method returns false, instead of throwing, when given badly typed arguments.
     * @param {!number|!Complex|*} other
     * @param {!number} epsilon
     * @returns {!boolean}
     */
    isApproximatelyEqualTo(other, epsilon) {
        if (other instanceof Complex || typeof other === "number") {
            let d = this.minus(Complex.from(other));
            return Math.abs(d.real) <= epsilon &&
                Math.abs(d.imag) <= epsilon &&
                d.abs() <= epsilon;
        }
        return false;
    }

    /**
     * Wraps the given number into a Complex value (unless it's already a Complex value).
     * @param {!number|!Complex} v
     * @returns {!Complex}
     */
    static from(v) {
        if (v instanceof Complex) {
            return v;
        }
        if (typeof v === "number") {
            return new Complex(v, 0);
        }
        throw new DetailedError("Unrecognized value type.", {v});
    }

    /**
     * Returns a complex number with the given magnitude and phase.
     * @param {!number} magnitude Distance from origin.
     * @param {!number} phase Phase in radians.
     * @returns {!Complex}
     */
    static polar(magnitude, phase) {
        let [cos, sin] = Util.snappedCosSin(phase);
        return new Complex(magnitude * cos, magnitude * sin);
    }

    /**
     * Returns the real component of a Complex, integer, or float value.
     * @param {!number|!Complex} v
     * @returns {!number}
     */
    static realPartOf(v) {
        if (v instanceof Complex) {
            return v.real;
        }
        if (typeof v === "number") {
            return v;
        }
        throw new DetailedError("Unrecognized value type.", {v});
    }

    /**
     * Returns the imaginary component of a Complex value, or else 0 for integer and float values.
     * @param {!number|!Complex} v
     * @returns {!number}
     */
    static imagPartOf(v) {
        if (v instanceof Complex) {
            return v.imag;
        }
        if (typeof v === "number") {
            return 0;
        }
        throw new DetailedError("Unrecognized value type.", {v});
    }

    /**
     * Returns a compact text representation of the receiving complex value.
     * @param {=Format} format
     * @returns {!string}
     */
    toString(format) {
        format = format || Format.EXACT;

        return format.allowAbbreviation ?
            this._toString_allowSingleValue(format) :
            this._toString_bothValues(format);
    }

    /**
     * @param {!Format} format
     * @returns {!string}
     * @private
     */
    _toString_allowSingleValue(format) {
        if (Math.abs(this.imag) <= format.maxAbbreviationError) {
            return format.formatFloat(this.real);
        }
        if (Math.abs(this.real) <= format.maxAbbreviationError) {
            if (Math.abs(this.imag - 1) <= format.maxAbbreviationError) {
                return "i";
            }
            if (Math.abs(this.imag + 1) <= format.maxAbbreviationError) {
                return "-i";
            }
            return format.formatFloat(this.imag) + "i";
        }

        return this._toString_bothValues(format);
    }

    /**
     * @param {!Format} format
     * @returns {!string}
     * @private
     */
    _toString_bothValues(format) {
        let separator = this.imag >= 0 ? "+" : "-";
        let imagFactor = format.allowAbbreviation && Math.abs(Math.abs(this.imag) - 1) <= format.maxAbbreviationError ?
            "" :
            format.formatFloat(Math.abs(this.imag));
        let prefix = format.allowAbbreviation || format.fixedDigits === undefined || this.real < 0 ? "" : "+";
        return prefix + format.formatFloat(this.real) + separator + imagFactor + "i";
    }

    /**
     * Returns the squared euclidean length of the receiving complex value.
     * @returns {!number}
     */
    norm2() {
        return this.real * this.real + this.imag * this.imag;
    }

    /**
     * Returns the euclidean length of the receiving complex value.
     * @returns {!number}
     */
    abs() {
        return Math.sqrt(this.norm2());
    }

    /**
     * Returns the complex conjugate of the receiving complex value, with the same real part but a negated imaginary part.
     * @returns {!Complex}
     */
    conjugate() {
        return new Complex(this.real, -this.imag);
    }

    /**
     * Returns the negation of this complex value.
     * @returns {!Complex}
     */
    neg() {
        return new Complex(-this.real, -this.imag);
    }

    /**
     * Returns the angle, in radians, of the receiving complex value with 0 being +real-ward and τ/4 being +imag-ward.
     * Zero defaults to having a phase of zero.
     * @returns {!number}
     */
    phase() {
        return Math.atan2(this.imag, this.real);
    }

    /**
     * Returns a unit complex value parallel to the receiving complex value.
     * Zero defaults to having the unit vector 1+0i.
     * @returns {!Complex}
     */
    unit() {
        let m = this.norm2();
        if (m < 0.00001) {
            return Complex.polar(1, this.phase());
        }
        return this.dividedBy(Math.sqrt(m));
    }

    /**
     * Returns the sum of the receiving complex value plus the given value.
     * @param {!number|!Complex} v
     * @returns {!Complex}
     */
    plus(v) {
        let c = Complex.from(v);
        return new Complex(this.real + c.real, this.imag + c.imag);
    }

    /**
     * Returns the difference from the receiving complex value to the given value.
     * @param {!number|!Complex} v
     * @returns {!Complex}
     */
    minus(v) {
        let c = Complex.from(v);
        return new Complex(this.real - c.real, this.imag - c.imag);
    }

    /**
     * Returns the product of the receiving complex value times the given value.
     * @param {!number|!Complex} v
     * @returns {!Complex}
     */
    times(v) {
        let c = Complex.from(v);
        return new Complex(
            this.real * c.real - this.imag * c.imag,
            this.real * c.imag + this.imag * c.real);
    }

    /**
     * Returns the ratio of the receiving complex value to the given value.
     * @param {!number|!Complex} v
     * @returns {!Complex}
     */
    dividedBy(v) {
        let c = Complex.from(v);
        let d = c.norm2();
        if (d === 0) {
            throw new Error("Division by Zero");
        }

        let n = this.times(c.conjugate());
        return new Complex(n.real / d, n.imag / d);
    }

    sqrts() {
        let [r, i] = [this.real, this.imag];
        let m = Math.sqrt(Math.sqrt(r*r + i*i));
        if (m === 0) {
            return [Complex.ZERO];
        }
        if (i === 0 && r < 0) {
            return [new Complex(0, m), new Complex(0, -m)]
        }

        let a = this.phase() / 2;
        let c = Complex.polar(m, a);
        return [c, c.times(-1)];
    }

    /**
     * Returns the result of raising Euler's constant to the receiving complex value.
     * @returns {!Complex}
     */
    exp() {
        return Complex.polar(Math.exp(this.real), this.imag);
    }

    /**
     * Returns the natural logarithm of the receiving complex value.
     * @returns {!Complex}
     */
    ln() {
        return new Complex(Math.log(this.abs()), this.phase());
    }

    /**
     * Returns the result of raising the receiving complex value to the given complex exponent.
     * @param {!number|!Complex} exponent
     * @returns {!Complex}
     */
    raisedTo(exponent) {
        if (exponent === 0.5 && this.imag === 0 && this.real >= 0) {
            return new Complex(Math.sqrt(this.real), 0);
        }
        if (Complex.ZERO.isEqualTo(exponent)) {
            return Complex.ONE;
        }
        if (this.isEqualTo(Complex.ZERO)) {
            return Complex.ZERO;
        }
        return this.ln().times(Complex.from(exponent)).exp();
    }

    /**
     * Returns the distinct roots of the quadratic, or linear, equation.
     */
    static rootsOfQuadratic(a, b, c) {
        a = Complex.from(a);
        b = Complex.from(b);
        c = Complex.from(c);

        if (a.isEqualTo(0)) {
            if (!b.isEqualTo(0)) {
                return [c.times(-1).dividedBy(b)];
            }
            if (!c.isEqualTo(0)) {
                return [];
            }
            throw Error("Degenerate");
        }

        let difs = b.times(b).minus(a.times(c).times(4)).sqrts();
        let mid = b.times(-1);
        let denom = a.times(2);
        return difs.map(d => mid.minus(d).dividedBy(denom));
    }
}

/**
 * The complex number equal to zero.
 * @type {!Complex}
 */
Complex.ZERO = new Complex(0, 0);

/**
 * The complex number equal to one.
 * @type {!Complex}
 */
Complex.ONE = new Complex(1, 0);

/**
 * The square root of negative 1.
 * @type {!Complex}
 */
Complex.I = new Complex(0, 1);

_gen_package_export("src/base/Complex.js", {Complex});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Describe.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const COLLECTION_CUTOFF = 1000;
const BAD_TO_STRING_RESULT = new (function(){})().toString();
const RECURSE_LIMIT_DESCRIPTION = "!recursion-limit!";
const DEFAULT_RECURSION_LIMIT = 10;

function try_describe_atomic(value) {
    if (value === null) {
        return "null";
    }
    if (value === undefined) {
        return "undefined";
    }
    if (typeof value === "string") {
        return `"${value}"`;
    }
    if (typeof value === "number") {
        return "" + value;
    }
    return undefined;
}
function try_describe_collection(value, recursionLimit) {
    if (recursionLimit === 0) {
        return RECURSE_LIMIT_DESCRIPTION;
    }
    if (value instanceof Map) {
        return describe_Map(value, recursionLimit);
    }
    if (value instanceof Set) {
        return describe_Set(value, recursionLimit);
    }
    if (value[Symbol.iterator] !== undefined) {
        return describe_Iterable(value, recursionLimit);
    }
    return undefined;
}
function describe_fallback(value, recursionLimit) {
    let defaultString = String(value);
    if (defaultString !== BAD_TO_STRING_RESULT) {
        return defaultString;
    }
    return describe_Object(value, recursionLimit);
}

/**
 * Attempts to give a useful and unambiguous description of the given value.
 *
 * @param {*} value
 * @param {!int=} recursionLimit
 * @returns {!string}
 */
function describe(value, recursionLimit = DEFAULT_RECURSION_LIMIT) {
    return try_describe_atomic(value) ||
        try_describe_collection(value, recursionLimit) ||
        describe_fallback(value, recursionLimit);
}

/**
 * @param {!Map} map
 * @param {!int} limit
 * @returns {!string}
 */
function describe_Map(map, limit) {
    let entries = [];
    for (let [k, v] of map.entries()) {
        if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
        }
        //noinspection JSUnusedAssignment
        let keyDesc = describe(k, limit - 1);
        //noinspection JSUnusedAssignment
        let valDesc = describe(v, limit - 1);
        entries.push(`${keyDesc}: ${valDesc}`);
    }
    return `Map{${entries.join(", ")}}`;
}

/**
 * @param {!Set} set
 * @param {!int} limit
 * @returns {!string}
 */
function describe_Set(set, limit) {
    let entries = [];
    for (let e of set) {
        if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
        }
        entries.push(describe(e, limit - 1));
    }
    return `Set{${entries.join(", ")}}`;
}

/**
 * @param {!Iterable} seq
 * @param {!int} limit
 * @returns {!string}
 */
function describe_Iterable(seq, limit) {
    let entries = [];
    for (let e of seq) {
        if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
        }
        entries.push(describe(e, limit - 1));
    }
    let prefix = Array.isArray(seq) ? "" : seq.constructor.name;
    return `${prefix}[${entries.join(", ")}]`;
}

/**
 * @param {*} value
 * @param {!int} limit
 * @returns {!string}
 */
function describe_Object(value, limit) {
    let entries = [];
    for (let k in value) {
        if (!value.hasOwnProperty(k)) {
            continue;
        }
        if (entries.length > COLLECTION_CUTOFF) {
            entries.push("[...]");
            break;
        }
        let v = value[k];
        let keyDesc = describe(k, limit - 1);
        let valDesc = describe(v, limit - 1);
        entries.push(`${keyDesc}: ${valDesc}`);
    }

    let typeName = value.constructor.name;
    let prefix = typeName === {}.constructor.name ? "" : `(Type: ${typeName})`;
    return `${prefix}{${entries.join(", ")}}`;
}

_gen_package_export("src/base/Describe.js", {describe});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/DetailedError.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {describe} = _gen_package_get("src/base/Describe.js");

let CONSTRUCTOR_CALLS_NESTING = 0;

/**
 * A generic error with an attached payload of details for context.
 */
class DetailedError extends Error {
    /**
     * @param {!string} message
     * @param {*} detailsObj
     */
    constructor(message, detailsObj) {
        super(message);
        /** @type {*} */
        this.detailsObj = detailsObj;
        /** @type {!string} */
        this.name = 'Error';
        /** @type {!string} */
        this.message = message;
        /** @type {undefined|!string} */
        this.stack = new Error().stack;
        if (this.stack !== undefined) {
            this.stack = this.stack.replace(/^Error\n\s+at new DetailedError (\S+)\s?\n\s+at /, '\n    ');
        }

        CONSTRUCTOR_CALLS_NESTING++;
        try {
            /** @type {!string} */
            this.details = CONSTRUCTOR_CALLS_NESTING === 1 ?
                describe(this.detailsObj) :
                "(failed to describe detailsObj due to possibly re-entrancy)";
        } catch (ex) {
            console.error(ex);
            this.details = "(failed to describe detailsObj, see the console for details)";
        } finally {
            CONSTRUCTOR_CALLS_NESTING--;
        }
    }

    toString() {
        return `${super.toString()}\nDetails: ${this.details}`;
    }
}

_gen_package_export("src/base/DetailedError.js", {DetailedError});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Equate.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Determines if two values are currently equivalent.
 *
 * Values that are equal according to === are currently equivalent.
 * NaN is currently equivalent to NaN.
 * Values with an `isEqualTo` method are currently equivalent to values that return true when passed to that method.
 * Collections of the same type that contain currently equivalent entries are currently equivalent.
 * Objects of the same type with equivalent same own properties and iterables are currently equivalent.
 *
 * @param {*} subject
 * @param {*} other
 * @returns {!boolean}
 */
function equate(subject, other) {
    if (subject === other || (isExactlyNaN(subject) && isExactlyNaN(other))) {
        return true;
    }

    // Custom equality.
    let customEquality = tryEquate_custom(subject, other);
    if (customEquality !== undefined) {
        return customEquality;
    }
    if (isAtomic(subject) || isAtomic(other) || !eqType(subject, other)) {
        return false;
    }

    // Collection equality.
    if (subject instanceof Map) {
        return equate_Maps(subject, other);
    }
    if (subject instanceof Set) {
        return equate_Sets(subject, other);
    }
    if (isIndexable(subject)) {
        return equate_Indexables(subject, other);
    }

    // Object equality.
    return equate_Objects(subject, other);
}

const GENERIC_ARRAY_TYPES = [
    Float32Array,
    Float64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray
];

/**
 * @param {*} v
 * @returns {!boolean}
 */
function isExactlyNaN(v) {
    return typeof v === "number" && isNaN(v);
}

/**
 * @param {*} subject
 * @param {*} other
 * @returns {undefined|!boolean}
 */
function tryEquate_custom(subject, other) {
    if (!isAtomic(subject) && subject.constructor.prototype.hasOwnProperty("isEqualTo")) {
        return subject.isEqualTo(other);
    }
    if (!isAtomic(other) && other.constructor.prototype.hasOwnProperty("isEqualTo")) {
        return other.isEqualTo(subject);
    }
    return undefined;
}

/**
 * @param {*} value
 * @returns {!boolean}
 */
function isAtomic(value) {
    return value === null ||
        value === undefined ||
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean";
}

/**
 * @param {*} value
 * @returns {!boolean}
 */
function isIndexable(value) {
    return Array.isArray(value) || !GENERIC_ARRAY_TYPES.every(t => !(value instanceof t));
}

/**
 * @param {*} subject
 * @param {*} other
 * @returns {!boolean}
 */
function eqType(subject, other) {
    return subject.constructor.name === other.constructor.name;
}

/**
 * @param {!(*[])} subject
 * @param {!(*[])} other
 * @returns {!boolean}
 */
function equate_Indexables(subject, other) {
    if (subject.length !== other.length) {
        return false;
    }
    for (let i = 0; i < subject.length; i++) {
        if (!equate(subject[i], other[i])) {
            return false;
        }
    }
    return true;
}

/**
 * @param {!Iterable} subject
 * @param {!Iterable} other
 * @returns {!boolean}
 */
function equate_Iterables(subject, other) {
    let otherIter = other[Symbol.iterator]();
    for (let subjectItem of subject) {
        let otherItemDone = otherIter.next();
        if (otherItemDone.done || !equate(subjectItem, otherItemDone.value)) {
            return false;
        }
    }
    return otherIter.next().done;
}

/**
 * @param {!Map} subject
 * @param {!Map} other
 * @returns {!boolean}
 */
function equate_Maps(subject, other) {
    if (subject.size !== other.size) {
        return false;
    }
    for (let [k, v] of subject) {
        //noinspection JSUnusedAssignment
        if (!other.has(k)) {
            return false;
        }
        //noinspection JSUnusedAssignment
        let otherV = other.get(k);
        //noinspection JSUnusedAssignment
        if (!equate(v, otherV)) {
            return false;
        }
    }
    return true;
}

/**
 * @param {!Set} subject
 * @param {!Set} other
 * @returns {!boolean}
 */
function equate_Sets(subject, other) {
    if (subject.size !== other.size) {
        return false;
    }
    for (let k of subject) {
        if (!other.has(k)) {
            return false;
        }
    }
    return true;
}

/**
 * @param {!object} obj
 * @returns {!Set}
 */
function objectKeys(obj) {
    let result = new Set();
    for (let k in obj) {
        if (obj.hasOwnProperty(k)) {
            result.add(k);
        }
    }
    return result;
}

/**
 * @param {!object} subject
 * @param {!object} other
 * @returns {!boolean}
 */
function equate_Objects(subject, other) {
    let keys = objectKeys(subject);
    if (!equate_Sets(keys, objectKeys(other))) {
        return false;
    }

    for (let k of keys) {
        if (k === Symbol.iterator) {
            continue;
        }
        if (!equate(subject[k], other[k])) {
            return false;
        }
    }

    let hasSubjectIter = subject[Symbol.iterator] !== undefined;
    let hasOtherIter = other[Symbol.iterator] !== undefined;
    if (hasSubjectIter !== hasOtherIter) {
        return false;
    }
    if (hasSubjectIter && hasOtherIter) {
        if (!equate_Iterables(/** @type {!Iterable} */ subject, /** @type {!Iterable} */ other)) {
            return false;
        }
    }

    return true;
}

_gen_package_export("src/base/Equate.js", {equate, equate_Sets, equate_Maps, equate_Iterables});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Format.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * Stores formatting options, for determining what string output should look like.
 */
class Format {
    /**
     * @param {!boolean} allowAbbreviation
     * @param {!number} maxAbbreviationError
     * @param {int|undefined} fixedDigits
     * @param {!string} itemSeparator
     *
     * @property {!boolean} allowAbbreviation Should outputs be shortened, if possible?
     * @property {!number} maxAbbreviationError How much error is abbreviating allowed to introduce?
     * @property {int|undefined} fixedDigits Use toFixed? How many digits?
     * @property {!string} itemSeparator What should list items be separated by?
     */
    constructor(allowAbbreviation, maxAbbreviationError, fixedDigits, itemSeparator) {
        this.allowAbbreviation = allowAbbreviation;
        this.maxAbbreviationError = maxAbbreviationError;
        this.fixedDigits = fixedDigits;
        this.itemSeparator = itemSeparator;
    }

    formatFloat(f) {
        if (this.allowAbbreviation) {
            return abbreviateFloat(f, this.maxAbbreviationError, this.fixedDigits);
        }
        if (this.fixedDigits !== undefined) {
            return f.toFixed(this.fixedDigits);
        }
        return f + "";
    }

    /**
     * Parses the given text into a float. Works for text created by Format#formatFloat.
     * @param {!string} text
     * @throws
     * @returns {!number}
     */
    static parseFloat(text) {
        if (text.length === 0) {
            throw new Error("Not a number: '" + text + "'");
        }
        if (text[0] === "-") {
            return -Format.parseFloat(text.substr(1));
        }
        if (text[0] === "\u221A") {
            return Math.sqrt(Format.parseFloat(text.substr(1)));
        }

        let fraction = match(UNICODE_FRACTIONS, e => e.character === text);
        if (fraction !== undefined) {
            return fraction.value;
        }

        let result = parseFloat(text);
        if (isNaN(result)) {
            throw new Error("Not a number: '" + text + "'")
        }
        return result;
    }

    /**
     * Corrects a value to a nearby simple fraction or root thereof, such as sqrt(1/2), so it can be printed compactly.
     * @param {!number} value The value to round.
     * @param {!number} epsilon The maximum offset error introduced by the rounding.
     */
    static simplifyByRounding(value, epsilon) {
        if (value < 0) {
            return -Format.simplifyByRounding(-value, epsilon);
        }

        let r = value % 1;
        if (r <= epsilon || 1 - r <= epsilon) {
            return Math.round(value);
        }

        let fraction = match(UNICODE_FRACTIONS, e => Math.abs(e.value - value) <= epsilon);
        if (fraction !== undefined) {
            return fraction.value;
        }

        let rootFraction = match(UNICODE_FRACTIONS, e => Math.abs(Math.sqrt(e.value) - value) <= epsilon);
        if (rootFraction !== undefined) {
            return Math.sqrt(rootFraction.value);
        }

        return value;
    }
}

/**
 * @type {!(!{character: !string, expanded: !string, value: !number}[])}
 */
const UNICODE_FRACTIONS = [
    {character: "\u00BD", ref: "½", expanded: "1/2", value: 1/2},
    {character: "\u00BC", ref: "¼", expanded: "1/4", value: 1/4},
    {character: "\u00BE", ref: "¾", expanded: "3/4", value: 3/4},
    {character: "\u2153", ref: "⅓", expanded: "1/3", value: 1/3},
    {character: "\u2154", ref: "⅔", expanded: "2/3", value: 2/3},
    {character: "\u2155", ref: "⅕", expanded: "1/5", value: 1/5},
    {character: "\u2156", ref: "⅖", expanded: "2/5", value: 2/5},
    {character: "\u2157", ref: "⅗", expanded: "3/5", value: 3/5},
    {character: "\u2158", ref: "⅘", expanded: "4/5", value: 4/5},
    {character: "\u2159", ref: "⅙", expanded: "1/6", value: 1/6},
    {character: "\u215A", ref: "⅚", expanded: "5/6", value: 5/6},
    {character: "\u2150", ref: "⅐", expanded: "1/7", value: 1/7},
    {character: "\u215B", ref: "⅛", expanded: "1/8", value: 1/8},
    {character: "\u215C", ref: "⅜", expanded: "3/8", value: 3/8},
    {character: "\u215D", ref: "⅝", expanded: "5/8", value: 5/8},
    {character: "\u215E", ref: "⅞", expanded: "7/8", value: 7/8},
    {character: "\u2151", ref: "⅑", expanded: "1/9", value: 1/9},
    {character: "\u2152", ref: "⅒", expanded: "1/10",  value:1/10}
];

/**
 * Returns the first element of an array matching the given predicate, or else returns undefined.
 */
const match = function(array, predicate) {
    for (let item of array) {
        if (predicate(item)) {
            return item;
        }
    }
    return undefined;
};

/**
 * Returns a string representation of a float, taking advantage of unicode fractions and square roots.
 *
 * @param {!number} value The value to represent as a string.
 * @param {!number=} epsilon The maximum error introduced by using an expression.
 * @param {!number|undefined=} digits The number of digits to use if no expression matches.
 * @returns {!string}
 */
function abbreviateFloat(value, epsilon=0, digits=undefined) {
    if (Math.abs(value) < epsilon) {
        return "0";
    }
    if (value < 0) {
        return "-" + abbreviateFloat(-value, epsilon, digits);
    }

    let fraction = match(UNICODE_FRACTIONS, e => Math.abs(e.value - value) <= epsilon);
    if (fraction !== undefined) {
        return fraction.character;
    }

    let rootFraction = match(UNICODE_FRACTIONS, e => Math.abs(Math.sqrt(e.value) - value) <= epsilon);
    if (rootFraction !== undefined) {
        return "\u221A" + rootFraction.character;
    }

    if (value % 1 !== 0 && digits !== undefined) {
        return value.toFixed(digits);
    }

    return value.toString();
}

/**
 * Returns an accurate result, but favoring looking nice over being small.
 * @type {!Format}
 */
Format.EXACT = new Format(true, 0, undefined, ", ");

/**
 * Returns an accurate result, favoring being small over looking nice.
 * @type {!Format}
 */
Format.MINIFIED = new Format(true, 0, undefined, ",");

/**
 * Returns an approximated result, strongly favoring looking nice.
 * @type {!Format}
 */
Format.SIMPLIFIED = new Format(true, 0.0005, 3, ", ");

/**
 * Returns an approximated result, but with the constraint that when it changes slightly it should "look the same".
 * (It should look good when varying and animated.)
 * @type {!Format}
 */
Format.CONSISTENT = new Format(false, 0, 2, ", ");

_gen_package_export("src/base/Format.js", {Format, UNICODE_FRACTIONS});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/GeneralMap.js", function() {

/**
 * A Map that can use keys that aren't primitives. Assumes that the key's toString method returns an
 * appropriate key that respects the desired equality.
 */
const {equate_Maps} = _gen_package_get("src/base/Equate.js");;
const {seq} = _gen_package_get("src/base/Seq.js");;
const {DetailedError} = _gen_package_get("src/base/DetailedError.js");;

class GeneralMap {
    /**
     * @param {...[*, *]} entries
     */
    constructor(...entries) {
        this._items = /** @type {!Map.<!string, *>} */ new Map();
        for (let [key, val] of entries) {
            if (this.has(key)) {
                throw new DetailedError('Duplicate key during init.', {key, val});
            }
            this.set(key, val);
        }
    }

    /**
     * @returns {!Iterator.<*>}
     */
    entries() {
        return this._items.values();
    }

    /**
     * @returns {!Iterable.<*>}
     */
    keys() {
        return seq(this._items.values()).map(e => e[0])._iterable;
    }

    /**
     * @returns {!Iterable.<*>}
     */
    values() {
        return seq(this._items.values()).map(e => e[1])._iterable;
    }

    /**
     * @param {*} key
     * @param {*} value
     */
    set(key, value) {
        this._items.set(key.toString(), [key, value]);
    }

    /**
     * @param {*} key
     * @returns {!boolean}
     */
    has(key) {
        return this._items.has(key.toString());
    }

    /**
     * @param {*} key
     * @param {*} notPresentValue
     * @returns {undefined|*}
     */
    get(key, notPresentValue=undefined) {
        let entry = this._items.get(key.toString());
        return entry !== undefined ? entry[1] : notPresentValue;
    }

    /**
     * @param {*} key
     * @param {!function(): *} defaultValueProducer
     * @returns {*}
     */
    getOrInsert(key, defaultValueProducer) {
        let entry = this._items.get(key.toString());
        if (entry !== undefined) {
            return entry[1];
        }

        let val = defaultValueProducer();
        this.set(key, val);
        return val;
    }

    /**
     * @returns {!int}
     */
    get size() {
        return this._items.size;
    }

    //noinspection ReservedWordAsName
    /**
     * @param {*} key
     */
    delete(key) {
        this._items.delete(key.toString());
    }

    clear() {
        this._items.clear();
    }

    /**
     * @param {!GeneralSet|*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof GeneralMap && equate_Maps(this._items, other._items);
    }

    /**
     * @param {!function(value: *): *} valueFunc
     * @returns {!GeneralMap}
     */
    mapValues(valueFunc) {
        let result = new GeneralMap();
        for (let [k, v] of this.entries()) {
            result.set(k, valueFunc(v));
        }
        return result;
    }

    /**
     * @param {!function(value: *): *} keyFunc
     * @returns {!GeneralMap}
     */
    mapKeys(keyFunc) {
        let result = new GeneralMap();
        for (let [k, v] of this.entries()) {
            result.set(keyFunc(k), v);
        }
        if (result.size !== this.size) {
            throw new DetailedError('Irreversible key mapping.', {keyFunc, n1: this.size, n2: result.size});
        }
        return result;
    }

    /**
     * @returns {!string}
     */
    toString() {
        let vals = [...this._items.values()].map(e => `${e[0]}: ${e[1]}`);
        vals.sort();
        return '{' + vals.join(', ') + '}';
    }

    /**
     * @param {!Writer} out
     * @param {!function(*)} keyWrite
     * @param {!function(*)} valueWrite
     */
    write(out, keyWrite, valueWrite) {
        out.writeInt32(this.size);
        for (let [key, val] of this.entries()) {
            keyWrite(key);
            valueWrite(val);
        }
    }

    /**
     * @param {!Reader} inp
     * @param {!function(): *} keyRead
     * @param {!function(): *} valueRead
     * @returns {!GeneralMap.<*, *>} map
     */
    static read(inp, keyRead, valueRead) {
        let size = inp.readInt32();
        let result = new GeneralMap();
        for (let i = 0; i < size; i++) {
            let key = keyRead();
            let val = valueRead();
            result.set(key, val);
        }
        return result;
    }
}

_gen_package_export("src/base/GeneralMap.js", {GeneralMap});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/GeneralSet.js", function() {

const {equate_Maps} = _gen_package_get("src/base/Equate.js");;

/**
 * A Set that can contain objects that aren't primitives. Assumes that the object's toString method returns an
 * appropriate key that respects the desired equality.
 */
class GeneralSet {
    /**
     * @param {*} items
     */
    constructor(...items) {
        this._items = /** @type {!Map.<!string, *>} */ new Map();
        for (let item of items) {
            this.add(item);
        }
        this[Symbol.iterator] = () => this._items.values()[Symbol.iterator]();
    }

    /**
     * @param {*} item
     */
    add(item) {
        this._items.set(item.toString(), item);
    }

    /**
     * @param {*} item
     * @returns {!boolean}
     */
    has(item) {
        return this._items.has(item.toString());
    }

    //noinspection ReservedWordAsName
    /**
     * @param {*} item
     */
    delete(item) {
        this._items.delete(item.toString());
    }

    clear() {
        this._items.clear();
    }

    /**
     * @returns {!int}
     */
    get size() {
       return this._items.size;
    }

    /**
     * @param {!GeneralSet|*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof GeneralSet && equate_Maps(this._items, other._items);
    }

    /**
     * @returns {!string}
     */
    toString() {
        let vals = [...this._items.values()];
        vals.sort();
        return '{' + vals.join(', ') + '}';
    }
}

_gen_package_export("src/base/GeneralSet.js", {GeneralSet});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Matrix.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {Complex} = _gen_package_get("src/base/Complex.js");
const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {Format} = _gen_package_get("src/base/Format.js");
const {seq, Seq} = _gen_package_get("src/base/Seq.js");
const {Util} = _gen_package_get("src/base/Util.js");

/**
 * A matrix of complex values.
 * @class
 */
class Matrix {
    /**
     * @param {int} width
     * @param {int} height
     * @param {!Float64Array|!Float32Array} buffer Complex value data, packed row-wise with real and imaginary
     * coefficients interleaved.
     */
    constructor(width, height, buffer) {
        if (width*height*2 !== buffer.length) {
            throw new DetailedError("width*height*2 !== buffer.length", {width, height, len: buffer.length});
        }
        /**
         * @type {int}
         * @private
         */
        this._width = width;
        /**
         * @type {int}
         * @private
         */
        this._height = height;
        /**
         * @type {!Float32Array|!Float64Array}
         * @private
         */
        this._buffer = buffer;
    }

    /**
     * @param {int} col
     * @param {int} row
     * @returns {!Complex}
     */
    cell(col, row) {
        if (col < 0 || row < 0 || col >= this._width || row >= this._height) {
            throw new DetailedError("Cell out of range", {col, row, width: this._width, height: this._height});
        }
        let i = (this._width*row + col)*2;
        return new Complex(this._buffer[i], this._buffer[i + 1]);
    }

    /**
     * @returns {!Float64Array|!Float32Array}
     */
    rawBuffer() {
        return this._buffer;
    }

    /**
     * @returns {!Array.<!Array.<Complex>>}
     */
    rows() {
        return Seq.range(this._height).
            map(row => Seq.range(this._width).
                map(col => this.cell(col, row)).
                toArray()).
            toArray();
    }

    /**
     * @param rows {!Array.<!Array.<Complex>>} The rows of complex coefficients making up the matrix.
     */
    static fromRows(rows) {
        Util.need(Array.isArray(rows) && rows.every(Array.isArray), "array rows", rows);
        Util.need(rows.length > 0, "non-zero height", arguments);

        let seqRows = seq(rows);
        let h = rows.length;
        let w = seqRows.map(e => e.length).distinct().single(null);
        if (w === null) {
            throw new DetailedError("Inconsistent row widths.", {rows});
        }

        let buffer = new Float64Array(w * h * 2);
        let i = 0;
        for (let row of rows) {
            for (let cell of row) {
                buffer[i] = Complex.realPartOf(cell);
                buffer[i + 1] = Complex.imagPartOf(cell);
                i += 2;
            }
        }
        return new Matrix(w, h, buffer);
    }

    /**
     * Determines if the receiving matrix is equal to the given matrix.
     * This method returns false, instead of throwing, when given badly typed arguments.
     * @param {!Matrix|*} obj
     * @returns {!boolean}
     */
    isEqualTo(obj) {
        if (this === obj) {
            return true;
        }
        if (!(obj instanceof Matrix)) {
            return false;
        }

        /** @type {!Matrix} */
        let other = obj;
        return this._width === other._width &&
            this._height === other._height &&
            Seq.range(this._buffer.length).every(i => this._buffer[i] === other._buffer[i]);
    }

    /**
     * Determines if the receiving matrix is approximately equal to the given matrix.
     * @param {!Matrix|*} other
     * @param {!number} epsilon Maximum distance between the two matrices.
     * @returns {!boolean}
     */
    isApproximatelyEqualTo(other, epsilon) {
        return other instanceof Matrix &&
            this._width === other._width &&
            this._height === other._height &&
            Math.sqrt(this.minus(other).norm2()) <= epsilon;
    }

    /**
     * Returns a text representation of the receiving matrix.
     * (It uses curly braces so you can paste it into wolfram alpha.)
     * @param {=Format} format
     * @returns {!string}
     */
    toString(format = Format.EXACT) {
        let data = this.rows().
            map(row => row.
                map(e => e.toString(format)).
                join(format.itemSeparator)).
            join("}" + format.itemSeparator + "{");
        return "{{" + data + "}}";
    }

    /**
     * Returns a matrix of the given dimensions, using the given function to generate the coefficients.
     * @param {!int} width
     * @param {!int} height
     * @param {!function(row: !int, col: !int): (!number|!Complex)} coefficientRowColGenerator
     * @returns {!Matrix}
     */
    static generate(width, height, coefficientRowColGenerator) {
        let buf = new Float64Array(width*height*2);
        for (let r = 0; r < height; r++) {
            for (let c = 0; c < width; c++) {
                let k = (r*width + c)*2;
                let v = coefficientRowColGenerator(r, c);
                buf[k] = Complex.realPartOf(v);
                buf[k+1] = Complex.imagPartOf(v);
            }
        }
        return new Matrix(width, height, buf);
    }

    /**
     * Returns a diagonal matrix of the given size, using the given function to generate the diagonal coefficients.
     * @param {!int} size
     * @param {!function(!int): (!number|!Complex)} coefficientFunc
     * @returns {!Matrix}
     */
    static generateDiagonal(size, coefficientFunc) {
        let buf = new Float64Array(size*size*2);
        for (let i = 0; i < size; i++) {
            let k = i*(size+1)*2;
            let v = coefficientFunc(i);
            buf[k] = Complex.realPartOf(v);
            buf[k+1] = Complex.imagPartOf(v);
        }
        return new Matrix(size, size, buf);
    }

    /**
     * Returns a matrix of the given size, with each column being mapped to a row by the transition function.
     * @param {!int} size
     * @param {!function(!int): !int} transitionFunc
     * @returns {!Matrix}
     */
    static generateTransition(size, transitionFunc) {
        let buf = new Float64Array(size*size*2);
        for (let c = 0; c < size; c++) {
            let r = transitionFunc(c);
            let k = (r*size + c)*2;
            buf[k] = 1;
        }
        return new Matrix(size, size, buf);
    }

    /**
     * Returns a zero matrix of the given size.
     * @param {!number} width
     * @param {!number} height
     * @returns {!Matrix}
     */
    static zero(width, height) {
        return new Matrix(width, height, new Float64Array(width*height*2));
    }

    /**
     * @param {!Matrix} other
     * @param {!boolean} alsoMatchMagnitude
     * @returns {!Matrix}
     */
    phaseMatchedTo(other, alsoMatchMagnitude=false) {
        let w = Math.min(this._width, other._width);
        let h = Math.min(this._height, other._height);
        let bestRow = 0;
        let bestCol = 0;
        let bestScore = -1;
        for (let row = 0; row < h; row++) {
            for (let col = 0; col < w; col++) {
                let score = Math.min(this.cell(col, row).norm2(), other.cell(col, row).norm2());
                if (score > bestScore) {
                    bestScore = score;
                    bestRow = row;
                    bestCol = col;
                }
            }
        }
        let a = this.cell(bestCol, bestRow);
        let b = other.cell(bestCol, bestRow);
        let s;
        if (alsoMatchMagnitude && b.abs() !== 0) {
            s = b.dividedBy(a);
        } else {
            let angle1 = a.phase();
            let angle2 = b.phase();
            s = Complex.polar(1, angle2 - angle1);
        }
        return this.times(s);
    }

    /**
     * Returns a 1x1 matrix containing the given value.
     * @param {!number|!Complex} coef
     * @returns {!Matrix}
     */
    static solo(coef) {
        return new Matrix(1, 1, new Float64Array([Complex.realPartOf(coef), Complex.imagPartOf(coef)]));
    }

    /**
     * Converts the given square block of coefficients into a square complex matrix.
     * @param {!number|!Complex} coefs The coefficients of the matrix,
     * arranged in a flat array of square length with the coefficients (which can be numeric or complex) in row order.
     * @returns {!Matrix}
     */
    static square(...coefs) {
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        let n = Math.round(Math.sqrt(coefs.length));
        Util.need(n * n === coefs.length, "Matrix.square: non-square number of arguments");
        return Matrix.generate(n, n, (r, c) => coefs[r * n + c]);
    }

    /**
     * Converts the array of complex coefficients into a column vector.
     * @param {!number|!Complex} coefs
     * @returns {!Matrix}
     */
    static col(...coefs) {
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        return Matrix.generate(1, coefs.length, r => coefs[r]);
    }

    /**
     * Converts the array of complex coefficients into a row vector.
     * @param {!number|!Complex} coefs
     * @returns {!Matrix}
     */
    static row(...coefs) {
        Util.need(Array.isArray(coefs), "Array.isArray(coefs)", arguments);
        return Matrix.generate(coefs.length, 1, (r, c) => coefs[c]);
    }

    /**
     * Returns the width of the receiving matrix.
     * @returns {!int}
     */
    width() {
        return this._width;
    }

    /**
     * Returns the height of the receiving matrix.
     * @returns {!int}
     */
    height() {
        return this._height;
    }

    /**
     * @param {!number} atol
     * @returns {!boolean}
     */
    isZero(atol=0.0) {
        for (let r of this._buffer) {
            if (Math.abs(r) > atol) {
                return false;
            }
        }
        return true;
    }

    /**
     * Determines if the matrix is approximately unitary or not.
     * @param {!number} epsilon Distance away from unitary the matrix is allowed to be. Defaults to 0.
     * @returns {!boolean}
     */
    isUnitary(epsilon) {
        let n = this.width();
        if (this.height() !== n) {
            return false;
        }
        return this.times(this.adjoint()).isApproximatelyEqualTo(Matrix.identity(n), epsilon);
    }

    /**
     * @param {!number=} epsilon
     * @returns {!boolean}
     */
    isLowerTriangular(epsilon=0) {
        for (let r = 0; r < this._height; r++) {
            for (let c = r + 1; c < this._width; c++) {
                let k = (r*this._width + c)*2;
                let v1 = this._buffer[k];
                let v2 = this._buffer[k+1];
                if (isNaN(v1) || isNaN(v2) || v1*v1 + v2*v2 > epsilon*epsilon) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * @param {!number=} epsilon
     * @returns {!boolean}
     */
    isUpperTriangular(epsilon=0) {
        for (let r = 0; r < this._height; r++) {
            for (let c = 0; c < r && c < this._width; c++) {
                let k = (r*this._width + c)*2;
                let v1 = this._buffer[k];
                let v2 = this._buffer[k+1];
                if (isNaN(v1) || isNaN(v2) || v1*v1 + v2*v2 > epsilon*epsilon) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Determines if the matrix can be factored into a permutation matrix times a diagonal matrix.
     * @param {!number=} epsilon
     * @returns {!boolean}
     */
    isPhasedPermutation(epsilon = 0) {
        if (this._width !== this._height) {
            return false;
        }

        let n = this._width;
        let colCounts = new Uint32Array(n);
        let rowCounts = new Uint32Array(n);

        // Count number of non-zero elements in each row and column.
        for (let col = 0; col < n; col++) {
            for (let row = 0; row < n; row++) {
                let i = (row*n + col)*2;
                let m = Math.max(Math.abs(this._buffer[i]), Math.abs(this._buffer[i+1]));
                if (isNaN(m) || m > epsilon) {
                    colCounts[col] += 1;
                    rowCounts[row] += 1;
                }
            }
        }

        // Phased permutations have at most one entry in each row and column.
        return seq(colCounts).concat(rowCounts).every(e => e <= 1);
    }

    /**
     * Determines if the matrix is approximately equal to its own conjugate transpose or not.
     * @param {!number} epsilon Maximum error per entry.
     * @returns {!boolean}
     */
    isApproximatelyHermitian(epsilon) {
        if (this._width !== this._height) {
            return false;
        }
        for (let c = 0; c < this._width; c++) {
            for (let r = 0; r < this._height; r++) {
                let i = (this._width*r + c)*2;
                let j = (this._width*c + r)*2;
                if (Math.abs(this._buffer[i] - this._buffer[j]) > epsilon) {
                    return false;
                }
                if (Math.abs(this._buffer[i+1] + this._buffer[j+1]) > epsilon) {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * Determines if the matrix is an identity matrix.
     * @param {!number} epsilon
     * @returns {!boolean}
     */
    isIdentity(epsilon=0) {
        if (this._width !== this._height) {
            return false;
        }
        for (let c = 0; c < this._width; c++) {
            for (let r = 0; r < this._height; r++) {
                let i = (this._width*r + c)*2;
                let dr = Math.abs(this._buffer[i] - (r === c ? 1 : 0));
                let di = Math.abs(this._buffer[i+1]);
                if (Math.max(dr, di) > epsilon) {
                    return false;
                }
            }
        }
        return !this.hasNaN();
    }

    /**
     * Determines if the matrix is a scaled identity matrix.
     * @param {!number} epsilon
     * @returns {!boolean}
     */
    isScaler(epsilon=0) {
        if (this._width !== this._height) {
            return false;
        }
        let sr = this._buffer[0];
        let si = this._buffer[1];
        for (let c = 0; c < this._width; c++) {
            for (let r = 0; r < this._height; r++) {
                let i = (this._width*r + c)*2;
                let dr = Math.abs(this._buffer[i] - (r === c ? sr : 0));
                let di = Math.abs(this._buffer[i+1] - (r === c ? si : 0));
                if (Math.max(dr, di) > epsilon) {
                    return false;
                }
            }
        }
        return !this.hasNaN();
    }

    /**
     * Determines if the matrix contains a NaN.
     * @returns {!boolean}
     */
    hasNaN() {
        for (let i = 0; i < this._buffer.length; i++) {
            if (isNaN(this._buffer[i])) {
                return true;
            }
        }
        return false;
    }

    /**
     * Determines if the matrix is square and only has entries along its main diagonal.
     * @param {!number=} epsilon
     * @returns {!boolean}
     */
    isDiagonal(epsilon=0) {
        for (let c = 0; c < this._width; c++) {
            for (let r = 0; r < this._height; r++) {
                if (r === c) {
                    continue;
                }
                let k = (this._width*r + c)*2;
                let dr = Math.abs(this._buffer[k]);
                let di = Math.abs(this._buffer[k+1]);
                let d = Math.max(dr, di);
                if (isNaN(d) || d > epsilon) {
                    return false;
                }
            }
        }
        return this._width === this._height;
    }

    /**
     * Returns the conjugate transpose of the receiving operation (the adjoint is the inverse when the matrix is unitary).
     * @returns {!Matrix}
     */
    adjoint() {
        let w = this._height;
        let h = this._width;
        let newBuf = new Float64Array(w*h*2);
        for (let r = 0; r < h; r++) {
            for (let c = 0; c < w; c++) {
                let kIn = (c*this._width + r)*2;
                let kOut = (r*w + c)*2;
                newBuf[kOut] = this._buffer[kIn];
                newBuf[kOut+1] = -this._buffer[kIn+1];
            }
        }
        return new Matrix(w, h, newBuf);
    }

    /**
     * @returns {!Matrix} The transpose of the receiving matrix.
     */
    transpose() {
        let w = this._height;
        let h = this._width;
        let newBuf = new Float64Array(w*h*2);
        for (let r = 0; r < h; r++) {
            for (let c = 0; c < w; c++) {
                let kIn = (c*this._width + r)*2;
                let kOut = (r*w + c)*2;
                newBuf[kOut] = this._buffer[kIn];
                newBuf[kOut+1] = this._buffer[kIn+1];
            }
        }
        return new Matrix(w, h, newBuf);
    }

    /**
     * Returns the matrix' trace (i.e. the sum of its diagonal elements, i.e. the sum of its eigenvalues
     * if it's square).
     * @returns {!Complex}
     */
    trace() {
        let total_r = 0;
        let total_i = 0;
        let d = this._width*2 + 2;
        for (let i = 0; i < this._buffer.length; i += d) {
            total_r += this._buffer[i];
            total_i += this._buffer[i+1];
        }
        return new Complex(total_r, total_i);
    }

    /**
     * Returns the result of scaling the receiving matrix by the given scalar factor.
     * @param {!number|!Complex} v
     * @returns {!Matrix}
     * @private
     */
    _timesScalar(v) {
        let newBuffer = new Float64Array(this._buffer.length);
        let sr = Complex.realPartOf(v);
        let si = Complex.imagPartOf(v);
        for (let i = 0; i < newBuffer.length; i += 2) {
            let vr = this._buffer[i];
            let vi = this._buffer[i + 1];
            newBuffer[i] = vr*sr - vi*si;
            newBuffer[i + 1] = vr*si + vi*sr;
        }
        return new Matrix(this._width, this._height, newBuffer);
    }

    /**
     * Returns the sum of the receiving matrix and the given matrix.
     * @param {!Matrix} other
     * @returns {!Matrix}
     */
    plus(other) {
        let {_width: w, _height: h, _buffer: b1} = this;
        let b2 = other._buffer;
        Util.need(other._width === w && other._height === h, "Matrix.plus: compatible sizes");

        let newBuffer = new Float64Array(this._buffer.length);
        for (let i = 0; i < newBuffer.length; i++) {
            newBuffer[i] = b1[i] + b2[i];
        }
        return new Matrix(w, h, newBuffer);
    }

    /**
     * Returns the difference from the receiving matrix to the given matrix.
     * @param {!Matrix} other
     * @returns {!Matrix}
     */
    minus(other) {
        let {_width: w, _height: h, _buffer: b1} = this;
        let b2 = other._buffer;
        Util.need(other._width === w && other._height === h, "Matrix.minus: compatible sizes");

        let newBuffer = new Float64Array(this._buffer.length);
        for (let i = 0; i < newBuffer.length; i++) {
            newBuffer[i] = b1[i] - b2[i];
        }
        return new Matrix(w, h, newBuffer);
    }

    /**
     * Returns the matrix product (i.e. the composition) of the receiving matrix and the given matrix.
     * @param {!Matrix} other
     * @returns {!Matrix}
     * @private
     */
    _timesMatrix(other) {
        if (this._width !== other._height) {
            throw new DetailedError("Incompatible sizes.", {'this': this, other})
        }
        let w = other._width;
        let h = this._height;
        let n = this._width;
        let newBuffer = new Float64Array(w*h*2);
        for (let r = 0; r < h; r++) {
            for (let c = 0; c < w; c++) {
                let k3 = (r*w + c)*2;
                for (let k = 0; k < n; k++) {
                    let k1 = (r*n + k)*2;
                    let k2 = (k*w + c)*2;
                    let r1 = this._buffer[k1];
                    let i1 = this._buffer[k1+1];
                    let r2 = other._buffer[k2];
                    let i2 = other._buffer[k2+1];
                    let r3 = r1*r2 - i1*i2;
                    let i3 = r1*i2 + r2*i1;
                    newBuffer[k3] += r3;
                    newBuffer[k3+1] += i3;
                }
            }
        }
        return new Matrix(w, h, newBuffer);
    }

    /**
     * Returns the product of the receiving matrix and the given matrix or scalar.
     * @param {!Matrix|!number|!Complex} other A matrix or a scalar value.
     * @returns {!Matrix}
     */
    times(other) {
        //noinspection JSCheckFunctionSignatures
        return other instanceof Matrix ? this._timesMatrix(other) : this._timesScalar(other);
    }

    /**
     * Expands a qubit operation so that it applies to a larger register of qubits, with optional controls.
     * @param {!int} targetQubitOffset
     * @param {!int} registerSize
     * @param {!Controls} controls
     * @returns {!Matrix}
     */
    expandedForQubitInRegister(targetQubitOffset, registerSize, controls) {
        let used = Math.round(Math.log2(this._width));
        let result = Matrix.identity(1 << (registerSize - targetQubitOffset - used)).
            tensorProduct(this).
            tensorProduct(Matrix.identity(1 << targetQubitOffset)).
            _clone();

        for (let c = 0; c < result._width; c++) {
            for (let r = 0; r < result._height; r++) {
                if (!controls.allowsState(c) || !controls.allowsState(r)) {
                    let k = 2*(c + r*result._width);
                    result._buffer[k] = c === r ? 1 : 0;
                    result._buffer[k+1] = 0;
                }
            }
        }

        return result;
    }

    /**
     * @param {!Matrix} stateVector
     * @param {!int} qubitIndex
     * @param {!Controls} controls
     * @returns {!Matrix}
     */
    applyToStateVectorAtQubitWithControls(stateVector, qubitIndex, controls) {
        let chunkSize = this._width*2;
        let chunkBuf = stateVector._buffer.slice(0, chunkSize);
        let strideLength = 2 << qubitIndex;
        let strideChunkSize = strideLength*chunkSize >> 1;
        let resultBuf = stateVector._buffer.slice();
        for (let strideChunkStart = 0; strideChunkStart < resultBuf.length; strideChunkStart += strideChunkSize) {
            for (let strideOffset = 0; strideOffset < strideLength; strideOffset += 2) {
                if (!controls.allowsState((strideChunkStart | strideOffset) >> 1)) {
                    continue;
                }

                // Collect inputs into a small contiguous vector.
                let k = strideChunkStart + strideOffset;
                for (let i = 0; i < chunkBuf.length; i += 2) {
                    chunkBuf[i] = stateVector._buffer[k];
                    chunkBuf[i+1] = stateVector._buffer[k+1];
                    k += strideLength;
                }

                let transformedChunk = this.times(new Matrix(1, chunkBuf.length >> 1, chunkBuf));

                // Scatter outputs.
                k = strideChunkStart + strideOffset;
                for (let i = 0; i < chunkBuf.length; i += 2) {
                    resultBuf[k] = transformedChunk._buffer[i];
                    resultBuf[k+1] = transformedChunk._buffer[i+1];
                    k += strideLength;
                }
            }
        }
        return new Matrix(1, stateVector.height(), resultBuf);
    }

    /**
     * Returns the receiving matrix's squared euclidean length.
     * @returns {!number}
     */
    norm2() {
        let t = 0;
        for (let e of this._buffer) {
            t += e*e;
        }
        return t;
    }

    /**
     * Returns the tensor product of the receiving matrix and the given matrix.
     * @param {!Matrix} other
     * @returns {!Matrix}
     */
    tensorProduct(other) {
        let w1 = this._width;
        let h1 = this._height;
        let w2 = other._width;
        let h2 = other._height;
        let w = w1*w2;
        let h = h1*h2;
        let newBuffer = new Float64Array(w*h*2);
        for (let r1 = 0; r1 < h1; r1++) {
            for (let r2 = 0; r2 < h2; r2++) {
                for (let c1 = 0; c1 < w1; c1++) {
                    for (let c2 = 0; c2 < w2; c2++) {
                        let k1 = (r1*w1 + c1)*2;
                        let k2 = (r2*w2 + c2)*2;
                        let k3 = ((r1*h2 + r2)*w + (c1*w2 + c2))*2;
                        let cr1 = this._buffer[k1];
                        let ci1 = this._buffer[k1+1];
                        let cr2 = other._buffer[k2];
                        let ci2 = other._buffer[k2+1];
                        let cr3 = cr1*cr2 - ci1*ci2;
                        let ci3 = cr1*ci2 + ci1*cr2;
                        newBuffer[k3] = cr3;
                        newBuffer[k3+1] = ci3;
                    }
                }
            }
        }
        return new Matrix(w, h, newBuffer);
    }

    timesQubitOperation(operation2x2, qubitIndex, controlMask, desiredValueMask) {
        Util.need((controlMask & (1 << qubitIndex)) === 0, "Matrix.timesQubitOperation: self-controlled");
        Util.need(operation2x2._width === 2 && operation2x2._height === 2, "Matrix.timesQubitOperation: not 2x2");

        let {_width: w, _height: h, _buffer: old} = this;
        let [ar, ai, br, bi, cr, ci, dr, di] = operation2x2._buffer;

        Util.need(h >= (2 << qubitIndex), "Matrix.timesQubitOperation: qubit index out of range");

        let buf = new Float64Array(old);
        let i = 0;
        for (let r = 0; r < h; r++) {
            let isControlled = ((controlMask & r) ^ desiredValueMask) !== 0;
            let qubitVal = (r & (1 << qubitIndex)) !== 0;
            for (let c = 0; c < w; c++) {
                if (!isControlled && !qubitVal) {
                    let j = i + (1 << qubitIndex)*2*w;
                    let xr = buf[i];
                    let xi = buf[i+1];
                    let yr = buf[j];
                    let yi = buf[j+1];

                    buf[i] = xr*ar - xi*ai + yr*br - yi*bi;
                    buf[i+1] = xr*ai + xi*ar + yr*bi + yi*br;
                    buf[j] = xr*cr - xi*ci + yr*dr - yi*di;
                    buf[j+1] = xr*ci + xi*cr + yr*di + yi*dr;
                }
                i += 2;
            }
        }
        return new Matrix(w, h, buf);
    }

    /**
     * Returns the result of tensor-product-ing the receiving matrix with itself the given number of times.
     * @param {!int} exponent The number of times the matrix is tensor-product-ed with itself.
     * @returns {!Matrix}
     */
    tensorPower(exponent) {
        if (!Number.isInteger(exponent) || exponent < 0) {
            throw new DetailedError("Bad exponent", {exponent});
        }
        let t = Matrix.identity(1);
        let p = this;
        for (let m = 1; m <= exponent; m *= 2) {
            if ((m & exponent) !== 0) {
                t = t.tensorProduct(p);
            }
            p = p.tensorProduct(p);
        }
        return t;
    }

    /**
     * Returns a single-qubit quantum operation corresponding to the given 3-dimensional rotation in some useful way.
     *
     * The mapping is chosen so that rotating around each axis runs through the respective pauli matrix, and so that cutting
     * a rotation in half square roots the result, and a few other nice properties.
     *
     * The direction of the given x, y, z vector determines which axis to rotate around, and the length of the vector
     * determines what fraction of an entire turn to rotate. For example, if [x, y, z] is [1/√8), 0, 1/√8], then the
     * rotation is a half-turn around the X+Z axis and the resulting operation is the Hadamard operation
     * {{1, 1}, {1, -1}}/√2.
     *
     * @param {!number} x The x component of the rotation vector.
     * @param {!number} y The y component of the rotation vector.
     * @param {!number} z The z component of the rotation vector.
     *
     * @returns {!Matrix}
     */
    static fromPauliRotation(x, y, z) {
        let sinc = t => {
            if (Math.abs(t) < 0.0002) { return 1 - t*t / 6.0; }
            return Math.sin(t) / t;
        };

        x = -x * Math.PI * 2;
        y = -y * Math.PI * 2;
        z = -z * Math.PI * 2;

        let s = -11*x + -13*y + -17*z >= 0 ? 1 : -1;  // phase correction discontinuity on an awkward plane
        let theta = Math.sqrt(x*x + y*y + z*z);
        let sigma_v = Matrix.PAULI_X.times(x).plus(
                      Matrix.PAULI_Y.times(y)).plus(
                      Matrix.PAULI_Z.times(z));

        /** @type {!Complex} */
        let [cos, sin] = Util.snappedCosSin(s * theta);
        let ci = new Complex(1 + cos, sin).times(0.5);
        /** @type {!Complex} */
        let cv = new Complex(Math.sin(theta/2) * sinc(theta/2), -s * sinc(theta)).times(s * 0.5);

        //noinspection JSCheckFunctionSignatures
        let m = Matrix.identity(2).times(ci).minus(sigma_v.times(cv));
        let expectNiceValuesCorrection = v => Format.simplifyByRounding(v, 0.0000000000001);
        return m.transformRealAndImagComponentsWith(expectNiceValuesCorrection);
    }

    /**
     * @param {!function(!number) : !number} func
     * @returns {!Matrix}
     * @private
     */
    transformRealAndImagComponentsWith(func) {
        let buf = this._buffer.slice();
        for (let i = 0; i < buf.length; i++) {
            buf[i] = func(buf[i]);
        }
        return new Matrix(this._width, this._height, buf);
    }

    /**
     * Returns a matrix for an n-wire circuit that swaps wires i and j.
     * @param {!int} numWires
     * @param {!int} swapWire1
     * @param {!int} swapWire2
     */
    static fromWireSwap(numWires, swapWire1, swapWire2) {
        let bitSwap = n => {
            let m1 = 1 << swapWire1;
            let m2 = 1 << swapWire2;
            let s = n & ~(m1 | m2);
            if ((n & m1) !== 0) { s |= m2; }
            if ((n & m2) !== 0) { s |= m1; }
            return s;
        };
        return Matrix.generateTransition(1<<numWires, bitSwap);
    }

    /**
     * Returns the identity matrix, with 1s on the main diagonal and all other entries zero.
     * @param size The dimension of the returned identity matrix.
     * @returns {!Matrix}
     */
    static identity(size) {
        if (!Number.isInteger(size) || size <= 0) {
            throw new DetailedError("Bad size", {size});
        }
        let buf = new Float64Array(size*size*2);
        for (let k = 0; k < size; k++) {
            buf[k*(size + 1)*2] = 1;
        }
        return new Matrix(size, size, buf);
    }

    /**
     * Returns a rotation matrix that rotations by the given angle.
     * @param {!number} theta The angle the matrix should rotate by, in radians.
     * @returns {!Matrix} A real matrix.
     */
    static rotation(theta) {
        let c = Math.cos(theta);
        let s = Math.sin(theta);
        return Matrix.square(
            c, -s,
            s, c);
    }

    /**
     * Equivalent to applying a swap gate in a quantum circuit.
     * @param {!int} qubit1
     * @param {!int} qubit2
     * @returns {!Matrix}
     */
    afterQubitSwap(qubit1, qubit2) {
        if (qubit1 === qubit2) {
            throw new DetailedError('Self-swap', {qubit1, qubit2});
        }
        if ((1 << qubit1) > this.height() || (1 << qubit2) > this.height()) {
            throw new DetailedError('Out of range swap', {qubit1, qubit2, height: this.height()});
        }

        let result = this._clone();
        let n = this.height();
        for (let i = 0; i < n; i++) {
            let m1 = (i >> qubit1) & 1;
            let m2 = (i >> qubit2) & 1;
            if (m1 === 1 && m2 === 0) {
                result._inline_rowSwap(i, i - (1 << qubit1) + (1 << qubit2));
            }
        }
        return result;
    }

    /**
     * @param {!int} row
     * @param {!Complex} scale
     * @private
     */
    _inline_rowScale_preMultiply(row, scale) {
        for (let col = 0; col < this._width; col++) {
            let v1 = this.cell(col, row);
            let v2 = v1.times(scale);
            let k = (row*this._width + col)*2;
            this._buffer[k] = v2.real;
            this._buffer[k+1] = v2.imag;
        }
    }

    /**
     * @param {!int} col
     * @param {!Complex} scale
     * @private
     */
    _inline_colScale_postMultiply(col, scale) {
        for (let row = 0; row < this._height; row++) {
            let v1 = this.cell(col, row);
            let v2 = v1.times(scale);
            let k = (row*this._width + col)*2;
            this._buffer[k] = v2.real;
            this._buffer[k+1] = v2.imag;
        }
    }

    /**
     * @param {!int} row1
     * @param {!int} row2
     * @private
     */
    _inline_rowSwap(row1, row2) {
        for (let col = 0; col < this._width; col++) {
            let k1 = (row1*this._width + col)*2;
            let k2 = (row2*this._width + col)*2;
            let t1 = this._buffer[k1];
            let t2 = this._buffer[k1+1];
            this._buffer[k1] = this._buffer[k2];
            this._buffer[k1+1] = this._buffer[k2+1];
            this._buffer[k2] = t1;
            this._buffer[k2+1] = t2;
        }
    }

    /**
     * @param {!int} row1
     * @param {!int} row2
     * @param {!Matrix} op
     * @private
     */
    _inline_rowMix_preMultiply(row1, row2, op) {
        let [a, b, c, d] = op._2x2Breakdown();
        for (let col = 0; col < this._width; col++) {
            let x = this.cell(col, row1);
            let y = this.cell(col, row2);
            let v1 = x.times(a).plus(y.times(b));
            let v2 = x.times(c).plus(y.times(d));
            let k1 = (row1*this._width + col)*2;
            let k2 = (row2*this._width + col)*2;
            this._buffer[k1] = v1.real;
            this._buffer[k1+1] = v1.imag;
            this._buffer[k2] = v2.real;
            this._buffer[k2+1] = v2.imag;
        }
    }

    /**
     * @param {!int} col1
     * @param {!int} col2
     * @param {!Matrix} op
     * @private
     */
    _inline_colMix_postMultiply(col1, col2, op) {
        let [a, b, c, d] = op._2x2Breakdown();
        for (let row = 0; row < this._width; row++) {
            let x = this.cell(col1, row);
            let y = this.cell(col2, row);
            let v1 = x.times(a).plus(y.times(c));
            let v2 = x.times(b).plus(y.times(d));
            let k1 = (row*this._width + col1)*2;
            let k2 = (row*this._width + col2)*2;
            this._buffer[k1] = v1.real;
            this._buffer[k1+1] = v1.imag;
            this._buffer[k2] = v2.real;
            this._buffer[k2+1] = v2.imag;
        }
    }

    /**
     * @returns {!Matrix}
     * @private
     */
    _clone() {
        //noinspection JSCheckFunctionSignatures
        return new Matrix(this._width, this._height, this._buffer.slice());
    }

    /**
     * Factors the receiving square matrix into a unitary matrix Q times an upper diagonal matrix R.
     * @returns {!{Q: !Matrix, R: !Matrix}} where Q.times(R).isEqualTo(this) && Q.isUnitary() && R.isUpperTriangular()
     */
    qrDecomposition() {
        if (this._width !== this._height) {
            throw new DetailedError("Expected a square matrix.", this);
        }
        let Q = Matrix.identity(this._width);
        let R = this._clone();
        for (let row = 0; row < this._height; row++) {
            for (let col = 0; col < row && col < this._width; col++) {
                // We're going to cancel out the value below the diagonal with a Givens rotation.

                let belowDiag = R.cell(col, row); // Zero this.
                let onDiag = R.cell(col, col); // With this.

                // Determine how much to rotate.
                let mag1 = onDiag.abs();
                let mag2 = belowDiag.abs();
                if (mag2 === 0) {
                    continue; // Already zero'd.
                }
                let theta = -Math.atan2(mag2, mag1);
                let cos = Math.cos(theta);
                let sin = Math.sin(theta);

                // Need to cancel phases before rotating.
                let phase1 = onDiag.unit().conjugate();
                let phase2 = belowDiag.unit().conjugate();

                // Apply the rotation to R (and cancel it with Q).
                let op = Matrix.square(
                    phase1.times(cos), phase2.times(-sin),
                    phase1.times(sin), phase2.times(cos));
                R._inline_rowMix_preMultiply(col, row, op);
                Q._inline_colMix_postMultiply(col, row, op.adjoint());
            }

            // Cancel imaginary factors on diagonal.
            let u = R.cell(row, row).unit();
            R._inline_rowScale_preMultiply(row, u.conjugate());
            Q._inline_colScale_postMultiply(row, u);
        }
        return {Q, R};
    }

    /**
     * Factors the receiving square matrix into a lower diagonal matrix L times a unitary matrix Q.
     * @returns {!{L: !Matrix, Q: !Matrix}} where L.times(Q).isEqualTo(this) && Q.isUnitary() && R.isLowerTriangular()
     */
    lqDecomposition() {
        let {Q, R} = this.adjoint().qrDecomposition();
        return {L: R.adjoint(), Q: Q.adjoint()};
    }

    /**
     * Computes the magnitudes of the eigenvalues of the matrix, using the QR algorithm.
     * @param {!number} epsilon
     * @param {!number=} maxIterations
     * @returns {!Array.<!Complex>}
     */
    eigenvalueMagnitudes(epsilon, maxIterations = 1000) {
        if (this._width !== this._height) {
            throw new DetailedError("Expected a square matrix.", this);
        }
        let iteration = 0;
        let m = this;
        while (!m.isUpperTriangular(epsilon) && iteration < maxIterations) {
            let {Q, R} = m.qrDecomposition();
            if (R.isIdentity(epsilon)) {
                return Seq.repeat(1, this._width).toArray();
            }
            m = R.times(Q);
            iteration++;
        }
        return Seq.range(this._width).map(i => m.cell(i, i).abs()).sortedBy(e => -e).toArray();
    }

    /**
     * Computes the eigenvalues and eigenvectors of a 2x2 matrix.
     * @returns {!Array.<!{val: !Complex, vec: !Matrix}>}
     */
    eigenDecomposition() {
        if (this.width() !== 2 || this.height() !== 2) {
            throw new Error("Not implemented: non-2x2 eigen decomposition");
        }
        let [a, b, c, d] = this._2x2Breakdown();
        let vals = Complex.rootsOfQuadratic(
            Complex.ONE,
            a.plus(d).times(-1),
            a.times(d).minus(b.times(c)));
        if (vals.length === 0) {
            throw new Error("Degenerate")
        }
        if (vals.length === 1) {
            return [
                {val: vals[0], vec: Matrix.col(1, 0)},
                {val: vals[0], vec: Matrix.col(0, 1)}
            ];
        }
        return vals.map(v => {
            // x*(a-L) + y*b = 0
            let [x, y] = [b.times(-1), a.minus(v)];
            if (x.isEqualTo(0) && y.isEqualTo(0)) {
                [x, y] = [v.minus(d), c];
            }
            if (!x.isEqualTo(0)) {
                y = y.dividedBy(x);
                x = Complex.ONE;
            }
            let m = Math.sqrt(x.norm2() + y.norm2());
            if (m === 0) {
                throw new Error("Unexpected degenerate");
            }
            return {val: v, vec: Matrix.col(x, y).times(1/m)};
        });
    }

    /**
     * Lifts a numeric function so that it applies to matrices by using the eigendecomposition and applying the function
     * to the eigenvalue coefficients.
     * @param {!function(!Complex) : !Complex} complexFunction
     * @returns {!Matrix}
     */
    liftApply(complexFunction) {
        let t = this.times(0);
        for (let {val, vec} of this.eigenDecomposition()) {
            //noinspection JSUnusedAssignment
            let fVal = complexFunction(val);
            //noinspection JSUnusedAssignment
            let part = vec.times(vec.adjoint());
            t = t.plus(part.times(fVal));
        }
        return t;
    }

    /**
     * Returns the bloch sphere vector (as an x,y,z array) corresponding to this density matrix.
     * @returns {!Array.<!number>}
     */
    qubitDensityMatrixToBlochVector() {
        if (this._width !== 2 || this._height !== 2) {
            throw new DetailedError("Need a 2x2 density matrix.", this);
        }
        if (!this.isApproximatelyHermitian(0.01)) {
            throw new DetailedError("Density matrix should be Hermitian.", this);
        }
        if (!this.trace().isApproximatelyEqualTo(1, 0.01)) {
            throw new DetailedError("Density matrix should have unit trace.", this);
        }

        // Density matrix from bloch vector equation: M = 1/2 (I + vσ)
        //noinspection JSUnusedLocalSymbols
        let [ar, ai, br, bi, cr, ci, dr, di] = this._buffer;
        let x = -cr - br;
        let y = bi - ci;
        let z = dr - ar;
        return [x, y, z];
    }

    /**
     * Returns the square matrix' determinant (i.e. the product of its eigenvalues).
     * @returns {!Complex}
     */
    determinant() {
        Util.need(this.width() === this.height(), "Must be square");
        let n = this.width();
        if (n === 1) {
            return this.cell(0, 0);
        }
        return Seq.range(n).
            map(k => {
                let cutColMatrix = Matrix.generate(n - 1, n - 1, (r, c) => this.cell(
                    c + (c < k ? 0 : 1),
                    r + 1));
                return cutColMatrix.determinant().times(this.cell(k, 0)).times(Math.pow(-1, k));
            }).
            aggregate(Complex.ZERO, (a, e) => a.plus(e));
    }

    /**
     * @returns {!Array.<!Complex>}
     * @private
     */
    _2x2Breakdown() {
        return [new Complex(this._buffer[0], this._buffer[1]),
                new Complex(this._buffer[2], this._buffer[3]),
                new Complex(this._buffer[4], this._buffer[5]),
                new Complex(this._buffer[6], this._buffer[7])];
    }

    /**
     * Given a single-qubit operation matrix U, finds φ, θ, and v=[x,y,z] that satisfy
     * U = exp(i φ) (I cos(θ/2) - v σ i sin(θ/2))
     *
     * @returns {!{axis: !Array.<!number>, angle: !number, phase: !number}}
     */
    qubitOperationToAngleAxisRotation() {
        Util.need(this.width() === 2 && this.height() === 2, "Need a 2x2 matrix.");
        Util.need(this.isUnitary(0.01), "Need a unitary matrix.");

        // Extract orthogonal components, adjusting for factors of i.
        let [a, b, c, d] = this._2x2Breakdown();
        let wp = a.plus(d);
        let xp = b.plus(c).dividedBy(Complex.I);
        let yp = b.minus(c);
        let zp = a.minus(d).dividedBy(Complex.I);

        // Cancel global phase factor, pushing all values onto the real line.
        let p = seq([wp, xp, yp, zp]).maxBy(e => e.abs()).unit().times(2);
        let w = Math.min(1, Math.max(-1, wp.dividedBy(p).real));
        let x = xp.dividedBy(p).real;
        let y = yp.dividedBy(p).real;
        let z = zp.dividedBy(p).real;
        let t = -2*Math.acos(w);

        // Normalize axis.
        let n = Math.sqrt(x*x + y*y + z*z);
        if (n < 0.0000001) {
            // There's an axis singularity near θ=0. Just default to no rotation around the X axis.
            return {axis: [1, 0, 0], angle: 0, phase: p.phase()};
        }
        x /= n;
        y /= n;
        z /= n;

        // Prefer θ in [-π, π].
        if (t <= -Math.PI) {
            t += 2*Math.PI;
            p = p.times(-1);
        }

        // Prefer axes that point positive-ward.
        if (x + y + z < 0) {
            x = -x;
            y = -y;
            z = -z;
            t = -t;
        }

        return {axis: [x, y, z], angle: t, phase: p.phase()};
    }

    /**
     * Returns the matrix U = exp(i φ) (I cos(θ/2) - v σ i sin(θ/2)).
     * @param {!number} angle
     * @param {!Array.<!number>} axis
     * @param {!number} phase
     * @returns {!Matrix}
     */
    static fromAngleAxisPhaseRotation(angle, axis, phase) {
        let [x, y, z] = axis;
        Util.need(Math.abs(x*x+y*y+z*z - 1) < 0.000001, "Not a unit axis.");

        let vσ = Matrix.PAULI_X.times(x).
            plus(Matrix.PAULI_Y.times(y)).
            plus(Matrix.PAULI_Z.times(z));
        let [cos, sin] = Util.snappedCosSin(-angle/2);
        return Matrix.identity(2).times(cos).
            plus(vσ.times(new Complex(0, sin))).
            times(Complex.polar(1, phase));
    }

    /**
     * Computes the cross product of two 3d column vectors.
     * @param {!Matrix} other
     * @returns {!Matrix}
     */
    cross3(other) {
        Util.need(this.width() === 1 && this.height() === 3, "This isn't a 3d column vector.");
        Util.need(other.width() === 1 && other.height() === 3, "Other's not a 3d column vector.");
        return Matrix.generate(1, 3, r => {
            let [i, j] = [(r+1) % 3, (r+2) % 3];
            let a = this.cell(0, i).times(other.cell(0, j));
            let b = this.cell(0, j).times(other.cell(0, i));
            return a.minus(b);
        });
    }

    /**
     * @returns {!{U: !Matrix, S: !Matrix, V: !Matrix}}
     */
    _unordered_singularValueDecomposition_2x2() {
        // Initial dirty work of clearing a corner is handled by the LQ decomposition.
        let U = Matrix.identity(2);
        let {L: S, Q: V} = this.lqDecomposition();

        // Cancel phase factors, leaving S with only real entries.
        let au = S.cell(0, 0).unit();
        let cu = S.cell(0, 1).unit();
        U._inline_colScale_postMultiply(0, au);
        U._inline_colScale_postMultiply(1, cu);
        S._inline_rowScale_preMultiply(0, au.conjugate());
        S._inline_rowScale_preMultiply(1, cu.conjugate());
        let du = S.cell(1, 1).unit();
        S._inline_colScale_postMultiply(1, du.conjugate());
        V._inline_rowScale_preMultiply(1, du);

        // Decompose the 2x2 real matrix.
        let [a,, b,, c,, d] = S._buffer;
        let t = a + d;
        let x = b + c;
        let y = b - c;
        let z = a - d;
        let theta_0 = Math.atan2(x, t) / 2.0;
        let theta_d = Math.atan2(y, z) / 2.0;
        let s_0 = Math.sqrt(t * t + x * x) / 2.0;
        let s_d = Math.sqrt(z * z + y * y) / 2.0;
        U._inline_colMix_postMultiply(0, 1, Matrix.rotation(theta_0 - theta_d));
        V._inline_rowMix_preMultiply(0, 1, Matrix.rotation(theta_0 + theta_d));
        S = Matrix.square(s_0 + s_d, 0, 0, s_0 - s_d);

        return {U, S, V};
    }

    /**
     * @param {!number=} epsilon
     * @param {!int=} maxIterations
     * @returns {!{U: !Matrix, S: !Matrix, V: !Matrix}}
     */
    _unordered_singularValueDecomposition_iterative(epsilon=0, maxIterations=100) {
        let U = Matrix.identity(this._width);
        let S = this._clone();
        let V = Matrix.identity(this._width);
        let iter = 0;
        while (!S.isDiagonal(epsilon) && iter++ < maxIterations) {
            let {Q: Ql, R: Sl} = S.qrDecomposition();
            let {L: Sr, Q: Qr} = Sl.lqDecomposition();
            U = U.times(Ql);
            S = Sr;
            V = Qr.times(V);
        }

        return {U, S, V};
    }

    /**
     * Factors the matrix int u*s*v parts, where u and v are unitary matrices and s is a real diagonal matrix.
     * @param {!number=} epsilon
     * @param {!int=} maxIterations
     * @returns {!{U: !Matrix, S: !Matrix, V: !Matrix}}
     */
    singularValueDecomposition(epsilon=0, maxIterations=100) {
        if (this._width !== this._height) {
            throw new DetailedError("Expected a square matrix.", this);
        }

        let {U, S, V} = this._width === 2 ?
            this._unordered_singularValueDecomposition_2x2() :
            this._unordered_singularValueDecomposition_iterative(epsilon, maxIterations);

        // Fix ordering, so that the singular values are ascending.
        let permutation = Seq.range(this._width).sortedBy(i => -S.cell(i, i).norm2()).toArray();
        for (let i = 0; i < S._width; i++) {
            let j = permutation[i];
            if (i !== j) {
                U._inline_colMix_postMultiply(i, j, Matrix.PAULI_X);
                V._inline_rowMix_preMultiply(i, j, Matrix.PAULI_X);
                [S._buffer[i*2], S._buffer[j*2]] = [S._buffer[j*2], S._buffer[i*2]];
                [S._buffer[i*2+1], S._buffer[j*2+1]] = [S._buffer[j*2+1], S._buffer[i*2+1]];
                [permutation[j], permutation[i]] = [permutation[i], permutation[j]]
            }
        }

        // Fix phases.
        for (let i = 0; i < S._width; i++) {
            U._inline_colScale_postMultiply(i, S.cell(i, i).unit());
        }

        // Discard off-diagonal elements.
        S = Matrix.generateDiagonal(S._width, k => S.cell(k, k).abs());

        return {U, S, V};
    }

    /**
     * @param {!int} colIndex
     * @returns {!Array.<!Complex>}
     */
    getColumn(colIndex) {
        Util.need(colIndex >= 0 && colIndex <= this.width(), "colIndex >= 0 && colIndex <= this.width()");
        let col = [];
        for (let r = 0; r < this._height; r++) {
            col.push(this.cell(colIndex, r));
        }
        return col;
    }

    /**
     * @param {!int} rowIndex
     * @returns {!Array.<!Complex>}
     */
    getRow(rowIndex) {
        Util.need(rowIndex >= 0 && rowIndex <= this.height(), "rowIndex >= 0 && rowIndex <= this.height()");
        let row = [];
        for (let c = 0; c < this._width; c++) {
            row.push(this.cell(c, rowIndex));
        }
        return row;
    }

    /**
     * Returns the unitary matrix closest to the receiving matrix, "repairing" it into a unitary form.
     * @returns {!Matrix}
     */
    closestUnitary(epsilon=0, maxIterations=100) {
        let svd = this.singularValueDecomposition(epsilon, maxIterations);
        return svd.U.times(svd.V);
    }
}

/**
 * The 2x2 Pauli X matrix.
 * @type {!Matrix}
 */
Matrix.PAULI_X = Matrix.square(0, 1, 1, 0);

/**
 * The 2x2 Pauli Y matrix.
 * @type {!Matrix}
 */
Matrix.PAULI_Y = Matrix.square(0, new Complex(0, -1), Complex.I, 0);

/**
 * The 2x2 Pauli Z matrix.
 * @type {!Matrix}
 */
Matrix.PAULI_Z = Matrix.square(1, 0, 0, -1);

/**
 * The 2x2 Hadamard matrix.
 * @type {!Matrix}
 */
Matrix.HADAMARD = Matrix.square(1, 1, 1, -1).times(Math.sqrt(0.5));

_gen_package_export("src/base/Matrix.js", {Matrix});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Obs.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * An observable sequence of events.
 *
 * WARNING: this class is not written to be re-entrant safe! If an observable ends up triggering itself, there may be
 * unexpected bugs.
 */
class Observable {
    /**
     * @param {!function(!function(T):void): (!function():void)} subscribe
     * @template T
     */
    constructor(subscribe) {
        /**
         * @type {!(function(!(function(T): void)): !(function(): void))}
         * @template T
         * @private
         */
        this._subscribe = subscribe;
    }

    /**
     * @param {!function(T):void} observer
     * @returns {!function():void} unsubscriber
     * @template T
     */
    subscribe(observer) {
        return this._subscribe(observer);
    }

    /**
     * @param {T} items
     * @returns {!Observable.<T>} An observable that immediately forwards all the given items to any new subscriber.
     * @template T
     */
    static of(...items) {
        return new Observable(observer => {
            for (let item of items) {
                observer(item);
            }
            return () => {};
        });
    }

    /**
     * Subscribes to the receiving observable for a moment and returns any collected items.
     * @returns {!Array.<T>}
     * @template T
     */
    snapshot() {
        let result = [];
        let unsub = this.subscribe(e => result.push(e));
        unsub();
        return result;
    }

    /**
     * @param {!function(TIn) : TOut} transformFunc
     * @returns {!Observable.<TOut>} An observable with the same items, but transformed by the given function.
     * @template TIn, TOut
     */
    map(transformFunc) {
        return new Observable(observer => this.subscribe(item => observer(transformFunc(item))));
    }

    /**
     * @param {!function(T) : !boolean} predicate
     * @returns {!Observable.<T>} An observable with the same items, but skipping items that don't match the predicate.
     * @template T
     */
    filter(predicate) {
        return new Observable(observer => this.subscribe(item => { if (predicate(item)) { observer(item); }}));
    }

    /**
     * @param {!Observable.<T2>} other
     * @param {!function(T1, T2): TOut} mergeFunc
     * @returns {!Observable.<TOut>}
     * @template T1, T2, TOut
     */
    zipLatest(other, mergeFunc) {
        return new Observable(observer => {
            let has1 = false;
            let has2 = false;
            let last1;
            let last2;
            let unreg1 = this.subscribe(e1 => {
                last1 = e1;
                has1 = true;
                if (has2) {
                    observer(mergeFunc(last1, last2));
                }
            });
            let unreg2 = other.subscribe(e2 => {
                last2 = e2;
                has2 = true;
                if (has1) {
                    observer(mergeFunc(last1, last2));
                }
            });
            return () => { unreg1(); unreg2(); };
        });
    }

    /**
     * Returns an observable that keeps requesting animations frame callbacks and calling observers when they arrive.
     * @returns {!Observable.<undefined>}
     */
    static requestAnimationTicker() {
        return new Observable(observer => {
            let iter;
            let isDone = false;
            iter = () => {
                if (!isDone) {
                    observer(undefined);
                    window.requestAnimationFrame(iter);
                }
            };
            iter();
            return () => { isDone = true; };
        });
    }

    /**
     * @returns {!Observable.<T>} An observable that subscribes to each sub-observables arriving on this observable
     * in turns, only forwarding items from the latest sub-observable.
     * @template T
     */
    flattenLatest() {
        return new Observable(observer => {
            let unregLatest = () => {};
            let isDone = false;
            let unregAll = this.subscribe(subObservable => {
                if (isDone) {
                    return;
                }
                let prevUnreg = unregLatest;
                unregLatest = subObservable.subscribe(observer);
                prevUnreg();
            });
            return () => {
                isDone = true;
                unregLatest();
                unregAll();
            }
        });
    }

    /**
     * @param {!function(T):void} action
     * @returns {!Observable.<T>}
     * @template T
     */
    peek(action) {
        return this.map(e => { action(e); return e; });
    }

    /**
     * @returns {!Observable.<T>} An observable that forwards all the items from all the observables observed by the
     * receiving observable of observables.
     * @template T
     */
    flatten() {
        return new Observable(observer => {
            let unsubs = [];
            unsubs.push(this.subscribe(observable => unsubs.push(observable.subscribe(observer))));
            return () => {
                for (let unsub of unsubs) {
                    unsub()
                }
            }
        });
    }

    /**
     * @param {!HTMLElement|!HTMLDocument} element
     * @param {!string} eventKey
     * @returns {!Observable.<*>} An observable corresponding to an event fired from an element.
     */
    static elementEvent(element, eventKey) {
        return new Observable(observer => {
            element.addEventListener(eventKey, observer);
            return () => element.removeEventListener(eventKey, observer);
        });
    }

    /**
     *
     * @param {!int} count
     * @returns {!Observable.<T>}
     * @template T
     */
    skip(count) {
        return new Observable(observer => {
            let remaining = count;
            return this.subscribe(item => {
                if (remaining > 0) {
                    remaining -= 1;
                } else {
                    observer(item);
                }
            })
        })
    }

    /**
     * @returns {!Observable.<T>} An observable with the same events, but filtering out any event value that's the same
     * as the previous one.
     * @template T
     */
    whenDifferent(equater = undefined) {
        let eq = equater || ((e1, e2) => e1 === e2);
        return new Observable(observer => {
            let hasLast = false;
            let last = undefined;
            return this.subscribe(item => {
                if (!hasLast || !eq(last, item)) {
                    last = item;
                    hasLast = true;
                    observer(item);
                }
            });
        });
    }
}

class ObservableSource {
    constructor() {
        /**
         * @type {!Array.<!function(T):void>}
         * @private
         * @template T
         */
        this._observers = [];
        /**
         * @type {!Observable.<T>}
         * @private
         * @template T
         */
        this._observable = new Observable(observer => {
            this._observers.push(observer);
            let didRun = false;
            return () => {
                if (!didRun) {
                    didRun = true;
                    this._observers.splice(this._observers.indexOf(observer), 1);
                }
            };
        });
    }

    /**
     * @returns {!Observable.<T>}
     * @template T
     */
    observable() {
        return this._observable;
    }

    /**
     * @param {T} eventValue
     * @template T
     */
    send(eventValue) {
        for (let obs of this._observers) {
            obs(eventValue);
        }
    }
}

class ObservableValue {
    /**
     * @param {T=undefined} initialValue
     * @template T
     */
    constructor(initialValue=undefined) {
        this._value = initialValue;
        this._source = new ObservableSource();
        this._observable = new Observable(observer => {
            observer(this._value);
            return this._source.observable().subscribe(observer);
        });
    }

    /**
     * @returns {!Observable}
     */
    observable() {
        return this._observable;
    }

    /**
     * @param {T} newValue
     * @template T
     */
    set(newValue) {
        this._value = newValue;
        this._source.send(newValue);
    }

    /**
     * @returns {T} The current value.
     * @template T
     */
    get() {
        return this._value;
    }
}

_gen_package_export("src/base/Obs.js", {Observable, ObservableSource, ObservableValue});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Point.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * A two dimensional point with real coordinates.
 */
class Point {
    /**
     * @param {!number} x The new point's x coordinate.
     * @param {!number} y The new point's y coordinate.
     */
    constructor(x, y) {
        /**
         * The point's x coordinate.
         * @type {!number}
         */
        this.x = x;
        /**
         * The point's y coordinate.
         * @member Point#y
         * @type {!number}
         */
        this.y = y;
    }

    /**
     * Determines if the given value is a point with the same coordinates as the receiving point.
     * @param {!Point|*} obj The point, or other value, to compare against.
     * @returns {!boolean}
     */
    isEqualTo(obj) {
        if (!(obj instanceof Point)) {
            return false;
        }
        /** @type {!Point} */
        let other = obj;
        return other.x === this.x && other.y === this.y;
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `(x: ${this.x}, y: ${this.y})`;
    }

    /**
     * Returns the result of adding the receiving point's coordinates to the given offset values.
     * @param {!number} dx The x offset.
     * @param {!number} dy The y offset.
     * @returns {!Point}
     */
    offsetBy(dx, dy) {
        return new Point(this.x + dx, this.y + dy);
    }

    /**
     * Returns the result of pairing and adding the receiving point's, and the given point's, coordinates.
     * @param {!Point} p
     * @returns {!Point}
     */
    plus(p) {
        return new Point(this.x + p.x, this.y + p.y);
    }

    /**
     * Returns the result of subtracting the given point's coordinates from the receiving point.
     * @param {!Point} p
     * @returns {!Point}
     */
    minus(p) {
        return new Point(this.x - p.x, this.y - p.y);
    }

    /**
     * Returns the result of scaling the receiving point's coordinates by the given factor.
     * @param {!number} c The scaling factor.
     * @returns {!Point}
     */
    times(c) {
        return new Point(this.x * c, this.y * c);
    }

    /**
     * Returns the Euclidean distance between the receiving point and the given point.
     * @param {!Point} other
     * @returns {!number}
     */
    distanceTo(other) {
        let dx = this.x - other.x;
        let dy = this.y - other.y;
        return Math.sqrt(dx*dx + dy*dy);
    }
}

_gen_package_export("src/base/Point.js", {Point});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Rect.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {Point} = _gen_package_get("src/base/Point.js");

/**
 * A two dimensional axis-aligned rectangle with defined position and size.
 */
class Rect {
    /**
     * @param {!number} x
     * @param {!number} y
     * @param {!number} w
     * @param {!number} h
     */
    constructor(x, y, w, h) {
        /**
         * The x-coordinate of the left of the rectangle.
         * @type {!number}
         */
        this.x = x;
        /**
         * The y-coordinate of the top of the rectangle.
         * @type {!number}
         */
        this.y = y;
        /**
         * The width of the rectangle.
         * @type {!number}
         */
        this.w = w;
        /**
         * The height of the rectangle.
         * @type {!number}
         */
        this.h = h;
    }

    /**
     * @param {!Rect|*} obj
     * @returns {!boolean}
     */
    isEqualTo(obj) {
        if (!(obj instanceof Rect)) {
            return false;
        }
        /** @type {Rect!} */
        let other = obj;
        return other.x === this.x &&
            other.y === this.y &&
            other.w === this.w &&
            other.h === this.h;
    }

    /**
     * @param {!Rect|*} obj
     * @param {!number} epsilon
     * @returns {!boolean}
     */
    isApproximatelyEqualTo(obj, epsilon) {
        if (!(obj instanceof Rect)) {
            return false;
        }
        /** @type {Rect!} */
        let other = obj;
        return Math.abs(other.x - this.x) <= epsilon &&
            Math.abs(other.y - this.y) <= epsilon &&
            Math.abs(other.right() - this.right()) <= epsilon &&
            Math.abs(other.bottom() - this.bottom()) <= epsilon;
    }

    toString() {
        return `[${this.x}:${this.right()}]x[${this.y}:${this.bottom()}]`;
    }

    /**
     *
     * @param {!Point} center The x/y point at the center of the square.
     * @param {!number} radius Half of the diameter of the square.
     * @returns {!Rect}
     */
    static centeredSquareWithRadius(center, radius) {
        return new Rect(center.x - radius, center.y - radius, radius*2, radius*2);
    }

    /**
     * @returns {!Point}
     */
    center() {
        return new Point(this.x + this.w / 2, this.y + this.h / 2);
    }

    /**
     * @returns {!Point}
     */
    topLeft() {
        return new Point(this.x, this.y);
    }

    /**
     * @returns {!Point}
     */
    topRight() {
        return new Point(this.x + this.w, this.y);
    }

    /**
     * @returns {!Point}
     */
    bottomLeft() {
        return new Point(this.x, this.y + this.h);
    }

    /**
     * @returns {!Point}
     */
    bottomRight() {
        return new Point(this.x + this.w, this.y + this.h);
    }

    /**
     * @returns {!Point}
     */
    centerLeft() {
        return new Point(this.x, this.y + this.h/2);
    }

    /**
     * @returns {!Point}
     */
    centerRight() {
        return new Point(this.x + this.w, this.y + this.h/2);
    }

    /**
     * @returns {!Point}
     */
    topCenter() {
        return new Point(this.x + this.w/2, this.y);
    }

    /**
     * @returns {!Point}
     */
    bottomCenter() {
        return new Point(this.x + this.w/2, this.y + this.h);
    }

    /**
     * @returns !number
     */
    right() {
        return this.x + this.w;
    }

    /**
     * @returns !number
     */
    bottom() {
        return this.y + this.h;
    }

    /**
     * Returns the result of removing the given width from the left side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} lostWidth
     * @returns !Rect
     */
    skipLeft(lostWidth) {
        let d = Math.min(lostWidth, this.w);
        return new Rect(this.x + d, this.y, this.w - d, this.h);
    }

    /**
     * Returns the result of removing the given width from the right side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} lostWidth
     * @returns !Rect
     */
    skipRight(lostWidth) {
        let d = Math.min(lostWidth, this.w);
        return new Rect(this.x, this.y, this.w - d, this.h);
    }

    /**
     * Returns the result of removing the given height from the top side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} lostHeight
     * @returns !Rect
     */
    skipTop(lostHeight) {
        let d = Math.min(lostHeight, this.h);
        return new Rect(this.x, this.y + d, this.w, this.h - d);
    }

    /**
     * Returns the result of removing the given height from the bottom side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} lostHeight
     * @returns !Rect
     */
    skipBottom(lostHeight) {
        let d = Math.min(lostHeight, this.h);
        return new Rect(this.x, this.y, this.w, this.h - d);
    }

    /**
     * Returns the result of removing all but the given width from the left side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} keptWidth
     * @returns !Rect
     */
    takeLeft(keptWidth) {
        let d = Math.max(keptWidth, 0);
        return new Rect(this.x, this.y, d, this.h);
    }

    /**
     * Returns the result of removing all but the given width from the right side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} keptWidth
     * @returns !Rect
     */
    takeRight(keptWidth) {
        let d = Math.max(keptWidth, 0);
        return new Rect(this.x + this.w - d, this.y, d, this.h);
    }

    /**
     * Returns the result of removing all but the given height from the top side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} keptHeight
     * @returns !Rect
     */
    takeTop(keptHeight) {
        let d = Math.max(keptHeight, 0);
        return new Rect(this.x, this.y, this.w, d);
    }

    /**
     * Returns the result of removing all but the given height from the bottom side of the rectangle.
     * The cut is clamped so it doesn't go into negative heights.
     *
     * @param {!number} keptHeight
     * @returns !Rect
     */
    takeBottom(keptHeight) {
        let d = Math.max(keptHeight, 0);
        return new Rect(this.x, this.y + this.h - d, this.w, d);
    }

    /**
     * Returns the result of padding to each side of the rectangle by the given amount.
     *
     * @param {!number} p The margin from the receiving rect's outside to the returned rect's inside.
     * @returns !Rect
     */
    paddedBy(p) {
        return new Rect(this.x - p, this.y - p, this.w + p * 2, this.h + p * 2);
    }

    /**
     * Returns the result of scaling the rectangle w.r.t. its center by the given scaling factor.
     * @param {!number} factor
     * @returns {!Rect}
     */
    scaledOutwardBy(factor) {
        let c = this.center();
        let w2 = this.w * factor;
        let h2 = this.h * factor;
        return new Rect(c.x - w2/2, c.y - h2/2, w2, h2);
    }

    /**
     * Determines if the given point is in the receiving rect or not.
     *
     * Note that the top and left of the rectangle are inclusive, but the bottom and right are exclusive.
     *
     * @param {!Point} p The query point.
     * @returns {!boolean}
     */
    containsPoint(p) {
        return p.x >= this.x &&
            p.x < this.x + this.w &&
            p.y >= this.y &&
            p.y < this.y + this.h;
    }

    /**
     * @param {!number} proportion
     * @returns {!Rect}
     */
    takeLeftProportion(proportion) {
        return this.takeLeft(this.w * proportion);
    }

    /**
     * @param {!number} proportion
     * @returns {!Rect}
     */
    takeRightProportion(proportion) {
        return this.takeRight(this.w * proportion);
    }

    /**
     * @param {!number} proportion
     * @returns {!Rect}
     */
    takeTopProportion(proportion) {
        return this.takeTop(this.h * proportion);
    }

    /**
     * @param {!number} proportion
     * @returns {!Rect}
     */
    takeBottomProportion(proportion) {
        return this.takeBottom(this.h * proportion);
    }

    /**
     * @returns {!Rect}
     */
    leftHalf() {
        return this.skipRight(this.w / 2);
    }

    /**
     * @returns {!Rect}
     */
    rightHalf() {
        return this.skipLeft(this.w / 2);
    }

    /**
     * @returns {!Rect}
     */
    topHalf() {
        return this.skipBottom(this.h / 2);
    }

    /**
     * @returns {!Rect}
     */
    bottomHalf() {
        return this.skipTop(this.h / 2);
    }

    /**
     * @param {!number} dx The displacement to move the rect horizontally.
     * @param {!number} dy The displacement to move the rect vertically.
     * @returns {!Rect}
     */
    shiftedBy(dx, dy) {
        return new Rect(this.x + dx, this.y + dy, this.w, this.h);
    }


    /**
     * @param {!number} dx The proportional amount to move the rect horizontally.
     * @param {!number} dy The proportional amount to move the rect vertically.
     * @returns {!Rect}
     */
    proportionalShiftedBy(dx, dy) {
        return this.shiftedBy(dx * this.w, dy * this.h);
    }

    /**
     * @param {!number} newX
     * @returns {!Rect}
     */
    withX(newX) {
        return new Rect(newX, this.y, this.w, this.h);
    }

    /**
     * @param {!number} newY
     * @returns {!Rect}
     */
    withY(newY) {
        return new Rect(this.x, newY, this.w, this.h);
    }

    /**
     * @param {!number} newW
     * @returns {!Rect}
     */
    withW(newW) {
        return new Rect(this.x, this.y, newW, this.h);
    }

    /**
     * @param {!number} newH
     * @returns {!Rect}
     */
    withH(newH) {
        return new Rect(this.x, this.y, this.w, newH);
    }

    /**
     * Returns the result of repositioning the receiving rect so that it is inside the paintable area. Also shrinks the
     * receiving rect, if necessary.
     * @param {!Rect} boundingRect
     * @returns {!Rect}
     */
    snapInside(boundingRect) {
        let w = Math.min(boundingRect.w, this.w);
        let h = Math.min(boundingRect.h, this.h);
        let x = Math.max(Math.min(this.x, boundingRect.right() - w), boundingRect.x);
        let y = Math.max(Math.min(this.y, boundingRect.bottom() - h), boundingRect.y);
        return new Rect(x, y, w, h);
    }
}

_gen_package_export("src/base/Rect.js", {Rect});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Revision.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {describe} = _gen_package_get("src/base/Describe.js");
const {equate} = _gen_package_get("src/base/Equate.js");
const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {ObservableSource, ObservableValue} = _gen_package_get("src/base/Obs.js");

/**
 * A simple linear revision history tracker, for supporting undo and redo functionality.
 */
class Revision {
    /**
     * @param {!Array.<*>} history
     * @param {!int} index
     * @param {!boolean} isWorkingOnCommit
     */
    constructor(history, index, isWorkingOnCommit) {
        if (index < 0 || index >= history.length) {
            throw new DetailedError("Bad index", {history, index, isWorkingOnCommit});
        }
        if (!Array.isArray(history)) {
            throw new DetailedError("Bad history", {history, index, isWorkingOnCommit});
        }

        /** @type {!Array.<*>} */
        this.history = history;
        /** @type {!int} */
        this.index = index;
        /** @type {!boolean} */
        this.isWorkingOnCommit = isWorkingOnCommit;
        /** @type {!ObservableSource} */
        this._changes = new ObservableSource();
        /** @type {!ObservableSource} */
        this._latestActiveCommit = new ObservableValue(this.history[this.index]);
    }

    /**
     * @returns {!Observable.<*>}
     */
    changes() {
        return this._changes.observable();
    }

    /**
     * @returns {!Observable.<*>}
     */
    latestActiveCommit() {
        return this._latestActiveCommit.observable();
    }

    /**
     * Returns a snapshot of the current commit.
     * @returns {*}
     */
    peekActiveCommit() {
        return this._latestActiveCommit.get();
    }

    /**
     * Returns a cleared revision history, starting at the given state.
     * @param {*} state
     */
    static startingAt(state) {
        return new Revision([state], 0, false);
    }

    /**
     * @returns {!boolean}
     */
    isAtBeginningOfHistory() {
        return this.index === 0 && !this.isWorkingOnCommit;
    }

    /**
     * @returns {!boolean}
     */
    isAtEndOfHistory() {
        return this.index === this.history.length - 1;
    }

    /**
     * Throws away all revisions and resets the given state.
     * @param {*} state
     * @returns {void}
     */
    clear(state) {
        this.history = [state];
        this.index = 0;
        this.isWorkingOnCommit = false;
        this._changes.send(state);
        this._latestActiveCommit.set(state);
    }

    /**
     * Indicates that there are pending changes, so that a following 'undo' will return to the current state instead of
     * the previous state.
     * @returns {void}
     */
    startedWorkingOnCommit() {
        this.isWorkingOnCommit = true;
        this._changes.send(undefined);
    }

    /**
     * Indicates that pending changes were discarded, so that a following 'undo' should return to the previous state
     * instead of the current state.
     * @returns {*} The new current state.
     */
    cancelCommitBeingWorkedOn() {
        this.isWorkingOnCommit = false;
        let result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
    }

    /**
     * Throws away future states, appends the given state, and marks it as the current state
     * @param {*} newCheckpoint
     * @returns {void}
     */
    commit(newCheckpoint) {
        if (newCheckpoint === this.history[this.index]) {
            this.cancelCommitBeingWorkedOn();
            return;
        }
        if (newCheckpoint === this.history[this.index + 1]) {
            this.index += 1;
            this.cancelCommitBeingWorkedOn();
            return;
        }
        this.isWorkingOnCommit = false;
        this.index += 1;
        this.history.splice(this.index, this.history.length - this.index);
        this.history.push(newCheckpoint);
        this._changes.send(newCheckpoint);
        this._latestActiveCommit.set(newCheckpoint);
    }

    /**
     * Marks the previous state as the current state and returns it (or resets to the current state if
     * 'working on a commit' was indicated).
     * @returns {undefined|*} The new current state, or undefined if there's nothing to undo.
     */
    undo() {
        if (!this.isWorkingOnCommit) {
            if (this.index === 0) {
                return undefined;
            }
            this.index -= 1;
        }
        this.isWorkingOnCommit = false;
        let result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
    }

    /**
     * Marks the next state as the current state and returns it (or does nothing if there is no next state).
     * @returns {undefined|*} The new current state, or undefined if there's nothing to redo.
     */
    redo() {
        if (this.index + 1 === this.history.length) {
            return undefined;
        }
        this.index += 1;
        this.isWorkingOnCommit = false;
        let result = this.history[this.index];
        this._changes.send(result);
        this._latestActiveCommit.set(result);
        return result;
    }

    /**
     * @returns {!string} A description of the revision.
     */
    toString() {
        return 'Revision(' + describe({
                index: this.index,
                count: this.history.length,
                workingOnCommit: this.isWorkingOnCommit,
                head: this.history[this.index]
            }) + ')';
    }

    /**
     * Determines if two revisions currently have the same state.
     * @param {*|!Revision} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof Revision &&
            this.index === other.index &&
            this.isWorkingOnCommit === other.isWorkingOnCommit &&
            equate(this.history, other.history);
    }
}

_gen_package_export("src/base/Revision.js", {Revision});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Seq.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {GeneralSet} = _gen_package_get("src/base/GeneralSet.js");

const THROW_IF_EMPTY = { if_same_instance_as_this_then_throw: true };

/**
 * A private sygil/sentinel value that shouldn't ever be present in a sequence, and so can be used as a placeholder for
 * "not set yet" (unlike undefined or null, which are allowed to appear in sequences).
 */
const EMPTY_SYGIL = { not_a_normal_value: true };

const GENERIC_ARRAY_TYPES = [
    Float32Array,
    Float64Array,
    Int8Array,
    Int16Array,
    Int32Array,
    Uint8Array,
    Uint16Array,
    Uint32Array,
    Uint8ClampedArray
];

const isIterable = obj => typeof Object(obj)[Symbol.iterator] === 'function';

const emptyFallback = (result, alternative, errorMessage) => {
    if (result !== EMPTY_SYGIL) {
        return result;
    }
    if (alternative === THROW_IF_EMPTY) {
        throw new Error(errorMessage);
    }
    return alternative;
};


/**
 * A fluent wrapper for iterable sequences of values, exposing useful methods and properties.
 */
class Seq {
    /**
     * Wraps the given array, collection, or other iterable.
     * Use fromGenerator for wrapping generator functions.
     *
     * @param {!(T[])|!Seq.<T>|!Iterable.<T>|*} obj
     * @param {!boolean=} isIteratorFunction
     * @template T
     */
    constructor(obj, isIteratorFunction=false) {
        let iterable;
        let iterator;
        if (obj instanceof Seq) {
            // Avoid double-wrapping.
            iterable = obj._iterable;
            iterator = obj[Symbol.iterator];
        } else if (isIteratorFunction) {
            iterable = {[Symbol.iterator]: obj};
            iterator = obj;
        } else {
            if (!isIterable(obj)) {
                throw new Error(`Not iterable: ${obj}`);
            }
            iterable = obj;
            iterator = obj[Symbol.iterator].bind(obj);
        }

        /**
         * The generator, array, or other iterable object wrapped by this Seq instance.
         * @type {!(T[])|!Iterable.<T>|*}
         * @template T
         */
        this._iterable = iterable;

        /**
         * Iterates over the sequence's items.
         * @returns {!Iterator.<T>}
         * @template T
         */
        this[Symbol.iterator] = iterator;
    }

    /**
     * Creates a re-usable iterable from a generator function like <code>function*() { yield 1; }</code>.
     *
     * Note that the obvious alternative, <code>new Seq(function*(){yield 1;}()}</code>, stops working after the
     * iterable has been iterated once.
     *
     * @param {!function() : Iterator.<T>} generatorFunction
     * @returns {!Seq.<T>}
     * @template T
     */
    static fromGenerator(generatorFunction) {
        return new Seq(generatorFunction, true);
    }

    /**
    * Determines if the given iterable contains the same items as this sequence.
    * @param {*|!(T[])|!Seq.<T>|!Iterable.<T>} other
    * @param {!function(T, T|*) : !boolean} comparator
     * @template T
    */
    isEqualTo(other, comparator = (e1, e2) => e1 === e2) {
        if (!isIterable(other)) {
            return false;
        }
        if (other === this) {
            return true;
        }
        let iter2 = other[Symbol.iterator]();
        for (let e1 of this._iterable) {
            let e2 = iter2.next();
            if (e2.done || !comparator(e1, e2.value)) {
                return false;
            }
        }
        return iter2.next().done;
    }

    /**
     * Returns an array containing the items of this sequence.
     * @returns {!(T[])}
     * @template T
     */
    toArray() {
        return Array.from(this._iterable);
    }

    /**
     * Returns a Float32Array containing the items of this sequence.
     * @returns {!Float32Array}
     */
    toFloat32Array() {
        let n = this.tryPeekCount();
        if (n === undefined) {
            return new Float32Array(this.toArray());
        }

        let buf = new Float32Array(n);
        let i = 0;
        for (let item of this._iterable) {
            buf[i++] = item;
        }
        return buf;
    }

    /**
     * Returns a set containing the distinct items of this sequence.
     * @returns {!Set.<T>}
     * @template T
     */
    toSet() {
        return new Set(this._iterable);
    }

    /**
     * Returns a string representation of the receiving sequence's items, separated by the given joiner.
     * @param {!string} joiner
     * @returns {!string}
     */
    join(joiner) {
        return this.toArray().join(joiner);
    }


    /**
     * Returns a string representation of the receiving sequence.
     * @returns {!string}
     */
    toString() {
        return `Seq[${this.join(", ")}]`;
    }

    /**
     * Returns a sequence of natural numbers, starting at 0 and incrementing until just before the given count.
     * @param {!int} count
     * @returns {!Seq.<!int>}
     */
    static range(count) {
        if (!Number.isInteger(count) || count < 0) {
            throw new DetailedError("bad count", {count});
        }

        return Seq.fromGenerator(function*() {
            for (let i = 0; i < count; i++) {
                yield i;
            }
        });
    }

    /**
     * Returns the sequence of natural numbers, starting at 0 and incrementing without bound.
     * @returns {!Seq.<!int>}
     */
    static naturals() {
        return Seq.fromGenerator(function*() {
            let i = 0;
            //noinspection InfiniteLoopJS
            while (true) { //eslint-disable-line no-constant-condition
                yield i;
                i++;
            }
        })
    }

    /**
     * Returns a sequence of the same item repeated the given number of times.
     * @param {T} item
     * @param {!int} repeatCount
     * @returns {!Seq.<T>}
     * @template T
     */
    static repeat(item, repeatCount) {
        if (repeatCount < 0) {
            throw new Error("needed repeatCount >= 0");
        }

        return Seq.fromGenerator(function*() {
            for (let i = 0; i < repeatCount; i++) {
                yield item;
            }
        })
    }

    /**
     * Returns a sequence with the same items, but precomputed and stored. If the sequence is already solid, e.g. it is
     * backed by an array, then it is returned directly (and unchanged).
     * @returns {!Seq.<T>}
     * @template T
     */
    solidify() {
        let knownSolidTypes = [
            Float32Array,
            Float64Array,
            Int8Array,
            Int16Array,
            Int32Array,
            Uint8Array,
            Uint16Array,
            Uint32Array
        ];

        if (Array.isArray(this._iterable)) {
            return this;
        }
        for (let t of knownSolidTypes) {
            if (this._iterable instanceof t) {
                return this;
            }
        }
        return new Seq(this.toArray());
    }

    /**
     * Returns a sequence iterating the results of applying a transformation to the items of the receiving sequence.
     * @param {!function(T): R} projection
     * @returns {!Seq.<T>}
     * @template T, R
     */
    map(projection) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            for (let e of seq) {
                yield projection(e);
            }
        });
    }

    /**
     * Returns a sequence iterating the results of applying a transformation to the indexed items of the receiving
     * sequence.
     * @param {!function(T, int): R} projection
     * @returns {!Seq.<T>}
     * @template T, R
     */
    mapWithIndex(projection) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let i = 0;
            for (let e of seq) {
                yield projection(e, i);
                i += 1;
            }
        });
    }

    /**
     * Returns a sequence iterating the concatenated results of applying an iterable-returning transformation to the
     * items of the receiving sequence.
     * @param {!function(T): !Iterable<R>} sequenceProjection
     * @returns {!Seq.<T>}
     * @template T, R
     */
    flatMap(sequenceProjection) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            for (let e of seq) {
                yield* sequenceProjection(e);
            }
        });
    }

    /**
     * Returns a sequence iterating the items of the receiving sequence that match a predicate. Items that don't match
     * the predicate, by causing it to return a falsy value, are skipped.
     * @param {!function(T) : !boolean} predicate
     * @returns {!Seq.<T>}
     * @template T
     */
    filter(predicate) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            for (let e of seq) {
                if (predicate(e)) {
                    yield e;
                }
            }
        });
    }

    /**
     * Returns a sequence iterating the items of the receiving sequence that match a predicate over the item and the
     * item's index. Items that don't match the predicate are skipped.
     * @param {!function(T, int) : !boolean} predicate
     * @returns {!Seq.<T>}
     * @template T
     */
    filterWithIndex(predicate) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let i = 0;
            for (let e of seq) {
                if (predicate(e, i)) {
                    yield e;
                }
                i++;
            }
        });
    }

    /**
     * Combines the items of a sequence into a single result by iteratively applying a combining function. If the
     * sequence is empty, then either an error is thrown or the given alternative value is returned.
     * @param {!function(T, T) : T} combiner
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @returns {T|A}
     * @template T, A
     */
    fold(combiner, emptyErrorAlternative = THROW_IF_EMPTY) {
        let accumulator = EMPTY_SYGIL;
        for (let e of this._iterable) {
            accumulator = accumulator === EMPTY_SYGIL ? e : combiner(accumulator, e);
        }
        return emptyFallback(
            accumulator,
            emptyErrorAlternative,
            "Folded empty sequence without providing an alternative result.");
    }

    /**
     * Combines the items of a sequence into a single result by starting with a seed accumulator and iteratively
     * applying an aggregation function to the accumulator and next item to get the next accumulator.
     * @param {!function(A, T) : A} aggregator Computes the next accumulator value.
     * @param {A} seed The initial accumulator value.
     * @returns {A}
     * @template T, A
     */
    aggregate(seed, aggregator) {
        let accumulator = seed;
        for (let e of this._iterable) {
            accumulator = aggregator(accumulator, e);
        }
        return accumulator;
    }

    /**
     * Combines this sequence with another by passing items with the same index through a combining function.
     * If one sequence is longer than the other, the lonely tail is discarded.
     *
     * @param {!(T2[])|!Seq.<T2>|!Iterable.<T2>} other
     * @param {!function(T, T2) : R} combiner
     *
     * @returns {!Seq.<R>}
     *
     * @template T, T2, R
     */
    zip(other, combiner) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let iter2 = other[Symbol.iterator]();
            for (let item1 of seq) {
                let item2 = iter2.next();
                if (item2.done) {
                    break;
                }
                yield combiner(item1, item2.value);
            }
        });
    }

    /**
     * Returns the largest value in the sequence, as determined by the `<` operator. If the sequence  is empty, then
     * either an error is thrown or the given alternative value is returned.
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @returns {T|A}
     * @template T, A
     */
    max(emptyErrorAlternative = THROW_IF_EMPTY) {
        return this.fold((e1, e2) => e1 < e2 ? e2 : e1, emptyErrorAlternative);
    }

    /**
     * Returns the smallest value in the sequence, as determined by the `<` operator. If the sequence  is empty, then
     * either an error is thrown or the given alternative value is returned.
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @returns {T|A}
     * @template T, A
     */
    min(emptyErrorAlternative = THROW_IF_EMPTY) {
        return this.fold((e1, e2) => e1 < e2 ? e1 : e2, emptyErrorAlternative);
    }

    /**
     * Returns the highest-scoring item in the sequence, as determined by a scoring function.
     *
     * @param {!function(T) : !number} projection Determines the score of an item.
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @param {(function(A, A): !boolean)=} isALessThanBComparator The operation used to compare scores.
     * @returns {T|A}
     * @template T, A
     */
    maxBy(projection, emptyErrorAlternative = THROW_IF_EMPTY, isALessThanBComparator = (e1, e2) => e1 < e2) {
        let curMaxItem = EMPTY_SYGIL;
        let curMaxScore = EMPTY_SYGIL;
        for (let item of this._iterable) {
            // Delay computing the score for the first item, so that singleton lists never touch the score function.
            if (curMaxItem === EMPTY_SYGIL) {
                curMaxItem = item;
                continue;
            }
            if (curMaxScore === EMPTY_SYGIL) {
                curMaxScore = projection(curMaxItem);
            }

            let score = projection(item);
            if (isALessThanBComparator(curMaxScore, score)) {
                curMaxItem = item;
                curMaxScore = score;
            }
        }

        return emptyFallback(curMaxItem, emptyErrorAlternative, "Can't maxBy an empty sequence.");
    }

    /**
     * Returns the lowest-scoring item in the sequence, as determined by a scoring function.
     *
     * @param {!function(T) : !number} projection Determines the score of an item.
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @param {(function(A, A): !boolean)=} isALessThanBComparator The operation used to compare scores.
     * @returns {T|A}
     * @template T, A
     */
    minBy(projection, emptyErrorAlternative = THROW_IF_EMPTY, isALessThanBComparator = (e1, e2) => e1 < e2) {
        return this.maxBy(projection, emptyErrorAlternative, (e1, e2) => isALessThanBComparator(e2, e1));
    }

    /**
     * Determines if any of the items in the sequence matches the given predicate.
     * @param {!function(T) : !boolean} predicate
     * @returns {!boolean}
     * @template T
     */
    any(predicate) {
        for (let e of this._iterable) {
            if (predicate(e)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Determines if every item in the sequence matches the given predicate.
     * @param {!function(T) : !boolean} predicate
     * @returns {!boolean}
     * @template T
     */
    every(predicate) {
        return !this.any(e => !predicate(e));
    }

    /**
     * Determines if the sequence contains a given value or not, as determined by the <code>===</code> operator.
     * @param {T|*} value
     * @returns {!boolean}
     * @template T
     */
    contains(value) {
        return this.any(e => e === value);
    }

    /**
     * Adds up the numbers in the sequence, using the `+` operator, and returns the total.
     * The empty sum is defined to be 0, to satisfy the invariant that X.concat([s]).sum() === X.sum() + s.
     * @returns {T|!number|*}
     * @template T
     */
    sum() {
        let total = 0;
        let first = true;
        for (let e of this._iterable) {
            total = first ? e : total + e;
            first = false;
        }
        return total;
    }

    /**
     * Multiplies up the numbers in the sequence, using the `*` operator, and returns the total.
     * The empty product is defined to be 1, to satisfy the invariant that X.concat([s]).product() === X.product() * s.
     * @returns {T|!number|*}
     * @template T
     */
    product() {
        return this.fold((a, e) => a * e, 1);
    }

    /**
     * Accumulates the items of a sequence into a seed, while yielding the results. For example,
     * <code>[1, 2, 3].scan((a, e) => a + e, "a")</code> yields <code>["a", "a1", "a12", "a123"]</code> and
     * <code>[1, 2, 3].scan((e1, e2) => e1 + e2, 0)</code> yields <code>[0, 1, 3, 6]</code<.
     *
     * @param {A} seed
     * @param {!function(A, T) : A} aggregator
     * @returns {!Seq.<A>}
     * @template T, A
     */
    scan(seed, aggregator) {
        let seq = this._iterable;

        return Seq.fromGenerator(function*() {
            let accumulator = seed;
            yield accumulator;
            for (let e of seq) {
                accumulator = aggregator(accumulator, e);
                yield accumulator;
            }
        });
    }

    /**
     * Returns a sequence containing the same items, but in the opposite order.
     * @returns {!Seq.<T>}
     * @template T
     */
    reverse() {
        return new Seq(this.toArray().reverse());
    }

    /**
     * Flattens this sequence of iterables into a concatenated sequence.
     * @returns {!Seq.<C>}
     * @template C
     */
    flatten() {
        let seqSeq = this._iterable;
        return Seq.fromGenerator(function*() {
            for (let seq of seqSeq) {
                yield* seq;
            }
        });
    }

    /**
     * Returns a sequence that iterates the receiving sequence's items and then the given iterable's items.
     * @param {*|!(A[])|!Seq.<A>} other
     * @returns {!Seq.<T|A>}
     * @template T, A
     */
    concat(other) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            yield* seq;
            yield* other;
        });
    }

    /**
     * Returns a sequence with the same items, except the item at the given index is replaced.
     * If the index is not reached during iteration, an exception is thrown.
     * @param {!int} index
     * @param {A} overlayedItem
     * @returns {!Seq.<T|A>}
     * @template T, A
     */
    withOverlayedItem(index, overlayedItem) {
        if (index < 0) {
            throw new Error("needed index >= 0");
        }
        let self = this;
        return Seq.fromGenerator(function*() {
            if (self.tryPeekCount() !== undefined && index >= self.tryPeekCount()) {
                throw new Error("needed index <= count");
            }
            let i = 0;
            for (let e of self._iterable) {
                yield i === index ? overlayedItem : e;
                i++;
            }
            if (i <= index) {
                throw new Error("sequence ended before overlay " +
                    "[withOverlayedItem(${index}, ${overlayedItem})]");
            }
        });
    }

    /**
     * Returns a sequence with the same items, except the item at the given index is transformed by the given function.
     * If the index is not reached during iteration, an exception is thrown.
     * @param {!int} index
     * @param {!function(T) : A} itemTransformation
     * @returns {!Seq.<T|A>}
     * @template T, A
     */
    withTransformedItem(index, itemTransformation) {
        if (index < 0) {
            throw new Error("needed index >= 0");
        }
        let self = this;
        return Seq.fromGenerator(function*() {
            if (self.tryPeekCount() !== undefined && index >= self.tryPeekCount()) {
                throw new Error("needed index <= count");
            }
            let i = 0;
            for (let e of self._iterable) {
                yield i === index ? itemTransformation(e) : e;
                i++;
            }
            if (i <= index) {
                throw new Error("sequence ended before transformation " +
                    "[withTransformedItem(${index}, ${itemTransformation})]");
            }
        });
    }

    /**
     * Returns a sequence with the same items, except the given extra item is yielded when the given index is reached.
     * If the insertion index is the length of the sequence, the inserted item is the last yielded item.
     * If the insertion index is past the length of the sequence, an error is thrown (but only at the end of iteration).
     *
     * @param {A} item
     * @param {!int} index
     * @returns {!Seq.<T|A>}
     * @template T, A
     */
    withInsertedItem(index, item) {
        if (index < 0) {
            throw new Error("needed index >= 0");
        }
        let self = this;
        return Seq.fromGenerator(function*() {
            if (self.tryPeekCount() !== undefined && index > self.tryPeekCount()) {
                throw new Error("needed index <= count");
            }
            let i = 0;
            for (let e of self._iterable) {
                if (i === index) {
                    yield item;
                }
                i++;
                yield e;
            }
            if (i === index) {
                yield item;
            }
            if (i < index) {
                throw new Error("sequence ended before insertion [withInsertedItem(${index}, ${item})]");
            }
        });
    }

    /**
     * Returns a sequence with the same items, until one of the items fails to match the given predicate. Then the
     * sequence is cut short just before yielding that item.
     * @param {!function(T) : !boolean} predicate
     * @returns {!Seq.<T>}
     * @template T
     */
    takeWhile(predicate) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            for (let e of seq) {
                if (!predicate(e)) {
                    break;
                }
                yield e;
            }
        });
    }

    /**
     * Returns a sequence with the same items, except items are dropped from the end of the sequence until the last item
     * doesn't satisfy the given predicate.
     * @param {!function(T) : !boolean} predicate
     * @returns {!Seq.<T>}
     * @template T
     */
    skipTailWhile(predicate) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let tail = [];
            for (let e of seq) {
                if (predicate(e)) {
                    tail.push(e);
                } else {
                    yield* tail;
                    tail = [];
                    yield e;
                }
            }
        });
    }

    /**
     * Returns a sequence with the same items, except items at the start of the sequence are skipped until an item
     * doesn't satisfy the given predicate.
     * @param {!function(T) : !boolean} predicate
     * @returns {!Seq.<T>}
     * @template T
     */
    skipWhile(predicate) {
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let matched = true;
            for (let e of seq) {
                matched = matched && predicate(e);
                if (!matched) {
                    yield e;
                }
            }
        });
    }

    /**
     * Returns a sequence with the same items, except cut short if it exceeds the given maximum count.
     * @param {!int} maxTakeCount
     * @returns {!Seq.<T>}
     * @template T
     */
    take(maxTakeCount) {
        if (maxTakeCount < 0) {
            throw new Error("needed maxTakeCount >= 0");
        }
        if (maxTakeCount === 0) {
            return new Seq([]);
        }
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let i = 0;
            for (let e of seq) {
                yield e;
                i++;
                if (i >= maxTakeCount) {
                    break;
                }
            }
        });
    }

    /**
     * Returns a sequence with the same items, except the give number are skipped at the start.
     * @param {!int} maxSkipCount
     * @returns {!Seq.<T>}
     * @template T
     */
    skip(maxSkipCount) {
        if (maxSkipCount < 0) {
            throw new Error("needed maxSkipCount >= 0");
        }
        if (maxSkipCount === 0) {
            return this;
        }

        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let i = 0;
            for (let e of seq) {
                if (i >= maxSkipCount) {
                    yield e;
                }
                i++;
            }
        });
    }

    /**
     * Returns a sequence with the same items, except later items with the same key as earlier items get skipped.
     *
     * @param {!function(T) : K} keySelector Items are considered distinct when their image, through this function, is
     * not already in the Set of seen images. The return type must support being inserted into a Set.
     * @returns {!Seq.<T>}
     * @template T, K
     */
    distinctBy(keySelector) {
        let seq = this;
        return Seq.fromGenerator(function() {
            let keySet = new GeneralSet();
            return seq.filter(e => {
                let key = keySelector(e);
                if (keySet.has(key)) {
                    return false;
                }
                keySet.add(key);
                return true;
            })[Symbol.iterator]();
        });
    }

    /**
    * Returns a sequence with the same items, except duplicate items are omitted.
    * The items must support being inserted into / found in a Set.
    * @returns {!Seq.<T>}
     * @template T
    */
    distinct() {
        return this.distinctBy(e => e);
    }

    /**
     * @param {!function(T):*} keySelector
     * @returns {!Seq.<T>}
     * @template T
     */
    segmentBy(keySelector) {
        let seq = this;
        return Seq.fromGenerator(function*() {
            let group = [];
            let lastKey = undefined;
            for (let item of seq) {
                let itemKey = keySelector(item);
                if (group.length > 0 && itemKey !== lastKey) {
                    yield group;
                    group = [];
                }
                group.push(item);
                lastKey = itemKey;
            }
            if (group.length > 0) {
                yield group;
            }
        });
    }

    /**
     * Returns the single item in the sequence. If there are no items or multiple items in the sequence, either an error
     * is thrown or an alternative value is returned.
     *
     * @param {=A} emptyManyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty or has more than one value.
     * @returns {T|A}
     * @template T, A
     */
    single(emptyManyErrorAlternative = THROW_IF_EMPTY) {
        let iter = this[Symbol.iterator]();

        let first = iter.next();
        if (!first.done && iter.next().done) {
            return first.value;
        }

        if (emptyManyErrorAlternative === THROW_IF_EMPTY) {
            if (first.done) {
                throw new Error("Empty sequence doesn't contain a single item.")
            } else {
                throw new Error("Sequence contains more than a single item.")
            }
        }

        return emptyManyErrorAlternative;
    }

    /**
     * Returns the first item in the sequence.
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @returns {T|A}
     * @template T, A
     */
    first(emptyErrorAlternative = THROW_IF_EMPTY) {
        let iter = this[Symbol.iterator]();

        let first = iter.next();
        if (!first.done) {
            return first.value;
        }

        if (emptyErrorAlternative === THROW_IF_EMPTY) {
            throw new Error("Empty sequence has no first item.")
        }

        return emptyErrorAlternative;
    }

    /**
     * Returns the last item in the sequence.
     * @param {=A} emptyErrorAlternative The value to return if the sequence is empty. If not provided, an error
     * is thrown when the sequence is empty.
     * @returns {T|A}
     * @template T, A
     */
    last(emptyErrorAlternative = THROW_IF_EMPTY) {
        //noinspection JSUnusedAssignment
        let result = EMPTY_SYGIL;
        for (let e of this._iterable) {
            result = e;
        }
        return emptyFallback(result, emptyErrorAlternative, "Empty sequence has no last item.");
    }

    /**
     * If the sequence is of a known type with a known number of items, then returns the length of the sequence.
     * Otherwise, returns undefined.
     * It is guaranteed that the sequence will not be iterated by this method.
     * @returns {!int|undefined}
     */
    tryPeekCount() {
        if (Array.isArray(this._iterable) || !GENERIC_ARRAY_TYPES.every(t => !(this._iterable instanceof t))) {
            return this._iterable.length;
        }
        if (this._iterable instanceof Map || this._iterable instanceof Set) {
            return this._iterable.size;
        }
        return undefined;
    }

    /**
     * Determines the number of items in the sequence.
     * Uses length/size methods of known types, when possible, but otherwise falls back to iterating all the items.
     * Gets stuck in a loop if the sequence is unbounded.
     * @returns {!int}
     */
    count() {
        let known = this.tryPeekCount();
        if (known !== undefined) {
            return known;
        }

        let n = 0;
        //noinspection JSUnusedLocalSymbols
        for (let _ of this._iterable) {
            n++;
        }
        return n;
    }

    /**
     * Returns a sequence starting with the same items, but padded up to the given length with the given item. If the
     * sequence already exceeds the given length, no items are added.
     * @param {!int} minCount
     * @param {A=} paddingItem
     * @returns {!Seq.<T|A>}
     * @template T, A
     */
    padded(minCount, paddingItem=undefined) {
        if (minCount < 0) {
            throw new Error("needed minCount >= 0");
        }
        let seq = this._iterable;
        return Seq.fromGenerator(function*() {
            let remaining = minCount;
            for (let e of seq) {
                yield e;
                remaining -= 1;
            }
            while (remaining > 0) {
                yield paddingItem;
                remaining -= 1;
            }
        });
    }

    /**
     * Returns a sequence containing the same items, but in ascending order.
     * @returns {!Seq.<T>}
     * @template T
     */
    sorted() {
        return this.sortedBy(e => e);
    }

    /**
     * Returns a sequence containing the same items, but in ascending order of outputs from the given function.
     * @returns {!Seq.<T>}
     * @template T
     */
    sortedBy(keySelector) {
        return seq(this.toArray().sort((e1, e2) => {
            let out1 = keySelector(e1);
            let out2 = keySelector(e2);
            return out1 < out2 ? -1 :
                   out1 > out2 ? +1 :
                   0;
        }));
    }

    /**
     * Returns all possible permutations of the items in the sequence.
     * @returns {!Seq.<!Array.<T>>}
     * @template T
     */
    permutations() {
        let seq = this;
        return Seq.fromGenerator(function*() {
            yield* _permutations(seq.toArray());
        });
    }

    /**
     * Conditionally applies a transformation to the sequence.
     * If the given condition is false, the original sequence is returned.
     * If the given condition is true, the sequence is run through the given transformation and the result is returned.
     *
     * This method mainly exists for syntactic convenience, so a dotted pipeline can be done in a single expression.
     * For example, <code>seq.map(e => e + 1).ifThen(filterFlag, s => s.filter(e => e == 1)).toArray()</code>
     *
     * @param {!boolean} condition
     * @param {!function(!Seq<T>) : ((!Seq<T>)|(!Iterable.<T>)|(!(T[]))|*)} sequenceTransformation
     * @template T
     */
    ifThen(condition, sequenceTransformation) {
        return condition ? new Seq(sequenceTransformation(this)) : this;
    }

    /**
     * Returns a map containing the key/value pairs created by projecting each of the items in the sequence through
     * key and value selector functions.
     *
     * If any duplicate keys are generated, an exception is thrown.
     *
     * @param {!function(T): K} keySelector
     * @param {!function(T): V} valueSelector
     * @returns {!Map.<K, V>}
     * @template T, K, V
     */
    toMap(keySelector, valueSelector) {
        let map = new Map();
        for (let item of this._iterable) {
            let key = keySelector(item);
            let val = valueSelector(item);

            if (map.has(key)) {
                throw new Error(`Duplicate key <${key}>. Came from item <${item}>.`);
            }
            map.set(key, val);
        }
        return map;
    }

    /**
     * Returns a map where the items from the sequence are indexed by the result of running them through the given key
     * selector function.
     *
     * If any duplicate keys are generated, an exception is thrown.
     *
     * @param {!function(T): K} keySelector
     * @returns {!Map.<K, V>}
     * @template T, K, V
     */
    keyedBy(keySelector) {
        return this.toMap(keySelector, e => e);
    }

    /**
     * Returns a map, with keys generated by passing the sequence's items through the given key selector, where each key
     * maps to an array of the items (from the sequence) that mapped to said key.
     * @param {!function(T): K} keySelector
     * @param {!function(T): R} valueSelector
     * @returns {!Map.<K, !(R[])>}
     * @template T, K, R
     */
    groupBy(keySelector, valueSelector = e => e) {
        let map = new Map();
        for (let item of this._iterable) {
            let key = keySelector(item);
            if (!map.has(key)) {
                map.set(key, []);
            }
            map.get(key).push(valueSelector(item));
        }
        return map;
    }

    /**
     * Groups elements into arrays of the given size (except for the last partition, which may be smaller) and yields
     * the groups instead of individual items.
     * @param {!int} partitionSize
     * @returns {!Seq.<!(T[])>}
     * @template T
     */
    partitioned(partitionSize) {
        if (partitionSize <= 0) {
            throw new Error("need partitionSize > 0");
        }
        let seq = this;
        return Seq.fromGenerator(function*() {
            let buffer = [];
            for (let item of seq) {
                buffer.push(item);
                if (buffer.length >= partitionSize) {
                    yield buffer;
                    buffer = [];
                }
            }
            if (buffer.length > 0) {
                yield buffer;
            }
        });
    }

    /**
     * Iterates the elements in the subsequence that are at indices congruent to 0 modulo the given step size.
     * @param stepSize
     */
    stride(stepSize) {
        return this.filterWithIndex((e, i) => i % stepSize === 0);
    }

    /**
     * Iterates elements reachable by starting from the given sequence and applying the given neighbor yielding function
     * to known nodes.
     * @param {!function(T) : !(T[])} neighborSelector
     * @param {!function(T) : K} keySelector
     * @returns {!Seq.<T>}
     * @template T, K
     */
    breadthFirstSearch(neighborSelector, keySelector = e => e) {
        let seq = this;
        return Seq.fromGenerator(function*() {
            let visited = new Set();
            let schedule = seq.toArray();
            for (let i = 0; i < schedule.length; i++) {
                let e = schedule[i];
                let k = keySelector(e);
                if (visited.has(k)) {
                    continue;
                }
                visited.add(k);
                for (let neighbor of neighborSelector(e)) {
                    schedule.push(neighbor);
                }
                yield e;
            }
        });
    }
}

/**
 * @param {!Array.<T>} items
 * @yield {!Array.<!T>}
 * @template
 */
function* _permutations(items) {
    if (items.length === 0) {
        yield [];
        return;
    }
    for (let sub of _permutations(items.slice(1))) {
        for (let i = 0; i < items.length; i++) {
            yield [...sub.slice(0, i), items[0], ...sub.slice(i)];
        }
    }
}

/**
 * Wraps an iterable into a Seq.
 * @param {!(T[])|!Seq.<T>|!Iterable.<T>|*} iterable
 * @returns {!Seq.<T>}
 * @template T
 */
let seq = iterable => new Seq(iterable);

_gen_package_export("src/base/Seq.js", {seq, Seq, THROW_IF_EMPTY});;


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Serialize.js", function() {

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");;

class Writer {
    constructor() {
        /** @type {!Array.<!Uint8Array>} */
        this.bufs = [];
    }

    /**
     * @param {!number} v
     */
    writeFloat32(v) {
        this.bufs.push(new Uint8Array(new Float32Array([v]).buffer));
    }

    /**
     * @param {!number} v
     */
    writeFloat64(v) {
        this.bufs.push(new Uint8Array(new Float64Array([v]).buffer));
    }

    /**
     * @param {!int} v
     */
    writeInt8(v) {
        this.bufs.push(new Uint8Array([v]));
    }

    /**
     * @param {!int} v
     */
    writeInt16(v) {
        this.bufs.push(new Uint8Array([
            (v >> 8) & 0xFF,
            v & 0xFF,
        ]));
    }

    /**
     * @param {!int} v
     */
    writeInt32(v) {
        this.bufs.push(new Uint8Array([
            (v >> 24) & 0xFF,
            (v >> 16) & 0xFF,
            (v >> 8) & 0xFF,
            v & 0xFF,
        ]));
    }

    /**
     * @param {!string} text
     */
    writeAsciiString(text) {
        this.writeInt32(text.length);
        let buf = new Uint8Array(text.length);
        for (let i = 0; i < text.length; i++) {
            let c = text.charCodeAt(i);
            if (c >= 128) {
                throw new DetailedError('Not an ascii character.', {code: c, char: text[i]});
            }
            buf[i] = c;
        }
        this.bufs.push(buf);
    }

    /**
     * @param {!Array.<*>} array
     * @param {!function(*)} valueWrite
     */
    writeArray(array, valueWrite) {
        this.writeInt32(array.length);
        for (let val of array) {
            valueWrite(val);
        }
    }

    /**
     * @param {!boolean} b
     */
    writeBooleans(...b) {
        if (b.length > 8) {
            throw new DetailedError('Not implemented.', {b});
        }
        let v = 0;
        for (let i = 0; i < b.length; i++) {
            v |= b[i] ? 1 << i : 0;
        }
        this.writeInt8(v);
    }

    toHex() {
        let result = '';
        for (let buf of this.bufs) {
            for (let e of buf) {
                if (e < 16) {
                    result += '0';
                }
                result += e.toString(16);
            }
        }
        return result;
    }
}

class Reader {
    /**
     * @param {!Uint8Array} bytes
     */
    constructor(bytes) {
        this.offset = 0;
        this.bytes = bytes;
    }

    /**
     * @returns {!boolean}
     */
    isEndOfInput() {
        return this.offset >= this.bytes.length;
    }

    /**
     * @param {!string} hex
     * @returns {!Reader}
     */
    static fromHex(hex) {
        let result = new Uint8Array(hex.length / 2);
        for (let i = 0; i < hex.length; i += 2) {
            result[i >> 1] = parseInt(hex.substr(i, 2), 16);
        }
        return new Reader(result);
    }

    /**
     * @param {!int} count
     * @returns {!Uint8Array}
     */
    readBytes(count) {
        let result = new Uint8Array(count);
        for (let i = 0; i < count; i++) {
            result[i] = this.bytes[this.offset + i];
        }
        this.offset += count;
        return result;
    }

    /**
     * @returns {!number}
     */
    readFloat32() {
        return new Float32Array(this.readBytes(4).buffer)[0];
    }

    /**
     * @returns {!number}
     */
    readFloat64() {
        return new Float64Array(this.readBytes(8).buffer)[0];
    }

    /**
     * @returns {!int}
     */
    readInt8() {
        let result = this.bytes[this.offset];
        this.offset += 1;
        return result;
    }

    /**
     * @returns {!int}
     */
    readInt32() {
        let a = this.readInt8();
        let b = this.readInt8();
        let c = this.readInt8();
        let d = this.readInt8();
        return d | (c << 8) | (b << 16) | (a << 24);
    }

    /**
     * @returns {!int}
     */
    readInt16() {
        let a = this.readInt8();
        let b = this.readInt8();
        return b | (a << 8);
    }

    /**
     * @param {!int} count
     * @returns {!Array.<!boolean>}
     */
    readBooleans(count) {
        let b = this.readInt8();
        let result = [];
        for (let i = 0; i < count; i++) {
            result.push(((1 << i) & b) !== 0);
        }
        return result;
    }

    /**
     * @param {!function(): *} valueRead
     * @returns {!Array.<*>}
     */
    readArray(valueRead) {
        let size = this.readInt32();
        let result = [];
        for (let i = 0; i < size; i++) {
            let val = valueRead();
            result.push(val);
        }
        return result;
    }

    /**
     * @returns {!string}
     */
    readAsciiString() {
        let size = this.readInt32();
        let result = '';
        for (let i = 0; i < size; i++) {
            result += String.fromCharCode(this.readInt8());
        }
        return result;
    }
}

_gen_package_export("src/base/Serialize.js", {Writer, Reader});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/base/Util.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");

/**
 * Miscellaneous utility methods.
 */
class Util {
    /**
     * Checks a precondition, throwing an exception containing the given message in the case of failure.
     * @param {!boolean|*} expression
     * @param {=string} message
     * @param {=Array} args
     */
    static need(expression, message, args) {
        if (expression !== true) {
            let argDesc = args === undefined ?
                "(not provided)" :
                `[${ Array.prototype.slice.call(args).join(", ") }]` ;
            let msgDesc = message === undefined ? "(not provided)" : message;
            let msg = "Precondition failed" +
                "\n\nMessage: " + msgDesc +
                "\n\nArgs: " + argDesc;
            throw new Error(msg);
        }
    }

    static numberOfSetBits(i) {
        if (i < 0) { throw new Error("i < 0"); }
        if (!Number.isInteger(i)) { throw new Error("!Number.isInteger(i)"); }
        if (i > 0xFFFFFFFF) { throw new Error("i > 0xFFFFFFFF"); }

        // Start with each bit representing its own pop count.
        // Merge adjacent 1-bit pop counts into 2-bit pop counts.
        i = (i & 0x55555555) + ((i >> 1) & 0x55555555);
        // Merge adjacent 2-bit pop counts into 4-bit pop counts.
        i = (i & 0x33333333) + ((i >> 2) & 0x33333333);
        // Merge adjacent 4-bit pop counts into 8-bit pop counts.
        // Because log(8) < 4, the count won't overflow in to the adjacent 4-bit count. Masking can happen after.
        i = (i + (i >> 4)) & 0x0F0F0F0F;
        // Merge adjacent 8-bit pop counts into 16-bit pop counts.
        // Because log(48) < 8, we no longer need to mask while merging.
        i += i >> 8;
        // Merge adjacent 16-bit pop counts into 32-bit pop counts.
        i += i >> 16;
        // Done. The total is in the low byte (the others contain noise due to lack of masking during later merges).
        return i & 0xFF;
    }

    /**
     * Returns a big-endian binary representation of the given number, zero-padded and truncated to the given length.
     * @param {!number|!int} number
     * @param {!int} fixedLen
     * @returns {!string}
     */
    static bin(number, fixedLen) {
        return ("0".repeat(fixedLen) + number.toString(2)).slice(-fixedLen).split("").join("");
    }

    /**
     * Forced cast from nullable to non-nullable, throwing an exception on failure.
     * @param {?T} v
     * @returns {!T}
     * @template T
     */
    static notNull(v) {
        Util.need(v !== null, "notNull");
        //noinspection JSValidateTypes
        return v;
    }

    /**
     * Determines if there is an integer p such that 2^p equals the given integer.
     * @param {!int} i
     * @returns {!boolean}
     */
    static isPowerOf2(i) {
        return i > 0 && ((i - 1) & i) === 0;
    }

    /**
     * Returns the number of bits needed to uniquely encode all integers up to and including the given value.
     * A discrete off-by-one version of log_2(n).
     * @param {!int} n
     * @returns {!int}
     */
    static bitSize(n) {
        Util.need(n >= 0, "bitSize: n >= 0");
        if (n === 0) {
            return 0;
        }
        return Util.floorLg2(n) + 1;
    }

    /**
     * Returns the smallest power of 2 that is equal to or larger than the given integer.
     * @param {!int} n
     * @returns {!int}
     */
    static ceilingPowerOf2(n) {
        if (n <= 1) {
            return 1;
        }
        return 1 << Util.ceilLg2(n);
    }

    /**
     * @param {!int} n
     * @returns {!int} A value p such that 2**(p-1) < n <= 2**p.
     */
    static ceilLg2(n) {
        if (n <= 1) {
            return 0;
        }
        let p = Math.ceil(Math.log2(n));
        if (1<<p < n) {
            return p + 1;
        }
        if (n <= 1<<(p-1)) {
            return p - 1;
        }
        return p;
    }

    /**
     * @param {!int} n
     * @returns {!int} A value p such that 2**p <= n < 2**(p+1).
     */
    static floorLg2(n) {
        if (n <= 1) {
            return 0;
        }
        let p = Math.floor(Math.log2(n));
        if (1<<(p+1) <= n) {
            return p + 1;
        }
        if (n < 1<<p) {
            return p - 1;
        }
        return p;
    }

    /**
     * Determines how multiply-even a number is; how many times you can divide it by 2 before getting an odd result.
     * Odd numbers have 0 power-of-two-ness, multiples of 2 that aren't multiples of 4 have 1 power-of-two-ness,
     * multiples of 4 that aren't multiples of 8 have 3 power-of-two-ness, and so forth.
     *
     * Note that zero has infinite power-of-two-ness.
     *
     * @param {!int} i
     * @returns {!int}
     */
    static powerOfTwoness(i) {
        if (i === 0) {
            return Math.POSITIVE_INFINITY;
        }
        if (i < 0) {
            return Util.powerOfTwoness(-i);
        }
        let lowMask = i ^ (i - 1);
        let lowBit = i & lowMask;
        return Math.round(Math.log2(lowBit));
    }

    /**
     * Converts from Map.<K, V[]> to Map.<V, K[]> in the "obvious" way, by having each value map to the group of keys that
     * mapped to a group containing said value in the original map.
     * @param {!Map.<K, !(V[])>} groupMap
     * @param {!boolean=} includeGroupsForOriginalKeysEvenIfEmpty
     * @returns {!Map.<V, !(K[])>}
     * @template K, V
     */
    static reverseGroupMap(groupMap, includeGroupsForOriginalKeysEvenIfEmpty = false) {
        let result = new Map();

        if (includeGroupsForOriginalKeysEvenIfEmpty) {
            for (let e of groupMap.keys()) {
                result.set(e, []);
            }
        }

        for (let [k, g] of groupMap) {
            //noinspection JSUnusedAssignment
            for (let e of g) {
                if (!result.has(e)) {
                    result.set(e, []);
                }
                //noinspection JSUnusedAssignment
                result.get(e).push(k);
            }
        }

        return result;
    }

    /**
     * Performs a binary search, looking for the first index to return false under the constraint that the given
     * function returns true for all arguments less than some index and false afterwards.
     *
     * @param {!int} max Determines the range to search over. Valid inputs to the query function are non-negative
     * integers up to this maximum than this count.
     * @param {!function(!int) : !boolean} argIsBeforeTransitionFunc Determines if the transition happens before or
     * after the given index.
     * @returns {!int}
     */
    static binarySearchForTransitionFromTrueToFalse(max, argIsBeforeTransitionFunc) {
        let min = 0;
        while (max > min) {
            let med = min + Math.floor((max - min) / 2);
            if (argIsBeforeTransitionFunc(med)) {
                min = med + 1;
            } else {
                max = med;
            }
        }
        return min;
    }

    /**
     * Breaks a single line of characters into several lines, when forced to by a width boundary.
     * @param {!string} text A single unbroken line of text, without any newline characters.
     * @param {!number} maxWidth The maximum width that lines can grow to before they must be broken.
     * @param {!function(!string) : !number} measureWidth Measure the width of a substring.
     * @returns {!(!string[])}
     */
    static breakLine(text, maxWidth, measureWidth) {
        if (text === "") {
            return [""];
        }
        let lines = [];
        let p = 0;
        while (p < text.length) {
            // How many characters will fit on this line?
            let maxKeepLength = Util.binarySearchForTransitionFromTrueToFalse(
                text.length - p + 1,
                i => measureWidth(text.substr(p, i)) <= maxWidth) - 1;
            maxKeepLength = Math.max(1, maxKeepLength);
            let maxChunk = text.substr(p, maxKeepLength);

            let hitBoundary = p + maxKeepLength === text.length ||
                text.substr(p + maxKeepLength, 1).match(/\s/) !== null;
            if (!hitBoundary) {
                // If some of the chunk words fit, defer the split word into the next line.
                let niceRegex = /^(.*\S)(\s+)\S*$/;
                let niceChunkMatch = niceRegex.exec(maxChunk);
                if (niceChunkMatch !== null) {
                    let keepChunk = niceChunkMatch[1];
                    let skipChunk = niceChunkMatch[2];
                    lines.push(keepChunk.trim());
                    p += keepChunk.length + skipChunk.length;
                    continue;
                }
            }

            // Taking the entire chunk, either due to a lucky break in the right place or an unavoidable word split.
            lines.push(maxChunk.trim());
            p += maxChunk.length;

            // Skip starting whitespace
            p += text.substr(p).match(/^\s*/)[0].length;
        }
        return lines;
    }

    /**
     * Enumerates the fields of an object, stashing their values into an array.
     * Array fields are flattened into the result array.
     *
     * @param {*} object
     * @returns {!Array.<*>}
     */
    static decomposeObjectValues(object) {
        let result = [];

        let decomposeValueOrArray;
        decomposeValueOrArray = val => {
            if (Array.isArray(val)) {
                for (let item of val) {
                    decomposeValueOrArray(item);
                }
            } else {
                result.push(val);
            }
        };

        for (let key of Object.keys(object).sort()) {
            decomposeValueOrArray(object[key], result);
        }
        return result;
    }

    /**
     * @param {*} originalObject
     * @param {!Array.<*>} newFieldValues
     * @returns {!object}
     */
    static recomposedObjectValues(originalObject, newFieldValues) {
        let result = {};
        let i = 0;

        let recomposeValueOrArray;
        recomposeValueOrArray = originalVal => {
            if (Array.isArray(originalVal)) {
                let arr = [];
                for (let item of originalVal) {
                    arr.push(recomposeValueOrArray(item));
                }
                return arr;
            }

            return newFieldValues[i++];
        };

        for (let key of Object.keys(originalObject).sort()) {
            result[key] = recomposeValueOrArray(originalObject[key]);
        }
        Util.need(i === newFieldValues.length, "Mismatched field value count.");
        return result;
    }

    /**
     * @param {!function(!Array.<*>) : !Array.<*>} func
     * @returns {!function(!object) : !object}
     */
    static objectifyArrayFunc(func) {
        return arg => Util.recomposedObjectValues(arg, func(Util.decomposeObjectValues(arg)));
    }

    /**
     * Returns the cosine and sine of an angle, except that when the angle is the closest approximation to a multiple of
     * π/4 the result is snapped to a nice vector by assuming the input was an exact multiple.
     * @param {!number} radians
     * @returns {!Array.<!number>}
     */
    static snappedCosSin(radians) {
        let unit = Math.PI/4;
        let i = Math.round(radians / unit);
        if (i*unit === radians) {
            const s = Math.sqrt(0.5);
            const snaps = [
                [1, 0],
                [s, s],
                [0, 1],
                [-s, s],
                [-1, 0],
                [-s, -s],
                [0, -1],
                [s, -s]
            ];
            return snaps[i & 7];
        }
        return [Math.cos(radians), Math.sin(radians)];
    }

    /**
     * Returns the math-style remainder, which is guaranteed to be in the range [0, denominator) even when the numerator
     * is negative.
     * @param {!number} numerator
     * @param {!number} denominator
     * @returns {!number}
     */
    static properMod(numerator, denominator) {
        if (denominator <= 0) {
            throw new DetailedError("denominator <= 0", {numerator, denominator});
        }
        let result = numerator % denominator;
        return result + (result < 0 ? denominator : 0);
    }

    /**
     * @param {...!Map}maps
     * @returns {!Map}
     */
    static mergeMaps(...maps) {
        let result = new Map();
        for (let map of maps) {
            for (let [key, val] of map.entries()) {
                //noinspection JSUnusedAssignment
                result.set(key, val);
            }
        }
        return result;
    }

    /**
     * @param {!int} value
     * @param {!int} modulus
     * @returns {!int} A value r in [0, modulus) such that r*value = 1 (mod modulus).
     */
    static modular_multiplicative_inverse(value, modulus) {
        let {x, gcd} = Util.extended_gcd(value, modulus);
        if (gcd !== 1) {
            return undefined;
        }
        x %= modulus;
        if (x < 0) {
            x += modulus;
        }
        return x;
    }

    /**
     * @param {!int} a
     * @param {!int} b
     * @returns {!{x: !int, y: !int, gcd: !int}} Such that x*a + y*b = gcd = GCD(a, b)
     */
    static extended_gcd(a, b) {
        let s = 0;
        let t = 1;
        let r = b;

        let old_s = 1;
        let old_t = 0;
        let old_r = a;
        while (r !== 0) {
            let q = Math.floor(old_r / r);
            [old_r, r] = [r, old_r - q * r];
            [old_s, s] = [s, old_s - q * s];
            [old_t, t] = [t, old_t - q * t];
        }
        return {x: old_s, y: old_t, gcd: old_r};
    }

    /**
     * @param {!string} text
     * @returns {!string}
     */
    static digits_to_superscript_digits(text) {
        let digits = "0123456789";
        let superscript_digits = "⁰¹²³⁴⁵⁶⁷⁸⁹";
        for (let i = 0; i < 10; i++) {
            text = text.split(digits[i]).join(superscript_digits[i]);
        }
        return text;
    }
}

/**
 * Determines if the two given values are exactly the same, as determined by the `===` operator.
 * @param {*} e1
 * @param {*} e2
 * @return {!boolean}
 */
Util.STRICT_EQUALITY = (e1, e2) => e1 === e2;

/**
 * Uses the `isEqualTo` property of the first argument to determine equality with the second argument. Handles the case
 * where both are null, returning true instead of throwing.
 *
 * @param {?T|*} e1
 * @param {?T|*} e2
 * @returns {!boolean}
 * @template T
 */
Util.CUSTOM_IS_EQUAL_TO_EQUALITY = (e1, e2) =>
    e1 === null ? e2 === null :
    e1 === undefined ? e2 === undefined :
    e1.isEqualTo(e2);


/**
 * @param {!string} text
 * @param {!string} indentation
 * @returns {!string}
 */
function indent(text, indentation='    ') {
    return text.split('\n').map(e => e.length > 0 ? indentation + e : e).join('\n');
}

/**
 * @param {!int} k
 * @returns {!int}
 */
function popcnt(k) {
    let t = 0;
    while (k > 0) {
        k &= k - 1;
        t += 1;
    }
    return t;
}


_gen_package_export("src/base/Util.js", {Util, indent, popcnt});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/browser/Clipboard.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @param {!HTMLElement} element
 * @throws
 */
function selectAndCopyToClipboard(element) {
    if (document.selection) {
        //noinspection XHTMLIncompatabilitiesJS
        let range = document.body.createTextRange();
        range.moveToElementText(element);
        range.select();
    } else if (window.getSelection) {
        let range = document.createRange();
        range.selectNodeContents(element);
        window.getSelection().removeAllRanges();
        window.getSelection().addRange(range);
    }

    if (!document.execCommand('copy')) {
        throw new Error("execCommand failed");
    }
}

_gen_package_export("src/browser/Clipboard.js", {selectAndCopyToClipboard});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/browser/HistoryPusher.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");

/**
 * Manages interactions with the browser's history as the app's state changes and frequently updates the URL.
 */
class HistoryPusher {
    constructor() {
        /**
         * @type {!boolean}
         * @private
         */
        this._historyActionsNotWorking = false;
        /**
         * @type {undefined|*}
         * @private
         */
        this._currentMemorableStateObj = undefined;
    }

    /**
     * Indicates that the current state should be preserved in the browser history if the user transitions away from it.
     *
     * Because the state isn't known, any transition will trigger the preservation (possibly creating a duplicate
     * history entry).
     */
    currentStateIsMemorableButUnknown() {
        this._currentMemorableStateObj = {wont_equal_this: true};
    }

    /**
     * Indicates that the current state should be preserved in the browser history if the user transitions away from it.
     * @param {*} stateObj An ===-able object representing the current state, for identifying spurious transitions.
     */
    currentStateIsMemorableAndEqualTo(stateObj) {
        this._currentMemorableStateObj = stateObj;
    }

    /**
     * Indicates that the current state should not be preserved in the browser history if the user transitions away.
     * States are not-memorable by default.
     */
    currentStateIsNotMemorable() {
        this._currentMemorableStateObj = undefined;
    }

    /**
     * @param {*} stateObj An equatable (by ===) object representing the latest state.
     * @param {!string} stateUrlHash A document.location.hash value that will lead to the latest state.
     */
    stateChange(stateObj, stateUrlHash) {
        if (!stateUrlHash.startsWith('#')) {
            throw new DetailedError("Expected a hash URL.", {stateObj, stateUrlHash});
        }
        if (this._currentMemorableStateObj === stateObj) {
            return;
        }
        if (this._historyActionsNotWorking) {
            // This is worse than using the history API, since it inserts junk after every state change, but it's also
            // better than just randomly losing the circuit.
            document.location.hash = stateUrlHash;
            return;
        }

        try {
            // 'Memorable' states should stay in the history instead of being replaced.
            if (this._currentMemorableStateObj === undefined) {
                history.replaceState(stateObj, "", stateUrlHash);
            } else {
                history.pushState(stateObj, "", stateUrlHash);
                this._currentMemorableStateObj = undefined;
            }
        } catch (ex) {
            // E.g. this happens when running from the filesystem due to same-origin constraints.
            console.warn(
                "Calling 'history.replaceState/pushState' failed. Falling back to setting location.hash.",
                ex);
            this._historyActionsNotWorking = true;
            document.location.hash = stateUrlHash;
        }
    }
}

_gen_package_export("src/browser/HistoryPusher.js", {HistoryPusher});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/Config.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

class Config {}

Config.SUPERPOSITION_BACK_COLOR = '#EFF';
Config.SUPERPOSITION_MID_COLOR = '#8FF';
Config.SUPERPOSITION_FORE_COLOR = '#0BB';

Config.DEFAULT_FILL_COLOR = 'white';
Config.DEFAULT_STROKE_COLOR = 'black';
Config.DEFAULT_TEXT_COLOR = 'black';
Config.DEFAULT_FONT_SIZE = 12;
Config.DEFAULT_FONT_FAMILY = 'sans-serif';
Config.DEFAULT_STROKE_THICKNESS = 1;

_gen_package_export("src/Config.js", {Config});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/edit.js", function() {

const {GeneralSet} = _gen_package_get("src/base/GeneralSet.js");;
const {ZxGraph, ZxEdge, ZxNode, ZxPort} = _gen_package_get("src/sim/ZxGraph.js");;
const {ZxNodeDrawArgs} = _gen_package_get("src/nodes/ZxNodeKind.js");;
const {NODES} = _gen_package_get("src/nodes/All.js");;
const {seq} = _gen_package_get("src/base/Seq.js");;


class Edit {
    /**
     * @param {!function() : !string} describe
     * @param {!function(!ZxGraph)} action
     * @param {!function(!DisplayedZxGraph, !CanvasRenderingContext2D)} preview
     */
    constructor(describe, action, preview) {
        this.describe = describe;
        this.action = action;
        this.drawPreview = preview;
    }

    toString() {
        return `Edit: ${this.describe()}`
    }
}


/**
 * Removes an edge from the graph, along with its leaf nodes.
 * @param {!ZxEdge} edge
 * @returns {!Edit}
 */
function removeEdgeEdit(edge) {
    return new Edit(
        () => `delete ${edge} and its leaf nodes`,
        graph => {
            graph.edges.delete(edge);
            for (let n of edge.nodes()) {
                if (graph.nodes.has(n) && graph.activeUnitEdgesOf(n).length === 0) {
                    graph.nodes.delete(n);
                }
            }
        },
        (displayed, ctx) => {
            let [n1, n2] = edge.nodes();
            let [x1, y1] = displayed.nodeToXy(n1);
            let [x2, y2] = displayed.nodeToXy(n2);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.globalAlpha *= 0.5;
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 3;
            ctx.globalAlpha *= 2;
            ctx.stroke();

            for (let n of [n1, n2]) {
                if (displayed.graph.activeUnitEdgesOf(n).length === 1) {
                    ctx.beginPath();
                    ctx.arc(...displayed.nodeToXy(n), 4, 0, 2*Math.PI);
                    ctx.fillStyle = 'red';
                    ctx.globalAlpha *= 0.5;
                    ctx.fill();
                    ctx.globalAlpha *= 2;
                }
            }
        });
}

/**
 * Removes an edge from the graph, along with its leaf nodes.
 * @param {!ZxGraph} graphAtFocusTime
 * @param {!ZxEdge} edge
 * @returns {undefined|!Edit}
 */
function maybeRemoveEdgeModifier(graphAtFocusTime, edge) {
    let kind = graphAtFocusTime.kind(edge);
    if (kind === undefined || kind === '-') {
        return undefined;
    }

    return new Edit(
        () => `remove modified on ${edge}`,
        graph => {
            graph.edges.set(edge, '-');
        },
        (displayed, ctx) => {
            let [n1, n2] = edge.nodes();
            let [x1, y1] = displayed.nodeToXy(n1);
            let [x2, y2] = displayed.nodeToXy(n2);
            let [cx, cy] = [(x1+x2)/2, (y1+y2)/2];

            ctx.beginPath();
            ctx.arc(cx, cy, 8, 0, 2*Math.PI);
            ctx.fillStyle = 'red';
            ctx.globalAlpha *= 0.5;
            ctx.fill();
            ctx.globalAlpha *= 2;
        });
}

/**
 * Removes an edge from the graph, along with its leaf nodes.
 * @param {!ZxNode|!ZxEdge} element
 * @param {!string} kind
 * @returns {undefined|!Edit}
 */
function setElementKindEdit(element, kind) {
    return new Edit(
        () => `set ${element} kind to ${kind}`,
        graph => graph.setKind(element, kind),
        (displayed, ctx) => {
            let nodeKind = NODES.map.get(kind);
            ctx.save();
            ctx.translate(...displayed.graphElementToCenterXy(element));
            if (nodeKind !== undefined) {
                nodeKind.contentDrawer(ctx, new ZxNodeDrawArgs(graph, element));
            }
            ctx.restore();
        });
}

/**
 * Removes an edge from the graph, along with its leaf nodes.
 * @param {!ZxGraph} graphAtFocusTime
 * @param {!ZxEdge|!ZxNode} elementOnPath
 * @returns {undefined|!Edit}
 */
function maybeRemoveConnectingPathEdit(graphAtFocusTime, elementOnPath) {
    let path = graphAtFocusTime.extendedUnblockedPath(elementOnPath, false);
    if (path.size === 0) {
        return undefined;
    }

    return new Edit(
        () => `delete connecting path touching ${elementOnPath}`,
        graph => graph.deletePath(path),
        (displayed, ctx) => {
            for (let edge of path) {
                let [n1, n2] = edge.nodes();
                let [x1, y1] = displayed.nodeToXy(n1);
                let [x2, y2] = displayed.nodeToXy(n2);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.globalAlpha *= 0.5;
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.globalAlpha *= 2;
                ctx.stroke();
            }
        });
}

/**
 * Removes a node from the graph, along with its edges.
 * @param {!ZxGraph} graphAtFocusTime
 * @param {!ZxNode} node
 * @returns {!Edit}
 */
function maybeContractNodeEdit(graphAtFocusTime, node) {
    let kind = graphAtFocusTime.kind(node);
    let degree = graphAtFocusTime.activeUnitEdgesOf(node).length;
    if (kind === undefined || kind === '+' || degree % 2 === 1) {
        return undefined;
    }

    return new Edit(
        () => `contract ${node} to a crossing.`,
        graph => {
            if (degree === 0) {
                graph.nodes.delete(node);
            } else {
                graph.nodes.set(node, '+');
            }
        },
        (displayed, ctx) => {
            ctx.beginPath();
            ctx.arc(...displayed.nodeToXy(node), 4, 0, 2*Math.PI);
            ctx.fillStyle = 'red';
            ctx.globalAlpha *= 0.5;
            ctx.fill();
            ctx.globalAlpha *= 2;
        })
}

/**
 * @param {!Iterable.<!ZxEdge>|!GeneralSet<!ZxEdge>} edgePath
 * @returns {!ZxEdge}
 */
function edgePathToEdge(edgePath) {
    let seen = new GeneralSet();
    let seenOnce = new GeneralSet();
    for (let edge of edgePath) {
        for (let n of edge.nodes()) {
            if (seen.has(n)) {
                seenOnce.delete(n);
            } else {
                seen.add(n);
                seenOnce.add(n);
            }
        }
    }
    if (seenOnce.size !== 2) {
        throw new Error(`Not a path: ${edgePath}. Wrong endpoint count: ${seenOnce}`);
    }
    return new ZxEdge(...seenOnce);
}

/**
 * @param {!ZxGraph} graph
 * @param {!ZxNode} start
 * @param {!Array.<!ZxNode>} ends
 * @returns {undefined|!{newGraph: !ZxGraph, newPaths: !Array.<!Array.<!ZxEdge>>}
 * @private
 */
function _multiPath_allOrders(graph, start, ends) {
    // Ensure tie breakers always go the same way.
    ends = [...ends];
    ends.sort((a, b) => a.orderVal() - b.orderVal());

    // Optimize over all orderings.
    let result = seq(ends).
        permutations().
        map(ordering => _multiPath_fixedOrder(graph, start, ordering)).
        filter(result => result !== undefined).
        minBy(e => e.newPathLen, null);

    // Package result.
    if (result === null) {
        return undefined;
    }
    return result;
}

/**
 * @param {!ZxGraph} graph
 * @param {!ZxNode} start
 * @param {!Array.<!ZxNode>} ends
 * @returns {undefined|!{newGraph: !ZxGraph, newPaths: !Array.<!Array.<!ZxEdge>>}
 * @private
 */
function _multiPath_fixedOrder(graph, start, ends) {
    let newGraph = graph.copy();
    let newPaths = /* @type {!Array.<!Array.<!ZxEdge>>} */ [];
    let newPathLen = 0;
    for (let oppNode of ends) {
        let path = newGraph.tryFindFreePath(start, oppNode);
        if (path === undefined) {
            return undefined;
        }
        newPaths.push(path);
        newPathLen += path.length;

        for (let edge of path) {
            if (newGraph.has(edge)) {
                throw new Error('Double edged.');
            }
            newGraph.edges.set(edge, '-');
            for (let node of edge.nodes()) {
                if (!newGraph.has(node)) {
                    newGraph.nodes.set(node, '+');
                }
            }
        }
    }
    return {
        newPathLen,
        newPaths,
        newGraph,
    };
}

/**
 * @param {!ZxGraph} graph
 * @param {!ZxNode} node
 * @param {!boolean} includingOrphans
 * @returns {!{newGraph: !ZxGraph, endOfRemovedPathNodes: !Array.<!ZxNode>, removedEdges: !Array.<!ZxEdge>}}
 * @private
 */
function _deleteNodeAndAttachedEdges(graph, node, includingOrphans) {
    let ports = graph.activePortsOf(node);
    let newGraph = graph.copy();
    if (graph.kind(node) === '+') {
        newGraph.nodes.set(node, 'O'); // Temporarily change to a normal node to avoid double-deletes.
    }
    let endOfRemovedPathNodes = /* @type {!Array.<!ZxNode>} */ [];
    let removedEdges = /* @type {!Array.<!ZxEdge>} */ [];
    for (let port of ports) {
        if (!newGraph.has(port.edge)) {
            return undefined;
        }
        let extended = newGraph.extendedUnblockedPath(port.edge);
        removedEdges.push(...extended);
        newGraph.deletePath(extended, false);
        let oppNode = edgePathToEdge(extended).opposite(port.node);
        let newDegree = newGraph.activeUnitEdgesOf(oppNode).length;
        if (includingOrphans && newDegree === 0) {
            newGraph.nodes.delete(oppNode);
        } else {
            endOfRemovedPathNodes.push(oppNode);
        }
    }
    newGraph.nodes.delete(node);
    return {newGraph, endOfRemovedPathNodes, removedEdges}
}

/**
 * Removes a node from the graph, along with its edges.
 * @param {!ZxGraph} graphAtFocusTime
 * @param {!ZxNode} oldPos
 * @param {!ZxNode} newPos
 * @returns {!Edit}
 */
function maybeDragNodeEdit(graphAtFocusTime, oldPos, newPos) {
    if (newPos.isEqualTo(oldPos)) {
        return undefined;
    }
    let nodeKind = graphAtFocusTime.kind(oldPos);
    if (nodeKind === undefined) {
        return undefined;
    }

    let del = _deleteNodeAndAttachedEdges(graphAtFocusTime, oldPos, false);
    if (del.newGraph.has(newPos)) {
        return undefined;
    }
    del.newGraph.nodes.set(newPos, nodeKind);

    let result = _multiPath_allOrders(del.newGraph, newPos, del.endOfRemovedPathNodes);
    if (result === undefined) {
        return undefined;
    }

    return new Edit(
        () => `move ${oldPos} to ${newPos}.`,
        graph => {
            graph.nodes = result.newGraph.nodes;
            graph.edges = result.newGraph.edges;
        },
        (displayed, ctx) => {
            for (let e of del.removedEdges) {
                let [n1, n2] = e.nodes();
                let [x1, y1] = displayed.nodeToXy(n1);
                let [x2, y2] = displayed.nodeToXy(n2);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.globalAlpha *= 0.5;
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.globalAlpha *= 2;
                ctx.stroke();
            }
            for (let p of result.newPaths) {
                for (let e of p) {
                    let [n1, n2] = e.nodes();
                    let [x1, y1] = displayed.nodeToXy(n1);
                    let [x2, y2] = displayed.nodeToXy(n2);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
            }
        })
}

/**
 * Removes a node from the graph, along with its edges.
 * @param {!ZxNode} node
 * @returns {!Edit}
 */
function removeNodeEdit(node) {
    return new Edit(
        () => `delete ${node} and its edges.`,
        graph => {
            let result = _deleteNodeAndAttachedEdges(graph, node, true);
            graph.nodes = result.newGraph.nodes;
            graph.edges = result.newGraph.edges;
        },
        (displayed, ctx) => {
            let result = _deleteNodeAndAttachedEdges(displayed.graph, node, true);

            ctx.beginPath();
            ctx.arc(...displayed.nodeToXy(node), 4, 0, 2*Math.PI);
            ctx.fillStyle = 'red';
            ctx.globalAlpha *= 0.5;
            ctx.fill();
            ctx.globalAlpha *= 2;

            for (let e of result.removedEdges) {
                let [n1, n2] = e.nodes();
                let [x1, y1] = displayed.nodeToXy(n1);
                let [x2, y2] = displayed.nodeToXy(n2);
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.globalAlpha *= 0.5;
                ctx.strokeStyle = 'red';
                ctx.lineWidth = 3;
                ctx.globalAlpha *= 2;
                ctx.stroke();
            }
        })
}


_gen_package_export("src/edit.js", {
    Edit,
    removeEdgeEdit,
    removeNodeEdit,
    maybeRemoveConnectingPathEdit,
    maybeContractNodeEdit,
    maybeRemoveEdgeModifier,
    maybeDragNodeEdit,
    setElementKindEdit,
});;


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/main.js", function() {

/**
 * Entry point for the whole program.
 */

const {DetailedError} = _gen_package_get('src/base/DetailedError.js');
const {describe} = _gen_package_get("src/base/Describe.js");;
window.onerror = function(msg, url, line, col, error) {
    document.getElementById('err_msg').innerText = `${describe(msg)}\n${error.stack}`;
    document.getElementById('err_line').innerText = describe(line);
    document.getElementById('err_time').innerText = '' + new Date().getMilliseconds();
    document.getElementById('err_div').style.display = 'block';
    if (error instanceof DetailedError) {
        document.getElementById('err_gen').innerText = describe(error.details);
    }
};
document.getElementById('ack-error').addEventListener('click', () => {
    document.getElementById('err_div').style.display = 'none';
});

const {Revision} = _gen_package_get("src/base/Revision.js");;
const {ZxGraph, ZxEdge, ZxNode} = _gen_package_get("src/sim/ZxGraph.js");;
const {evalZxGraph} = _gen_package_get("src/sim/ZxGraphEval.js");;
const {evalZxGraphGroundTruth} = _gen_package_get("src/sim/ZxGraphGroundTruth.js");;
const {MathPainter} = _gen_package_get("src/MathPainter.js");;
const {Painter} = _gen_package_get("src/Painter.js");;
const {Rect} = _gen_package_get("src/base/Rect.js");;
const {seq} = _gen_package_get("src/base/Seq.js");;
const {
    Edit,
    removeEdgeEdit,
    removeNodeEdit,
    maybeRemoveConnectingPathEdit,
    maybeContractNodeEdit,
    maybeRemoveEdgeModifier,
    maybeDragNodeEdit,
    setElementKindEdit,
} = _gen_package_get("src/edit.js");;
const {NODES} = _gen_package_get("src/nodes/All.js");;
const {makeNodeRingMenu} = _gen_package_get("src/ui/RingMenu.js");
const {ZxNodeDrawArgs} = _gen_package_get("src/nodes/ZxNodeKind.js");;
const {Point} = _gen_package_get("src/base/Point.js");;
const {floodFillNodeAndUnitEdgeSpace, DisplayedZxGraph} = _gen_package_get("src/ui/DisplayedZxGraph.js");;
const {ObservableValue} = _gen_package_get("src/base/Obs.js");;
const {initUndoRedo} = _gen_package_get("src/ui/UndoRedo.js");;
const {initUrlSync} = _gen_package_get("src/ui/Url.js");;
const {initClear} = _gen_package_get("src/ui/Clear.js");;
const {initExports, obsExportsIsShowing} = _gen_package_get("src/ui/Export.js");;

const canvas = /** @type {!HTMLCanvasElement} */ document.getElementById('main-canvas');
const canvasDiv = /** @type {!HTMLDivElement} */ document.getElementById('main-canvas-div');
const stabilizersDiv = /** @type {!HTMLDivElement} */ document.getElementById('stabilizers-div');

let mouseX = undefined;
let mouseY = undefined;
let curCtrlKey = false;
let curAltKey = false;
let curShiftKey = false;
let curMouseButton = undefined;
let mouseDownX = undefined;
let mouseDownY = undefined;
let menuNode = undefined;
let currentlyDisplayedZxGraph = new DisplayedZxGraph();

let revision = new Revision([new ZxGraph().serialize()], 0, false);

let obsIsAnyOverlayShowing = new ObservableValue(false);
initUrlSync(revision);
initExports(revision, obsIsAnyOverlayShowing.observable());
initUndoRedo(revision, obsIsAnyOverlayShowing);
initClear(revision, obsIsAnyOverlayShowing.observable());
obsExportsIsShowing.
    whenDifferent().
    subscribe(e => {
        obsIsAnyOverlayShowing.set(e);
        canvasDiv.tabIndex = e ? -1 : 0;
    });

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxNode} node
 * @param {!number=} radius
 * @param {!string=} fill
 * @param {!string=} stroke
 */
function drawNode(ctx, displayed, node, radius=8, fill=undefined, stroke=undefined) {
    let kind = displayed.graph.nodes.get(node);
    let nodeKind = NODES.map.get(kind);
    if (nodeKind !== undefined) {
        ctx.save();
        ctx.translate(...displayed.nodeToXy(node));
        nodeKind.contentDrawer(ctx, new ZxNodeDrawArgs(displayed.graph, node));
        ctx.restore();
        return;
    }

    if (stroke !== undefined) {
        ctx.strokeStyle = stroke;
    }
    if (fill !== undefined) {
        ctx.fillStyle = fill;
    } else {
        ctx.fillStyle = 'red';
    }
    ctx.beginPath();
    ctx.arc(...displayed.nodeToXy(node), radius, 0, 2*Math.PI);
    ctx.fill();
    ctx.stroke();
    ctx.lineWidth = 1;
}

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxEdge} edge
 * @param {!number=} thickness
 * @param {!string=} color
 * @param {!boolean} showKind
 */
function drawEdge(ctx, displayed, edge, thickness=1, color='black', showKind=true) {
    let kind = displayed.graph.edges.get(edge);
    let [n1, n2] = edge.nodes();
    ctx.beginPath();
    let [x1, y1] = displayed.nodeToXy(n1);
    let [x2, y2] = displayed.nodeToXy(n2);
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.strokeStyle = color;
    ctx.lineWidth = thickness;
    ctx.stroke();

    if (showKind) {
        let nodeKind = NODES.map.get(kind);
        let [cx, cy] = displayed.graphElementToCenterXy(edge);
        if (nodeKind !== undefined) {
            ctx.save();
            ctx.translate(...displayed.graphElementToCenterXy(edge));
            let fakeGraph = new ZxGraph();
            let fakeNode = new ZxNode(cx*2, cy*2);
            fakeGraph.nodes.set(new ZxNode(x1*2, y1*2), displayed.graph.kind(n1));
            fakeGraph.nodes.set(fakeNode, kind);
            fakeGraph.nodes.set(new ZxNode(x2*2, y2*2), displayed.graph.kind(n2));
            nodeKind.contentDrawer(ctx, new ZxNodeDrawArgs(fakeGraph, fakeNode));
            ctx.restore();
            return;
        }

        let r = [cx - 4, cy - 4, 8, 8];
        if (kind !== '-') {
            ctx.fillStyle = 'red';
            ctx.strokeStyle = 'black';
            ctx.fillRect(...r);
            ctx.strokeRect(...r)
        }
    }
}

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {!DisplayedZxGraph} displayed
 */
function drawFadedNearbyRegion(ctx, displayed) {
    let element = displayed.xyToGraphElement(mouseX, mouseY);
    if (element === undefined) {
        return;
    }

    ctx.globalAlpha *= 0.25;
    let nearby = seq(floodFillNodeAndUnitEdgeSpace(element)).take(150);
    let [cx, cy] = displayed.graphElementToCenterXy(element);
    for (let e of nearby) {
        if (displayed.graph.has(e) || !(e instanceof ZxEdge)) {
            continue;
        }

        let [ex, ey] = displayed.graphElementToCenterXy(e);
        if (Math.abs(ex - cx) >= 100 || Math.abs(ey - cy) >= 100) {
            continue;
        }

        drawEdge(ctx, displayed, e, undefined, 'gray', false);
    }
    ctx.globalAlpha *= 4;
}

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {!DisplayedZxGraph} displayed
 */
function drawFocus(ctx, displayed) {
    ctx.globalAlpha *= 0.5;
    let element = displayed.xyToGraphElement(mouseX, mouseY);
    if (element !== undefined) {
        // Draw connecting path.
        let drewPath = false;
        if (displayed.graph.has(element)) {
            let path = displayed.graph.extendedUnblockedPath(element, false);
            for (let e of path) {
                drewPath = true;
                drawEdge(ctx, displayed, e, 7, 'gray', false);
            }
        }

        if (element instanceof ZxNode) {
            drawNode(ctx, displayed, element, displayed.graph.has(element) ? 12 : 7, 'gray', '#00000000');
        } else if (element instanceof ZxEdge) {
            if (!drewPath) {
                drawEdge(ctx, displayed, element, 7, 'gray', false);
            }
        }
    }
    ctx.globalAlpha *= 2;
}

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param{!DisplayedZxGraph} displayed
 */
function drawPossibleEdit(ctx, displayed) {
    let deletePref = curWantDeleteEdit();
    let choices = deletePref === undefined ? [false, true] : [deletePref];

    if (deletePref === undefined) {
        ctx.globalAlpha *= 0.25;
    }

    let drewEdit = false;
    for (let choice of choices) {
        let edit = pickEdit(displayed, choice, mouseX, mouseY);
        if (edit !== undefined) {
            edit.drawPreview(displayed, ctx);
            drewEdit = true;
        }
    }

    if (deletePref === undefined) {
        ctx.globalAlpha *= 4;
    }
}

/**
 * @param {*} object
 * @param {!string} key
 * @param {*} value
 */
function setIfDiffers(object, key, value) {
    if (object[key] !== value) {
        object[key] = value;
    }
}

let prevGraph = undefined;
let prevResults = undefined;

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {!DisplayedZxGraph} displayed
 * @param {!boolean=} checkGroundTruth
 */
function drawResults(ctx, displayed, checkGroundTruth=false) {
    let graph = displayed.graph;
    if (!graph.isEqualTo(prevGraph)) {
        prevResults = evalZxGraph(graph);
        prevGraph = graph;
    }

    let results = prevResults;
    if (!results.satisfiable) {
        ctx.fillStyle = '#FDD';
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    }
    let numIn = graph.inputNodes().length;
    function descStabilizer(s) {
        let r = s.toString();
        return `${r.slice(0, 1)}${r.slice(1, numIn+1)}→${r.slice(numIn+1)}`;
    }

    setIfDiffers(
        stabilizersDiv,
        'innerText',
        results.stabilizers.map(descStabilizer).join('\n'));

    let waveRect = new Rect(canvas.clientWidth - 300, 0, 300, 300);
    let painter = new Painter(ctx);
    if (results.satisfiable && results.wavefunction !== undefined) {
        MathPainter.paintMatrix(painter, results.wavefunction, waveRect);

        if (checkGroundTruth) {
            let groundTruth = evalZxGraphGroundTruth(graph);
            let groundSatisfiable = !groundTruth.isZero(1e-8);
            let detectedBadSimulationResult = false;
            if (groundSatisfiable && results.satisfiable) {
                let matchedGround = groundTruth.phaseMatchedTo(
                    results.wavefunction, true);
                if (!matchedGround.isApproximatelyEqualTo(results.wavefunction,
                    1e-8)) {
                    // Disagreed about satisfiable result.
                    detectedBadSimulationResult = true;
                }
            } else if (groundSatisfiable !== results.satisfiable) {
                // Disagreed about satisfiability.
                detectedBadSimulationResult = true;
            }
            if (detectedBadSimulationResult) {
                ctx.globalAlpha *= 0.5;
                MathPainter.paintMatrix(painter, groundTruth, waveRect, 'red',
                    'black', '#00000000', '#FFFF00A0');
                ctx.globalAlpha *= 2;
            }
        }
    }

    if (results.successProbability !== 1) {
        let loss = Math.log2(results.successProbability);
        painter.printParagraph(
            [
                `Chance of success: ${Math.round(results.successProbability*100)}%`,
                `(${Math.round(-loss)} coin flips)`
            ].join('\n'),
            waveRect.takeBottom(50).proportionalShiftedBy(0, 1),
            new Point(0.5, 0.5),
            'black',
            20);
    }
    if (!results.satisfiable) {
        painter.printParagraph(
            `Graph isn't satisfiable. It evaluates to the zero tensor.`,
            waveRect.takeBottom(50).proportionalShiftedBy(0, 2),
            new Point(0.5, 0.5),
            'red',
            20);
    }
}

/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxNode} node
 * @returns {![!number, !number]}
 */
function nodeToMenuXy(displayed, node) {
    let [x, y] = displayed.nodeToXy(node);
    x = Math.max(x, 170);
    y = Math.max(y, 140);
    return [x, y];
}

/**
 * @param {!CanvasRenderingContext2D} ctx
 * @param {!DisplayedZxGraph} displayed
 */
function drawGraph(ctx, displayed) {
    let graph = displayed.graph;
    for (let edge of graph.edges.keys()) {
        drawEdge(ctx, displayed, edge);
    }
    for (let node of graph.nodes.keys()) {
        if (graph.kind(node) !== '+') {
            drawNode(ctx, displayed, node);
        }
    }
}

let _drawRequested = false;
function draw() {
    let displayed = currentlyDisplayedZxGraph;

    //noinspection JSUnresolvedVariable
    let t = performance.now();
    if (!_drawRequested && t < displayed.interpolateEndTime) {
        _drawRequested = true;
        requestAnimationFrame(() => {
            _drawRequested = false;
            draw();
        });

    }
    displayed.interpolateTick(t);

    let drawBox = displayed.boundingDrawBox(true);
    canvas.width = Math.max(canvasDiv.clientWidth, drawBox.x + drawBox.w);
    canvas.height = Math.max(400, drawBox.y + drawBox.h);

    let ctx = /** @type {!CanvasRenderingContext2D} */ canvas.getContext('2d');
    ctx.clearRect(0, 0, 10000, 10000);

    ctx.save();
    try {
        if (menuNode === undefined) {
            drawFocus(ctx, displayed);
        }
        try {
            drawResults(ctx, displayed);
            drawFadedNearbyRegion(ctx, displayed);
        } finally {
            drawGraph(ctx, displayed);
            if (menuNode === undefined) {
                drawPossibleEdit(ctx, displayed);
            }
        }

        if (menuNode !== undefined) {
            ctx.save();
            ctx.globalAlpha *= 0.85;
            ctx.beginPath();
            let [nx, ny] = displayed.nodeToXy(menuNode);
            ctx.arc(nx, ny, 1000, 0, 2*Math.PI);
            ctx.lineWidth = 1950;
            ctx.strokeStyle = 'white';
            ctx.stroke();
            ctx.restore();

            let [x, y] = nodeToMenuXy(displayed, menuNode);
            makeNodeRingMenu().draw(ctx, x, y, curShiftKey, mouseX, mouseY);
        }
    } finally {
        ctx.restore();
    }
}

let keyListeners = /** @type {!Map.<!int, !Array.<!function(!KeyboardEvent)>>} */ new Map();

/**
 * @param {!MouseEvent} ev
 * @param {!HTMLElement} element
 * @returns {![!number, !number]}
 */
function eventPosRelativeTo(ev, element) {
    let b = element.getBoundingClientRect();
    return [ev.clientX - b.left, ev.clientY - b.top];
}


/**
 * @param {!DisplayedZxGraph} displayedAtCreationTime
 * @param {!ZxEdge} edge
 * @returns {undefined|!Edit}
 */
function maybeExtendAlongEdgeEdit(displayedAtCreationTime, edge) {
    let graph = displayedAtCreationTime.graph;
    if (graph.edges.has(edge)) {
        return undefined;
    }

    let [n1, n2] = edge.nodes();
    let b1 = graph.nodes.has(n1);
    let b2 = graph.nodes.has(n2);
    if (b1 === b2) {
        return undefined;
    }
    if (b2) {
        [n1, n2] = [n2, n1];
    }

    return new Edit(
        () => `extend along ${edge}`,
        graph => {
            let kind = graph.nodes.get(n1);
            if (kind === 'in' || kind === 'out') {
                graph.nodes.set(n1, 'O');
            }
            graph.nodes.set(n2, kind);
            graph.edges.set(edge, '-');
        },
        (displayed, ctx) => {
            let [x1, y1] = displayed.nodeToXy(n1);
            let [x2, y2] = displayed.nodeToXy(n2);
            let dx = x2 - x1;
            let dy = y2 - y1;
            let d = Math.sqrt(dx * dx + dy * dy);
            dx /= d;
            dy /= d;
            let angle = Math.atan2(dy, dx);
            let painter = new Painter(ctx);
            painter.trace(
                tracer => {
                    tracer.circle(x1, y1, 4);
                    tracer.circle(x2, y2, 4);
                    tracer.line(x1, y1, x2, y2);
                    tracer.arrowHead(x2, y2, 10, angle, Math.PI / 2, 'tip');
                }
            ).thenFill('blue').thenStroke('blue');
        });
}


/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxNode} node
 * @returns {undefined|!Edit}
 */
function maybeExtendToNodeEdit(displayed, node) {
    for (let edge of node.unitEdges()) {
        let edit = maybeExtendAlongEdgeEdit(displayed, edge);
        if (edit !== undefined) {
            return edit;
        }
    }
    return undefined;
}

/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxNode} node
 * @returns {undefined|!Edit}
 */
function maybeRetractNodeEdit(displayed, node) {
    let graph = displayed.graph;
    let edges = graph.activeUnitEdgesOf(node);
    if (edges.length !== 1) {
        return undefined;
    }
    let edge = edges[0];
    let opp = edge.opposite(node);
    let oppDeg = graph.activeUnitEdgesOf(opp).length;
    let kind = graph.nodes.get(node);
    let oppKind = graph.nodes.get(opp);
    let acceptableOverwrites = ['@', 'O'];

    if (oppDeg !== 2) {
        return undefined;
    }

    if (acceptableOverwrites.indexOf(oppKind) === -1) {
        return undefined;
    }

    return new Edit(
        () => `contract ${edge}`,
        graph => {
            graph.edges.delete(edge);
            graph.nodes.delete(node);
            graph.nodes.set(opp, kind);
        },
        (displayed, ctx) => {
            let [x1, y1] = displayed.nodeToXy(node);
            let [x2, y2] = displayed.nodeToXy(opp);
            let dx = x2 - x1;
            let dy = y2 - y1;
            let d = Math.sqrt(dx*dx + dy*dy);
            dx /= d;
            dy /= d;
            let [ex, ey] = [-dy, dx];
            x1 += ex * 10;
            x2 += ex * 10;
            y1 += ey * 10;
            y2 += ey * 10;
            let angle = Math.atan2(dy, dx);
            let painter = new Painter(ctx);
            painter.trace(
                tracer => {
                    tracer.circle(x1, y1, 4);
                    tracer.circle(x2, y2, 4);
                    tracer.line(x1, y1, x2, y2);
                    tracer.arrowHead(x2, y2, 10, angle, Math.PI/2, 'tip');
                }
            ).thenFill('red').thenStroke('red');
        });
}


/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxEdge} edge
 * @returns {undefined|!Edit}
 */
function maybeContractEdgeEdit(displayed, edge) {
    for (let node of edge.nodes()) {
        let edit = maybeRetractNodeEdit(displayed, node);
        if (edit !== undefined) {
            return edit;
        }
    }
    return undefined;
}


/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxNode|!ZxEdge} element
 * @returns {undefined|!Edit}
 */
function maybeDeleteElementEdit(displayed, element) {
    let graph = displayed.graph;
    if (!graph.has(element)) {
        return undefined;
    }

    if (element instanceof ZxNode) {
        return (maybeRemoveConnectingPathEdit(graph, element) ||
            maybeContractNodeEdit(graph, element) ||
            maybeRetractNodeEdit(displayed, element) ||
            removeNodeEdit(element));
    } else if (element instanceof ZxEdge) {
        return (maybeRemoveEdgeModifier(graph, element) ||
            maybeRemoveConnectingPathEdit(graph, element) ||
            maybeContractEdgeEdit(displayed, element) ||
            removeEdgeEdit(element));
    }
}


/**
 * @param {!ZxEdge} edge
 * @returns {!Edit}
 */
function changeEdgeKindEdit(edge) {
    return new Edit(
        () => `cycle ${edge}`,
        graph => {
            let cycle = ['-', 'h', 'x', 'z', 'f', 's', 'w', 'a'];
            let kind = graph.edges.get(edge);
            let i = cycle.indexOf(kind);
            i++;
            i %= cycle.length;
            graph.edges.set(edge, cycle[i]);
        },
        (displayed, ctx) => {
            let [x, y] = displayed.graphElementToCenterXy(edge);
            x += edge.n1.x !== edge.n2.x ? 0 : 15;
            y += edge.n1.x !== edge.n2.x ? 15 : 0;
            ctx.beginPath();
            ctx.arc(x, y, 8, Math.PI/2, 0);
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 3;
            ctx.stroke();
            new Painter(ctx).trace(tracer => {
                tracer.arrowHead(x + 8, y, 4, Math.PI/2, Math.PI/2, 'stem');
            }).thenStroke('blue').thenFill('blue');
        });
}


/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!ZxEdge} edge
 * @returns {undefined|!Edit}
 */
function maybeIntroduceEdgeEdit(displayed, edge) {
    // Check for blocking neighbor.
    let blockKinds = ['in', 'out'];
    for (let node of edge.nodes()) {
        let kind = displayed.graph.nodes.get(node);
        if (blockKinds.indexOf(kind) !== -1) {
            return undefined;
        }
    }

    return new Edit(
        () => `introduce ${edge}`,
        graph => {
            graph.edges.set(edge, '-');
            for (let node of edge.nodes()) {
                if (!graph.nodes.has(node)) {
                    graph.nodes.set(node, 'O');
                }
            }
        },
        (displayed, ctx) => {});
}


/**
 * @param {!DisplayedZxGraph} displayed
 * @param {!boolean} wantDelete
 * @param {!number|undefined} x
 * @param {!number|undefined} y
 * @returns {undefined|!Edit}
 */
function pickEdit(displayed, wantDelete, x, y) {
    if (menuNode !== undefined) {
        let [cx, cy] = nodeToMenuXy(displayed, menuNode);
        let selection = makeNodeRingMenu().entryAt(cx, cy, x, y);
        if (selection !== undefined) {
            if (selection.id === 'del') {
                return maybeDeleteElementEdit(displayed, menuNode);
            }
            return setElementKindEdit(menuNode, selection.id);
        }
        return undefined;
    }

    let oldElement = displayed.xyToGraphElement(mouseDownX, mouseDownY);
    let element = displayed.xyToGraphElement(x, y);
    let nearestNode = displayed.xyToNode(x, y);

    if (element === undefined) {
        return undefined;
    }
    if (!wantDelete &&
            curMouseButton === 1 &&
            oldElement instanceof ZxNode &&
            nearestNode instanceof ZxNode &&
            displayed.graph.has(oldElement)) {
        let result = maybeDragNodeEdit(displayed.graph, oldElement, nearestNode);
        if (result !== undefined) {
            return result;
        }
    }

    if (curMouseButton !== 0 && curMouseButton !== undefined && !element.isEqualTo(oldElement)) {
        return undefined;
    }

    if (wantDelete) {
        return maybeDeleteElementEdit(displayed, element);
    }

    if (element instanceof ZxNode) {
        return maybeExtendToNodeEdit(displayed, element);
    }

    if (element instanceof ZxEdge) {
        if (displayed.graph.has(element)) {
            return changeEdgeKindEdit(element);
        }

        return maybeExtendAlongEdgeEdit(displayed, element) || maybeIntroduceEdgeEdit(displayed, element);
    }
}

/**
 * @returns {undefined|!boolean}
 */
function curWantDeleteEdit() {
    if (curMouseButton === undefined || curMouseButton === 0) {
        return undefined;
    }
    return curMouseButton === 2 || curCtrlKey;
}
canvasDiv.addEventListener('mousedown', ev => {
    if (ev.which !== 1 && ev.which !== 2) {
        return;
    }
    curCtrlKey = ev.ctrlKey;
    curAltKey = ev.altKey;
    curShiftKey = ev.shiftKey;
    curMouseButton = ev.which;
    ev.preventDefault();
    [mouseDownX, mouseDownY] = eventPosRelativeTo(ev, canvasDiv);
    draw();
});

canvasDiv.addEventListener('mouseup', ev => {
    let displayed = currentlyDisplayedZxGraph;
    if (ev.which !== 1 && ev.which !== 2) {
        return;
    }
    ev.preventDefault();
    let [x, y] = eventPosRelativeTo(ev, canvasDiv);
    curCtrlKey = ev.ctrlKey;
    curAltKey = ev.altKey;
    curShiftKey = ev.shiftKey;

    if (menuNode === undefined) {
        let startNode = displayed.xyToGraphElement(mouseDownX, mouseDownY);
        let endNode = displayed.xyToGraphElement(x, y);
        if (startNode instanceof ZxNode && startNode.isEqualTo(endNode) && ev.which === 1) {
            //noinspection JSUnusedAssignment
            menuNode = startNode;
            draw();
            return;
        }
    }

    let edit = pickEdit(displayed, curWantDeleteEdit(), x, y);
    if (edit !== undefined) {
        let g = displayed.graph.copy();
        edit.action(g);
        revision.commit(g.serialize());
    }
    menuNode = undefined;
    curMouseButton = undefined;
    mouseDownX = undefined;
    mouseDownY = undefined;
    draw();
});

canvasDiv.addEventListener('mousemove', ev => {
    [mouseX, mouseY] = eventPosRelativeTo(ev, canvasDiv);
    curCtrlKey = ev.ctrlKey;
    curAltKey = ev.altKey;
    curShiftKey = ev.shiftKey;
    curMouseButton = ev.which;
    draw();
});

canvasDiv.addEventListener('mouseleave', ev => {
    curCtrlKey = ev.ctrlKey;
    curAltKey = ev.altKey;
    curShiftKey = ev.shiftKey;
    mouseX = undefined;
    mouseY = undefined;
    draw();
});

/**
 * @param {!string|!int} keyOrCode
 * @param {!function(!KeyboardEvent)} func
 */
function addKeyListener(keyOrCode, func) {
    if (!Number.isInteger(keyOrCode)) {
        keyOrCode = keyOrCode.charCodeAt(0);
    }

    if (!keyListeners.has(keyOrCode)) {
        keyListeners.set(keyOrCode, []);
    }
    keyListeners.get(keyOrCode).push(func);
}

addKeyListener(27, () => {
    menuNode = undefined;
});

document.addEventListener('keydown', ev => {
    let displayed = currentlyDisplayedZxGraph;
    curCtrlKey = ev.ctrlKey;
    curAltKey = ev.altKey;
    curShiftKey = ev.shiftKey;

    if (!curAltKey && !curCtrlKey) {
        let entry = makeNodeRingMenu().entryForKey(ev.keyCode, curShiftKey);
        let targetNode = menuNode || displayed.xyToGraphElement(mouseX, mouseY);
        if (entry !== undefined && targetNode instanceof ZxNode) {
            let copy = displayed.graph.copy();
            copy.nodes.set(targetNode, entry.id);
            revision.commit(copy.serialize());
            menuNode = undefined;
            draw();
        }
    }

    let handlers = keyListeners.get(ev.keyCode);
    if (handlers !== undefined) {
        ev.preventDefault();
        for (let handler of handlers) {
            handler(ev);
        }
    }
    draw();
});

canvas.addEventListener('keydown', ev => {
    ev.preventDefault();
});

canvas.addEventListener('keyup', ev => {
    ev.preventDefault();
});

document.addEventListener('keyup', ev => {
    curCtrlKey = ev.ctrlKey;
    curAltKey = ev.altKey;
    curShiftKey = ev.shiftKey;
    draw();
});

revision.latestActiveCommit().subscribe(text => {
    let graph = ZxGraph.deserialize(text);
    currentlyDisplayedZxGraph.graph = graph;
    currentlyDisplayedZxGraph.startCenteringInterpolation();

    //noinspection EmptyCatchBlockJS,UnusedCatchParameterJS
    try {
        draw();
    } catch (_) {
        // Ensure subscription starts. Will be rethrown on next draw anyways.
    }
});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/MathPainter.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {Painter} = _gen_package_get("src/Painter.js");
const {Rect} = _gen_package_get("src/base/Rect.js");
const {Matrix} = _gen_package_get("src/base/Matrix.js");
const {Config} = _gen_package_get("src/Config.js");

class MathPainter {
    /**
     * @param {!Tracer} trace
     * @param {!number} real
     * @param {!number} imag
     * @param {!number} x
     * @param {!number} y
     * @param {!number} d
     * @private
     */
    static _traceAmplitudeProbabilitySquare(trace, real, imag, x, y, d) {
        let p = real*real + imag*imag;
        if (p > 0.001) {
            trace.polygon([
                x, y + d * (1 - p),
                x + d, y + d * (1 - p),
                x + d, y + d,
                x, y + d]);
        }
    }

    /**
     * @param {!Tracer} trace
     * @param {!number} real
     * @param {!number} imag
     * @param {!number} x
     * @param {!number} y
     * @param {!number} d
     * @private
     */
    static _traceAmplitudeProbabilityCircle(trace, real, imag, x, y, d) {
        let mag = Math.sqrt(real*real + imag*imag);
        if (d*mag > 0.5) {
            trace.circle(x+d/2, y+d/2, mag*d/2);
        }
    }

    /**
     * @param {!Tracer} trace
     * @param {!number} real
     * @param {!number} imag
     * @param {!number} x
     * @param {!number} y
     * @param {!number} d
     * @private
     */
    static _traceAmplitudeLogarithmCircle(trace, real, imag, x, y, d) {
        let g = 1 + Math.log(real*real + imag*imag)/15;
        if (g > 0) {
            trace.circle(x+d/2, y+d/2, g*d/2);
        }
    }

    /**
     * @param {!Tracer} trace
     * @param {!number} real
     * @param {!number} imag
     * @param {!number} x
     * @param {!number} y
     * @param {!number} d
     * @private
     */
    static _traceAmplitudePhaseDirection(trace, real, imag, x, y, d) {
        let mag = Math.sqrt(real*real + imag*imag);
        let g = 1 + Math.log(mag)/10;
        let r = Math.max(1, g/mag)*Math.max(d/2, 5);
        if (r < 0.1) {
            return;
        }
        let cx = x + d/2;
        let cy = y + d/2;
        trace.line(cx, cy, cx + real*r, cy - imag*r);
    }

    /**
     * Draws a visual representation of a complex matrix.
     * @param {!Painter} painter
     * @param {!Matrix} matrix The matrix to draw.
     * @param {!Rect} drawArea The rectangle to draw the matrix within.
     * @param {undefined|!string} amplitudeCircleFillColor
     * @param {!string} amplitudeCircleStrokeColor
     * @param {undefined|!string} amplitudeProbabilityFillColor
     * @param {undefined|!string=} backColor
     * @param {undefined|!string=} amplitudePhaseStrokeColor
     * @param {undefined|!string=} logCircleStrokeColor
     */
    static paintMatrix(painter,
                       matrix,
                       drawArea,
                       amplitudeCircleFillColor=Config.SUPERPOSITION_MID_COLOR,
                       amplitudeCircleStrokeColor='black',
                       amplitudeProbabilityFillColor=Config.SUPERPOSITION_FORE_COLOR,
                       backColor = Config.SUPERPOSITION_BACK_COLOR,
                       amplitudePhaseStrokeColor = undefined,
                       logCircleStrokeColor = '#AAA') {
        let numCols = matrix.width();
        let numRows = matrix.height();
        let buf = matrix.rawBuffer();
        let diam = Math.min(drawArea.w / numCols, drawArea.h / numRows);
        drawArea = drawArea.withW(diam * numCols).withH(diam*numRows);
        let {x, y} = drawArea;
        let hasNaN = matrix.hasNaN();
        amplitudePhaseStrokeColor = amplitudePhaseStrokeColor || amplitudeCircleStrokeColor;

        painter.fillRect(drawArea, backColor);

        let traceCellsWith = cellTraceFunc => painter.trace(trace => {
            for (let row = 0; row < numRows; row++) {
                for (let col = 0; col < numCols; col++) {
                    let k = (row * numCols + col) * 2;
                    cellTraceFunc(
                        trace,
                        buf[k],
                        buf[k + 1],
                        x + diam * col,
                        y + diam * row,
                        diam);
                }
            }
        });

        if (!hasNaN) {
            // Squared magnitude levels.
            if (amplitudeProbabilityFillColor !== undefined) {
                traceCellsWith(MathPainter._traceAmplitudeProbabilitySquare).
                thenFill(amplitudeProbabilityFillColor).
                thenStroke('lightgray', 0.5);
            }

            // Circles.
            if (amplitudeCircleFillColor !== undefined) {
                traceCellsWith(MathPainter._traceAmplitudeProbabilityCircle).
                thenFill(amplitudeCircleFillColor).
                thenStroke(amplitudeCircleStrokeColor, 0.5);

                traceCellsWith(MathPainter._traceAmplitudeLogarithmCircle).
                thenStroke(logCircleStrokeColor, 0.5);
            }
        }

        // Dividers.
        painter.trace(trace => trace.grid(x, y, drawArea.w, drawArea.h, numCols, numRows)).
        thenStroke('lightgray');

        if (!hasNaN) {
            // Phase lines.
            if (logCircleStrokeColor !== undefined) {
                traceCellsWith(MathPainter._traceAmplitudePhaseDirection).
                thenStroke(amplitudePhaseStrokeColor);
            }
        }

        // Error text.
        if (hasNaN) {
            painter.print(
                'NaN',
                drawArea.x + drawArea.w/2,
                drawArea.y + drawArea.h/2,
                'center',
                'middle',
                'red',
                '16px sans-serif',
                drawArea.w,
                drawArea.h);
        }
    }
}

_gen_package_export("src/MathPainter.js", {MathPainter});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/All.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {ZxNodeKind} = _gen_package_get("src/nodes/ZxNodeKind.js");
const {INPUT_NODE, OUTPUT_NODE} = _gen_package_get("src/nodes/InputOutputNodes.js");
const {CROSSING_NODE} = _gen_package_get("src/nodes/CrossingNode.js");
const {HADAMARD_NODE} = _gen_package_get("src/nodes/HadamardNode.js");
const {SPIDER_NODES} = _gen_package_get("src/nodes/SpiderNodes.js");
const {POST_SELECTION_NODES} = _gen_package_get("src/nodes/PostSelectionNodes.js");


/**
 * @yields {!ZxNodeKind}
 */
function* _iterNodeKinds() {
    yield* SPIDER_NODES;
    yield* POST_SELECTION_NODES;
    yield CROSSING_NODE;
    yield HADAMARD_NODE;
    yield INPUT_NODE;
    yield OUTPUT_NODE;
}

let map = /** @type {!GeneralMap.<!string, !ZxNodeKind>} */ new GeneralMap();
for (let e of _iterNodeKinds()) {
    map.set(e.id, e);
}
const NODES = {
    map: map,
    all: [...map.values()],
    cross: map.get('+'),
    in: map.get('in'),
    out: map.get('out'),
    x: map.get('O'),
    z: map.get('@'),
    white: map.get('O'),
    black: map.get('@'),
    h: map.get('h'),
};

_gen_package_export("src/nodes/All.js", {NODES});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/Base.js", function() {

const {Matrix} = _gen_package_get("src/base/Matrix.js");;
const {Complex} = _gen_package_get("src/base/Complex.js");;
const {popcnt} = _gen_package_get("src/base/Util.js");;


/**
 * @param {!int} inDim
 * @param {!int} outDim
 * @param {!number=0} phase
 * @returns {!Matrix}
 */
function zBasisEqualityMatrix(inDim, outDim, phase=0) {
    let result = Matrix.zero(1 << inDim, 1 << outDim);
    let buf = result.rawBuffer();
    buf[0] = 1;
    let c = Complex.polar(1, phase);
    buf[buf.length - 2] += c.real;
    buf[buf.length - 1] += c.imag;
    return result;
}

/**
 * @param {!int} inDim
 * @param {!int} outDim
 * @param {!number=0} phase
 * @returns {!Matrix}
 */
function xBasisEqualityMatrix(inDim, outDim, phase=0) {
    if (inDim + outDim === 0) {
        return Matrix.solo(Complex.polar(1, phase).plus(1));
    }

    let m = Math.sqrt(4 / (1 << (inDim + outDim)));
    let g = Complex.polar(m, phase / 2);
    let even = g.times(Math.cos(phase / 2));
    let odd = g.times(-Math.sin(phase / 2)).times(Complex.I);
    let result = Matrix.zero(1 << inDim, 1 << outDim);
    let buf = result.rawBuffer();
    for (let k = 0; k < buf.length; k += 2) {
        if (popcnt(k) % 2 === 0) {
            buf[k] = even.real;
            buf[k + 1] = even.imag;
        } else {
            buf[k] = odd.real;
            buf[k + 1] = odd.imag;
        }
    }
    return result;
}

/**
 * @param {!string} stroke
 * @param {!string} fill
 * @param {!number} lineWidth
 * @returns {!function(ctx: !CanvasRenderingContext2D)},
 * @private
 */
function nodeDrawer(stroke, fill, lineWidth) {
    return ctx => {
        ctx.beginPath();
        ctx.arc(0, 0, 8, 0, 2 * Math.PI);
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = stroke;
        ctx.fillStyle = fill;
        ctx.fill();
        ctx.stroke();
    };
}

/**
 * @param {!string} color
 * @returns {!function(ctx: !CanvasRenderingContext2D)},
 * @private
 */
function piDrawer(color) {
    return ctx => {
        ctx.fillStyle = color;
        ctx.font = '12px monospace';
        ctx.fillText('π', -3, 3);
    }
}

/**
 * @param {!string} color
 * @returns {!function(ctx: !CanvasRenderingContext2D)},
 * @private
 */
function halfPiDrawer(color) {
    return ctx => {
        ctx.fillStyle = color;
        ctx.font = '10px monospace';
        ctx.fillText('π', -3, -1);
        ctx.fillText('2', -3, 7);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-4, 0);
        ctx.lineTo(4, 0);
        ctx.lineWidth = 1;
        ctx.strokeStyle = color;
        ctx.stroke();
    }
}

/**
 * @param {!string} color
 * @returns {!function(ctx: !CanvasRenderingContext2D)},
 * @private
 */
function negHalfPiDrawer(color) {
    return ctx => {
        ctx.fillStyle = color;
        ctx.font = '10px monospace';
        ctx.fillText('-π', -5, -1);
        ctx.fillText('2', -3, 7);
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-6, 0);
        ctx.lineTo(6, 0);
        ctx.strokeStyle = color;
        ctx.stroke();
    }
}

/**
 * @param {!function(ctx: !CanvasRenderingContext2D)} drawers
 * @returns {!function(ctx: !CanvasRenderingContext2D)},
 * @private
 */
function concatDrawers(...drawers) {
    return ctx => {
        for (let drawer of drawers) {
            drawer(ctx);
        }
    }
}

_gen_package_export("src/nodes/Base.js", {
    zBasisEqualityMatrix,
    xBasisEqualityMatrix,
    nodeDrawer,
    negHalfPiDrawer,
    halfPiDrawer,
    piDrawer,
    concatDrawers,
});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/CrossingNode.js", function() {

const {PauliProduct} = _gen_package_get("src/sim/PauliProduct.js");;
const {ZxNodeKind} = _gen_package_get("src/nodes/ZxNodeKind.js");

const CROSSING_NODE = new ZxNodeKind({
    id: '+',
    description: 'Crosser node',
    diagramReps: ['+', '-', '|'],
    contentDrawer: ctx => {
        // Empty space.
    },
    hotkeys: [],
    hotkeyShiftMask: undefined,
    allowedDegrees: [2, 4],
    fixedPoints: deg => {
        if (deg === 4) {
            return [
                // HACK: This implicitly depends on the sorting order of edges being [left, top, down, right].
                PauliProduct.fromString('X..X'),
                PauliProduct.fromString('Z..Z'),
                PauliProduct.fromString('.XX.'),
                PauliProduct.fromString('.ZZ.'),
            ];
        }

        if (deg === 2) {
            return [PauliProduct.fromString('XX'), PauliProduct.fromString('ZZ')];
        }

        throw new Error('Invalid degree.');
    },
    tensor: () => {
        throw new Error('Crossing node tensor must be handled specially.');
    },
    nodeMeasurer: () => {
        throw new Error('Crossing node tensor must be handled specially.');
    },
});

_gen_package_export("src/nodes/CrossingNode.js", {CROSSING_NODE});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/HadamardNode.js", function() {

const {QubitAxis, PauliProduct} = _gen_package_get("src/sim/PauliProduct.js");;
const {Matrix} = _gen_package_get("src/base/Matrix.js");;
const {MultiCnot} = _gen_package_get("src/sim/QuantumProgram.js");;
const {ZxNodeKind, TransformedMeasurement, IDENTITY_EDGE_ACTION} = _gen_package_get("src/nodes/ZxNodeKind.js");

const HADAMARD_NODE = new ZxNodeKind({
    id: 'h',
    description: 'Hadamard\n\nFixed measures:\nX0·Z1\nZ0·X1\n\nAction:\nH',
    diagramReps: ['H', 'h'],
    contentDrawer: ctx => {
        ctx.fillStyle = 'yellow';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 1;
        ctx.fillRect(-5, -5, 10, 10);
        ctx.strokeRect(-5, -5, 10, 10);
    },
    hotkeys: ['h', 'H'],
    hotkeyShiftMask: undefined,
    allowedDegrees: [2],
    fixedPoints: deg => {
        if (deg !== 2) {
            throw new Error('Invalid degree.');
        }
        return [PauliProduct.fromString('XZ'), PauliProduct.fromString('ZX')];
    },
    edgeAction: {
        quirkGate: 'H',
        qasmGates: ['h'],
        sim: (sim, qubit) => {
            sim.hadamard(qubit);
        },
        matrix: Matrix.square(1, 1, 1, -1).times(Math.sqrt(0.5)),
    },
    nodeRootEdgeAction: IDENTITY_EDGE_ACTION,
    tensor: dim => {
        if (dim !== 2) {
            throw new Error(`Bad Hadamard dimension: ${dim}`);
        }
        return Matrix.square(1, 1, 1, -1).times(Math.sqrt(0.5));
    },
    nodeMeasurer: (outProgram, totalQubits, qubitIds) => {
        let [a, b] = qubitIds;
        outProgram.statements.push(new MultiCnot(a, [b], true, true));
        return [
            new TransformedMeasurement(
                PauliProduct.fromSparseByType(totalQubits, {X: a, Z: b}),
                new QubitAxis(a, false),
                new QubitAxis(b, false)),
            new TransformedMeasurement(
                PauliProduct.fromSparseByType(totalQubits, {X: b, Z: a}),
                new QubitAxis(b, false),
                new QubitAxis(a, false))
        ];
    },
});

_gen_package_export("src/nodes/HadamardNode.js", {HADAMARD_NODE});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/InputOutputNodes.js", function() {

const {ZxNodeKind} = _gen_package_get("src/nodes/ZxNodeKind.js");;
const {
    nodeDrawer,
    zBasisEqualityMatrix,
} = _gen_package_get("src/nodes/Base.js");;


let zOnlyFor2 = dim => {
    if (dim !== 1) {
        throw new Error(`Bad input dimension: ${dim}`);
    }
    return zBasisEqualityMatrix(0, 2);
};

let drawerForText = (text, flipSign) => (ctx, args) => {
    let edges = args.graph.activeUnitEdgesOf(args.pos);
    let opp = edges.length > 0 ? edges[0].opposite(args.pos) : args.pos;
    let spanSign;
    let inverseSpanSign ;
    if (edges.length === 0) {
        ctx.translate(0, 6);
        spanSign = +1;
        inverseSpanSign = -1;
    } else if (opp.y !== args.pos.y) {
        ctx.rotate(Math.PI/2 * flipSign * (opp.y > args.pos.y ? 1 : -1));
        spanSign = Math.abs(opp.y - args.pos.y) * flipSign;
        inverseSpanSign = 0;
    } else {
        spanSign = opp.x - args.pos.x;
        inverseSpanSign = 0;
    }

    ctx.fillStyle = 'black';
    ctx.font = 'bold 16px monospace';
    let r = ctx.measureText(text).width/2;
    ctx.fillText(text, -r, -4);

    ctx.beginPath();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.moveTo(-r * inverseSpanSign, 0);
    ctx.lineTo(-r * spanSign, 0);
    ctx.stroke();
};

const INPUT_NODE = new ZxNodeKind({
    id: 'in',
    description: 'Input node',
    diagramReps: ['!'],
    contentDrawer: drawerForText('in', +1),
    hotkeys: ['i', 'I'],
    hotkeyShiftMask: undefined,
    allowedDegrees: [1],
    tensor: zOnlyFor2,
});

const OUTPUT_NODE = new ZxNodeKind({
    id: 'out',
    description: 'Output node',
    diagramReps: ['?'],
    contentDrawer: drawerForText('out', -1),
    hotkeys: ['u', 'U'],
    hotkeyShiftMask: undefined,
    allowedDegrees: [1],
    tensor: zOnlyFor2,
});

_gen_package_export("src/nodes/InputOutputNodes.js", {INPUT_NODE, OUTPUT_NODE});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/PostSelectionNodes.js", function() {

const {ZxNodeKind} = _gen_package_get("src/nodes/ZxNodeKind.js");
const {
    nodeDrawer,
    xBasisEqualityMatrix,
    zBasisEqualityMatrix,
    concatDrawers,
    negHalfPiDrawer,
    halfPiDrawer,
    piDrawer,
} = _gen_package_get("src/nodes/Base.js");;

/**
 * @param {!boolean} axis
 * @yields {!ZxNodeKind}
 */
function* generatePostSelectionNodes(axis) {
    let nodeDraw = nodeDrawer('red', axis ? 'black' : 'white', 3);
    let textColor = axis ? 'white' : 'black';
    let axisPostChar = axis ? '+' : '0';
    let axisAntiPostChar = axis ? '-' : '1';

    let spiderTensor = phase => {
        let method = axis ? zBasisEqualityMatrix : xBasisEqualityMatrix;
        return dim => method(0, dim, phase);
    };

    yield new ZxNodeKind({
        id: `${axis ? '@' : 'O'}!`,
        description: `postselect\n|${axisPostChar}⟩`,
        diagramReps: axis ? ['@!'] : ['O!', 'o!', '0!'],
        contentDrawer: nodeDraw,
        hotkeys: axis ? ['@', '2'] : ['O', ')', '0'],
        hotkeyShiftMask: true,
        allowedDegrees: [1],
        tensor: spiderTensor(0),
        postSelectStabilizer: axis ? '+X' : '+Z',
    });

    yield new ZxNodeKind({
        id: `${axis ? 'z' : 'x'}!`,
        description: `postselect\n|${axisAntiPostChar}⟩`,
        diagramReps: axis ? ['Z!', 'z!'] : ['X!', 'x!'],
        contentDrawer: concatDrawers(nodeDraw, piDrawer(textColor)),
        hotkeys: axis ? ['Z'] : ['X'],
        hotkeyShiftMask: true,
        allowedDegrees: [1],
        tensor: spiderTensor(Math.PI),
        postSelectStabilizer: axis ? '-X' : '-Z',
    });

    yield new ZxNodeKind({
        id: `${axis ? 's' : 'f'}!`,
        description: `postselect\n|${axis ? 'i' : '-i'}⟩`,
        diagramReps: axis ? ['S!', 's!'] : ['F!', 'f!'],
        contentDrawer: concatDrawers(nodeDraw, halfPiDrawer(textColor)),
        hotkeys: axis ? ['S'] : ['V'],
        hotkeyShiftMask: true,
        allowedDegrees: [1],
        tensor: spiderTensor(Math.PI / 2),
        postSelectStabilizer: axis ? '-Y' : '+Y',
    });

    yield new ZxNodeKind({
        id: `${axis ? 'a' : 'w'}!`,
        description: `postselect\n|${axis ? '-i' : '+i'}⟩`,
        diagramReps: axis ? ['A!', 'a!'] : ['W!', 'w!'],
        contentDrawer: concatDrawers(nodeDraw, negHalfPiDrawer(textColor)),
        hotkeys: axis ? ['A'] : ['W'],
        hotkeyShiftMask: true,
        allowedDegrees: [1],
        tensor: spiderTensor(-Math.PI / 2),
        postSelectStabilizer: axis ? '+Y' : '-Y',
    });
}

const POST_SELECTION_NODES = [...generatePostSelectionNodes(false), ...generatePostSelectionNodes(true)];

_gen_package_export("src/nodes/PostSelectionNodes.js", {POST_SELECTION_NODES});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/SpiderNodes.js", function() {

const {QubitAxis, PauliProduct} = _gen_package_get("src/sim/PauliProduct.js");;
const {Matrix} = _gen_package_get("src/base/Matrix.js");;
const {Complex} = _gen_package_get("src/base/Complex.js");;
const {MultiCnot} = _gen_package_get("src/sim/QuantumProgram.js");;
const {ZxNodeKind, TransformedMeasurement} = _gen_package_get("src/nodes/ZxNodeKind.js");
const {
    nodeDrawer,
    xBasisEqualityMatrix,
    zBasisEqualityMatrix,
    concatDrawers,
    negHalfPiDrawer,
    halfPiDrawer,
    piDrawer,
} = _gen_package_get("src/nodes/Base.js");;

/**
 * @param {!boolean} axis
 * @returns {!function(
 *     outProgram: !QuantumProgram,
 *     totalQubits: !int,
 *     qubitIds: !Array.<!int>,
 * ): !Array.<!TransformedMeasurement>}
 * @private
 */
function _spiderMeasurer(axis) {
    return (outProgram, totalQubits, qubitIds) => {
        if (qubitIds.length === 0) {
            return [];
        }
        let [head, ...tail] = qubitIds;
        outProgram.statements.push(new MultiCnot(head, tail, axis, !axis));
        let measurements = [];
        measurements.push(new TransformedMeasurement(
            PauliProduct.fromXzParity(totalQubits, !axis, qubitIds),
            new QubitAxis(head, !axis),
            new QubitAxis(head, axis)));
        for (let t of tail) {
            measurements.push(new TransformedMeasurement(
                PauliProduct.fromXzParity(totalQubits, axis, [head, t]),
                new QubitAxis(t, axis),
                new QubitAxis(t, !axis)));
        }
        return measurements;
    };
}

/**
 * @param {!boolean} axis
 * @param {!int} count
 * @returns {!function(sim: !ChpSimulator, qubit: !int)}
 */
let simAxisPhase = (axis, count) => (sim, qubit) => {
    if (!axis) {
        sim.hadamard(qubit);
    }
    for (let i = 0; i < count; i++) {
        sim.phase(qubit);
    }
    if (!axis) {
        sim.hadamard(qubit);
    }
};

/**
 * @param {!boolean} axis
 * @param {!boolean} rootY
 * @returns {!function(deg: !int): !Array.<!PauliProduct>}
 */
let spiderFixedPointsFunc = (axis, rootY) => deg => {
    if (deg === 0) {
        return [];
    }

    let globalParity = new PauliProduct(0, new Uint8Array(deg));
    for (let i = 0; i < deg; i++) {
        globalParity.paulis[i] = axis ? 1 : 2;
    }
    if (rootY) {
        globalParity.paulis[0] = 3;
    }

    let result = [];
    result.push(globalParity);
    for (let i = 1; i < deg; i++) {
        result.push(PauliProduct.fromXzParity(deg, axis, [0, i]));
    }
    return result;
};

/**
 * @param {!boolean} axis
 * @param {!number} phase
 * @returns {!function(*=): *}
 */
function spiderTensorFunc(axis, phase) {
    let tensorFunc = axis ? zBasisEqualityMatrix : xBasisEqualityMatrix;
    return dim => tensorFunc(0, dim, phase);
}

/**
 * @param {!boolean} axis
 * @yields {!ZxNodeKind}
 */
function* generateSpiderNodes(axis) {
    let spiderNodeDrawer = nodeDrawer('black', axis ? 'black' : 'white', 1);
    let textColor = axis ? 'white' : 'black';
    let spider = axis ? 'Z' : 'X';
    let oppSpider = axis ? 'X' : 'Z';
    let desc = (modifier, sign, gate) => {
        return [
            `${spider} spider`,
            modifier === '' ? [] : [`(${modifier})`],
            '',
            'Fixed measures:',
            `∀k: ${spider}0·${spider}k`,
            `${sign}Πk(${oppSpider}k)`,
            '',
            'Edge action:',
            gate
        ].join('\n');
    };

    let nodeMeasurer = _spiderMeasurer(axis);
    let allowedDegrees = [0, 1, 2, 3, 4];

    yield new ZxNodeKind({
        id: `${axis ? '@' : 'O'}`,
        description: desc('', '', 'Identity'),
        diagramReps: axis ? ['@'] : ['O', 'o', '0'],
        contentDrawer: spiderNodeDrawer,
        hotkeys: axis ? ['2'] : ['o', '0'],
        hotkeyShiftMask: false,
        fixedPoints: spiderFixedPointsFunc(axis, false),
        tensor: spiderTensorFunc(axis, 0),
        allowedDegrees,
        nodeMeasurer,
    });

    yield new ZxNodeKind({
        id: `${axis ? 'z' : 'x'}`,
        description: desc('Flipped', '-', spider),
        diagramReps: (axis ? ['Z', 'z'] : ['X', 'x']),
        contentDrawer: concatDrawers(spiderNodeDrawer, piDrawer(textColor)),
        hotkeys: axis ? ['z'] : ['x'],
        hotkeyShiftMask: false,
        fixedPoints: spiderFixedPointsFunc(axis, false),
        tensor: spiderTensorFunc(axis, Math.PI),
        edgeAction: {
            quirkGate: axis ? 'Z' : 'X',
            qasmGates: axis ? ['z'] : ['x'],
            sim: simAxisPhase(axis, 2),
            matrix: axis ? Matrix.square(1, 0, 0, -1) : Matrix.square(0, 1, 1, 0),
        },
        allowedDegrees,
        nodeMeasurer,
    });

    yield new ZxNodeKind({
        id: `${axis ? 's' : 'f'}`,
        description: desc('Phased', `-i${spider}0·`, axis ? 'S' : 'H·S·H'),
        diagramReps: axis ? ['S', 's'] : ['F', 'f'],
        contentDrawer: concatDrawers(spiderNodeDrawer, halfPiDrawer(textColor)),
        hotkeys: axis ? ['s'] : ['v'],
        hotkeyShiftMask: false,
        fixedPoints: spiderFixedPointsFunc(axis, true),
        tensor: spiderTensorFunc(axis, Math.PI / 2),
        edgeAction: {
            quirkGate: axis ? 'Z^½' : 'X^½',
            qasmGates: axis ? ['s'] : ['h', 's', 'h'],
            sim: simAxisPhase(axis, 1),
            matrix: axis ?
                Matrix.square(1, 0, 0, Complex.I) :
                Matrix.square(1, Complex.I.neg(), Complex.I.neg(), 1).times(new Complex(0.5, 0.5)),
        },
        allowedDegrees,
        nodeMeasurer,
    });

    yield new ZxNodeKind({
        id: `${axis ? 'a' : 'w'}`,
        description: desc('Backphased', `i${spider}0·`, axis ? 'S†' : 'H·S†·H'),
        diagramReps: axis ? ['A', 'a'] : ['W', 'w'],
        contentDrawer: concatDrawers(spiderNodeDrawer, negHalfPiDrawer(textColor)),
        hotkeys: axis ? ['a'] : ['w'],
        hotkeyShiftMask: false,
        fixedPoints: spiderFixedPointsFunc(axis, true),
        tensor: spiderTensorFunc(axis, -Math.PI / 2),
        edgeAction: {
            quirkGate: axis ? 'Z^-½' : 'X^-½',
            qasmGates: axis ? ['z', 's'] : ['x', 'h', 's', 'h'],
            sim: simAxisPhase(axis, 3),
            matrix: axis ?
                Matrix.square(1, 0, 0, Complex.I.neg()) :
                Matrix.square(1, Complex.I, Complex.I, 1).times(new Complex(0.5, -0.5)),
        },
        allowedDegrees,
        nodeMeasurer,
    });
}

const SPIDER_NODES = [...generateSpiderNodes(false), ...generateSpiderNodes(true)];

_gen_package_export("src/nodes/SpiderNodes.js", {SPIDER_NODES});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/nodes/ZxNodeKind.js", function() {

class ZxNodeKind {
    /**
     * @param {!{
     *     id: !string,
     *     description: !string,
     *     contentDrawer: !function(ctx: !CanvasRenderingContext2D, args: !ZxNodeDrawArgs),
     *     diagramReps: (undefined|!Array.<!string>),
     *     hotkeys: !Array.<!string>,
     *     hotkeyShiftMask: (undefined|!boolean),
     *     mouseHotkey?: (undefined|!string),
     *     allowedDegrees: !Array.<!int>,
     *     fixedPoints?: undefined|!function(degree: !int): !Array.<!PauliProduct>,
     *     tensor: !function(dim: !int): !Matrix,
     *     edgeAction?: !{
     *         quirkGate: null|!string,
     *         qasmGates: null|!Array.<!string>,
     *         sim: !function(sim: !ChpSimulator, qubit: !int),
     *         matrix: null|!int|!Matrix,
     *     },
     *     nodeRootEdgeAction?: !{
     *         quirkGate: null|!string,
     *         qasmGates: null|!Array.<!string>,
     *         sim: !function(sim: !ChpSimulator, qubit: !int),
     *         matrix: null|!int|!Matrix,
     *     },
     *     nodeMeasurer?: undefined|!function(
     *         outProgram: !QuantumProgram,
     *         totalQubits: !int,
     *         qubitIds: !Array.<!int>,
     *     ): !Array.<!TransformedMeasurement>,
     *     postSelectStabilizer?: undefined|!string
     * }} attributes
     */
    constructor(attributes) {
        this.id = attributes.id;
        this.description = attributes.description;
        this.contentDrawer = attributes.contentDrawer;
        this.diagramReps = attributes.diagramReps || [this.id];
        this.hotkeys = attributes.hotkeys;
        this.hotkeyShiftMask = attributes.hotkeyShiftMask;
        this.mouseHotkey = attributes.mouseHotkey;
        this.allowedDegrees = attributes.allowedDegrees;
        this.fixedPoints = attributes.fixedPoints || NO_FIXED_POINTS;
        this.tensor = attributes.tensor;
        this.edgeAction = attributes.edgeAction || (
            attributes.allowedDegrees.indexOf(2) !== -1 ? IDENTITY_EDGE_ACTION : INVALID_EDGE_ACTION);
        this.nodeRootEdgeAction = attributes.nodeRootEdgeAction || this.edgeAction;
        this.nodeMeasurer = attributes.nodeMeasurer || IDENTITY_NODE_MEASURER;
        this.postSelectStabilizer = attributes.postSelectStabilizer || undefined;
    }
}

const IDENTITY_NODE_MEASURER = (outProgram, totalQubits, qubitIds) => [];

const NO_FIXED_POINTS = degree => [];

const IDENTITY_EDGE_ACTION = {
    quirkGate: '…',
    qasmGates: [],
    sim: (sim, qubit) => {},
    matrix: 1,
};

const INVALID_EDGE_ACTION = {
    quirkGate: null,
    qasmGates: null,
    sim: () => { throw new Error("Node doesn't permit degree 2 and so has no valid edge action."); },
    matrix: null,
};

class ZxNodeDrawArgs {
    /**
     * @param {!ZxGraph} graph
     * @param {!ZxNode} pos
     */
    constructor(graph, pos) {
        this.graph = graph;
        this.pos = pos;
    }
}

class TransformedMeasurement {
    /**
     * @param {!PauliProduct} originalStabilizer
     * @param {!QubitAxis} postselectionControlAxis
     * @param {!QubitAxis} measurementAxis
     */
    constructor(originalStabilizer, measurementAxis, postselectionControlAxis) {
        this.originalStabilizer = originalStabilizer;
        this.measurementAxis = measurementAxis;
        this.postselectionControlAxis = postselectionControlAxis;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof TransformedMeasurement &&
            this.measurementAxis.isEqualTo(other.measurementAxis) &&
            this.originalStabilizer.isEqualTo(other.originalStabilizer) &&
            this.postselectionControlAxis.isEqualTo(other.postselectionControlAxis));
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `originalStabilizer: ${this.originalStabilizer}
postselectionControlAxis: ${this.postselectionControlAxis}
measurementAxis: ${this.measurementAxis}`;
    }
}

_gen_package_export("src/nodes/ZxNodeKind.js", {TransformedMeasurement, ZxNodeKind, IDENTITY_EDGE_ACTION, ZxNodeDrawArgs});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/Painter.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {Config} = _gen_package_get("src/Config.js");
const {Point} = _gen_package_get("src/base/Point.js");
const {Rect} = _gen_package_get("src/base/Rect.js");
const {seq, Seq} = _gen_package_get("src/base/Seq.js");
const {Util} = _gen_package_get("src/base/Util.js");

class Painter {
    /**
     * @param {!HTMLCanvasElement|!CanvasRenderingContext2D} canvasOrCtx
     */
    constructor(canvasOrCtx) {
        /** @type {!HTMLCanvasElement} */
        this.canvas = canvasOrCtx instanceof CanvasRenderingContext2D ? canvasOrCtx.canvas : canvasOrCtx;
        /** @type {!CanvasRenderingContext2D} */
        this.ctx = canvasOrCtx instanceof CanvasRenderingContext2D ? canvasOrCtx : canvasOrCtx.getContext("2d");
        /**
         * @type {!Array.<!function()>}
         * @private
         */
        this._deferredPaintActions = [];
        /**
         * @type {!TraceAction}
         * @private
         */
        this._traceAction = new TraceAction(this.ctx);
        /**
         * @type {!Tracer}
         * @private
         */
        this._tracer = new Tracer(this.ctx);
        /**
         * @type {undefined|!string}
         */
        this.desiredCursorStyle = undefined;
        /**
         * @type {!Array.<!{rect: !Rect, cursor: undefined|!string}>}
         */
        this.touchBlockers = [];

        this._ignoringTouchBlockers = 0;
    }

    startIgnoringIncomingTouchBlockers() {
        this._ignoringTouchBlockers += 1
    }

    stopIgnoringIncomingTouchBlockers() {
        this._ignoringTouchBlockers -= 1
    }

    /**
     * @param {!{rect: !Rect, cursor: undefined|!string}} blocker
     */
    noteTouchBlocker(blocker) {
        if (this._ignoringTouchBlockers === 0) {
            this.touchBlockers.push(blocker);
        }
    }

    /**
     * @param {!string} cursorStyle auto|pointer|move|ns-resize|...
     */
    setDesiredCursor(cursorStyle) {
        this.desiredCursorStyle = cursorStyle;
    }

    /**
     * @param {!function()} tooltipPainter
     */
    defer(tooltipPainter) {
        this._deferredPaintActions.push(tooltipPainter);
    }

    paintDeferred() {
        for (let e of this._deferredPaintActions) {
            e();
        }
        this._deferredPaintActions = [];
    }

    /**
     * @returns {!Rect}
     */
    paintableArea() {
        return new Rect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * @param {!string=} color
     */
    clear(color = Config.DEFAULT_FILL_COLOR) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    }

    /**
     * Draws a line segment between the two points.
     *
     * @param {!Point} p1
     * @param {!Point} p2
     * @param {=string} color The color of the drawn line.
     * @param {=number} thickness The thickness of the drawn line.
     */
    strokeLine(p1, p2, color = Config.DEFAULT_STROKE_COLOR, thickness = 1) {
        this.ctx.beginPath();
        this.ctx.moveTo(p1.x, p1.y);
        this.ctx.lineTo(p2.x, p2.y);
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.stroke();
    }

    /**
     * Draws the outside of a rectangle.
     * @param {!Rect} rect The rectangular perimeter to stroke.
     * @param {!string=} color The stroke color.
     * @param {!number=} thickness The stroke thickness.
     */
    strokeRect(rect, color = "black", thickness = 1) {
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.strokeRect(rect.x, rect.y, rect.w, rect.h);
    }

    /**
     * Draws the inside of a rectangle.
     * @param {!Rect} rect The rectangular area to fill.
     * @param {!string=} color The fill color.
     */
    fillRect(rect, color = Config.DEFAULT_FILL_COLOR) {
        this.ctx.fillStyle = color;
        this.ctx.fillRect(rect.x, rect.y, rect.w, rect.h);
    }

    /**
     * Draws the outside of a circle.
     * @param {!Point} center The center of the circle.
     * @param {!number} radius The distance from the center of the circle to its side.
     * @param {!string=} color The stroke color.
     * @param {!number=} thickness The stroke thickness.
     */
    strokeCircle(center, radius, color = Config.DEFAULT_STROKE_COLOR, thickness = Config.DEFAULT_STROKE_THICKNESS) {
        this.ctx.beginPath();
        this.ctx.strokeStyle = color;
        this.ctx.lineWidth = thickness;
        this.ctx.arc(center.x, center.y, Math.max(radius - 0.5, 0), 0, 2 * Math.PI);
        this.ctx.stroke();
    }

    /**
     * @param {!function(!Tracer) : void} tracerFunc
     * @returns {!TraceAction}
     */
    trace(tracerFunc) {
        this.ctx.beginPath();
        tracerFunc(this._tracer);
        return this._traceAction;
    }

    /**
     * Draws the inside of a circle.
     * @param {!Point} center The center of the circle.
     * @param {!number} radius The distance from the center of the circle to its side.
     * @param {!string=} color The fill color. Defaults to white.
     */
    fillCircle(center, radius, color = Config.DEFAULT_FILL_COLOR) {
        this.ctx.beginPath();
        this.ctx.arc(center.x, center.y, Math.max(radius - 0.5, 0), 0, 2 * Math.PI);
        this.ctx.fillStyle = color;
        this.ctx.fill();
    }

    /**
     * Draws some text in a bounded area.
     * @param {!string} text The text to print.
     * @param {!number} x
     * @param {!number} y
     * @param {!number} boundingWidth The text will be scaled down so it doesn't exceed this width.
     * @param {!number} boundingHeight The text will be scaled down so it doesn't exceed this width.
     * @param {!string} textAlign Horizontal alignment. Options: start, end, left, right, center.
     * @param {!string} textBaseline Vertical alignment. Options: top, hanging, middle, alphabetic, ideographic, bottom.
     * @param {!string} fillStyle Text color.
     * @param {!string} font
     * @param {!function(!number, !number) : void} afterMeasureBeforeDraw
     * @param {!boolean} alsoStroke
     */
    print(text,
          x,
          y,
          textAlign,
          textBaseline,
          fillStyle,
          font,
          boundingWidth,
          boundingHeight,
          afterMeasureBeforeDraw = undefined,
          alsoStroke = false) {

        this.ctx.font = font;
        let naiveWidth = this.ctx.measureText(text).width;
        //noinspection JSSuspiciousNameCombination
        let naiveHeight = this.ctx.measureText("0").width * 2.5;
        let scale = Math.min(Math.min(boundingWidth / naiveWidth, boundingHeight / naiveHeight), 1);

        if (afterMeasureBeforeDraw !== undefined) {
            afterMeasureBeforeDraw(naiveWidth * scale, naiveHeight * scale);
        }
        this.ctx.save();
        this.ctx.textAlign = textAlign;
        this.ctx.textBaseline = textBaseline;
        this.ctx.font = font; // Re-set the font, because the 'afterMeasureBeforeDraw' callback may have changed it.
        this.ctx.fillStyle = fillStyle;
        this.ctx.translate(x, y);
        this.ctx.scale(scale, scale);
        if (alsoStroke) {
            this.ctx.strokeText(text, 0, 0);
        }
        this.ctx.fillText(text, 0, 0);
        this.ctx.restore();
    }

    /**
     * Draws some text within the given rectangular area, aligned based on the given proportional center, with
     * line breaking and (if line breaking isn't enough) font size reduction to make things fit.
     *
     * @param {!string} text
     * @param {!Rect} area
     * @param {!Point} proportionalCenterOfAlignment
     * @param {!string} fontColor
     * @param {!int} maxFontSize
     * @param {!string} fontFamily
     * @returns {!Rect} A minimal bounding rectangle containing the pixels affected by the text printing.
     */
    printParagraph(text,
                   area,
                   proportionalCenterOfAlignment = new Point(0, 0),
                   fontColor = Config.DEFAULT_TEXT_COLOR,
                   maxFontSize = Config.DEFAULT_FONT_SIZE,
                   fontFamily = Config.DEFAULT_FONT_FAMILY) {

        let fontSize;
        let ascendingHeightOf = metric => {
            let d = metric.fontBoundingBoxAscent;
            return d === undefined ? fontSize * 0.75 : d;
        };
        let descendingHeightOf = metric => {
            let d = metric.fontBoundingBoxDescent;
            return d === undefined ? fontSize * 0.25 : d;
        };
        let heightOf = metric => ascendingHeightOf(metric) + descendingHeightOf(metric);

        let lines;
        let measures;
        let height;
        let forcedLines = seq(text.split("\n"));
        for (let df = 0; ; df++) { // Note: potential for quadratic behavior.
            fontSize = maxFontSize - df;
            this.ctx.font = fontSize + "px " + fontFamily;
            lines = forcedLines.
            flatMap(line => Util.breakLine(line, area.w, s => this.ctx.measureText(s).width)).
            toArray();
            measures = lines.map(e => this.ctx.measureText(e));
            height = seq(measures.map(heightOf)).sum();
            if (height <= area.h || fontSize <= 4) {
                break;
            }
        }

        let f = (offset, full, used, proportion) => offset + (full - used) * proportion;
        let fx = w => f(area.x, area.w, w, proportionalCenterOfAlignment.x);
        let fy = h => f(area.y, area.h, h, proportionalCenterOfAlignment.y);
        let y = fy(height);

        this.ctx.fillStyle = fontColor;

        let dy = 0;
        for (let i = 0; i < lines.length; i++) {
            dy += ascendingHeightOf(measures[i]);
            this.ctx.fillText(lines[i], fx(measures[i].width), y + dy);
            dy += descendingHeightOf(measures[i]);
        }

        let maxWidth = new Seq(measures).map(e => e.width).max(0);
        return new Rect(fx(maxWidth), y, maxWidth, height);
    }

    /**
     * Draws a single line of text, without line breaks, using font size reduction to make things fit.
     *
     * @param {!string} text
     * @param {!Rect} area
     * @param {!number|undefined=} proportionalCenterOfHorizontalAlignment
     * @param {!string|undefined=} fontColor
     * @param {!int|undefined=} maxFontSize
     * @param {!string|undefined=} fontFamily
     * @param {!number|undefined=} proportionalCenterOfVerticalAlignment
     * @returns {!Rect} A minimal bounding rectangle containing the pixels affected by the text printing.
     */
    printLine(text,
              area,
              proportionalCenterOfHorizontalAlignment = 0,
              fontColor = Config.DEFAULT_TEXT_COLOR,
              maxFontSize = Config.DEFAULT_FONT_SIZE,
              fontFamily = Config.DEFAULT_FONT_FAMILY,
              proportionalCenterOfVerticalAlignment = undefined) {

        let fontSize;
        let ascendingHeightOf = metric => {
            let d = metric.fontBoundingBoxAscent;
            return d === undefined ? fontSize * 0.75 : d;
        };
        let descendingHeightOf = metric => {
            let d = metric.fontBoundingBoxDescent;
            return d === undefined ? fontSize * 0.25 : d;
        };
        let heightOf = metric => ascendingHeightOf(metric) + descendingHeightOf(metric);

        let measure;
        for (let df = 0; ; df++) { // Note: potential for quadratic behavior.
            fontSize = maxFontSize - df;
            this.ctx.font = fontSize + "px " + fontFamily;
            measure = this.ctx.measureText(text);
            if ((measure.width <= area.w && heightOf(measure) <= area.h) || fontSize <= 4) {
                break;
            }
        }

        let h = heightOf(measure);
        let py = proportionalCenterOfVerticalAlignment === undefined ?
            ascendingHeightOf(measure) / h :
            proportionalCenterOfVerticalAlignment;
        let f = (offset, full, used, proportion) => offset + (full - used) * proportion;
        let x = f(area.x, area.w, measure.width, proportionalCenterOfHorizontalAlignment);
        let y = f(area.y, area.h, h, py);

        this.ctx.fillStyle = fontColor;
        this.ctx.fillText(text, x, y + ascendingHeightOf(measure));

        return new Rect(x, y, measure.width, h);
    }

    /**
     * Draws the outside of a polygon.
     * @param {!(!Point[])} vertices
     * @param {!string=} strokeColor The stroke color.
     * @param {!number=} strokeThickness The stroke thickness.
     */
    strokePolygon(vertices,
                  strokeColor = Config.DEFAULT_STROKE_COLOR,
                  strokeThickness = Config.DEFAULT_STROKE_THICKNESS) {
        if (vertices.length === 0) {
            return;
        }
        let last = vertices[vertices.length - 1];

        this.ctx.beginPath();
        this.ctx.moveTo(last.x, last.y);
        for (let p of vertices) {
            this.ctx.lineTo(p.x, p.y);
        }

        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeThickness;
        this.ctx.stroke();
    }

    /**
     * Draws a path.
     * @param {!(!Point[])} vertices
     * @param {!string=} strokeColor The stroke color.
     * @param {!number=} strokeThickness The stroke thickness.
     */
    strokePath(vertices,
               strokeColor = Config.DEFAULT_STROKE_COLOR,
               strokeThickness = Config.DEFAULT_STROKE_THICKNESS) {
        if (vertices.length === 0) {
            return;
        }

        this.ctx.beginPath();
        this.ctx.moveTo(vertices[0].x, vertices[0].y);
        for (let p of vertices.slice(1)) {
            this.ctx.lineTo(p.x, p.y);
        }

        this.ctx.strokeStyle = strokeColor;
        this.ctx.lineWidth = strokeThickness;
        this.ctx.stroke();
    }

    /**
     * Draws the inside of a polygon.
     * @param {!(!Point[])} vertices
     * @param {!string} fillColor
     */
    fillPolygon(vertices, fillColor) {
        let last = vertices[vertices.length - 1];

        this.ctx.beginPath();
        this.ctx.moveTo(last.x, last.y);
        for (let p of vertices) {
            this.ctx.lineTo(p.x, p.y);
        }

        this.ctx.fillStyle = fillColor;
        this.ctx.fill();
    }
}

/**
 * Has various helper methods for tracing shapes and paths in a CanvasRenderingContext2D.
 */
class Tracer {
    /**
     * @param {!CanvasRenderingContext2D} ctx
     */
    constructor(ctx) {
        /** @type {!CanvasRenderingContext2D} */
        this.ctx = ctx;
    }

    /**
     * @param {!number} x1
     * @param {!number} y1
     * @param {!number} x2
     * @param {!number} y2
     */
    line(x1, y1, x2, y2) {
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
    }

    /**
     * @param {!number} x
     * @param {!number} y
     * @param {!number} w
     * @param {!number} h
     */
    rect(x, y, w, h) {
        this.ctx.moveTo(x, y);
        this.ctx.lineTo(x + w, y);
        this.ctx.lineTo(x + w, y + h);
        this.ctx.lineTo(x, y + h);
        this.ctx.lineTo(x, y);
    }

    /**
     * @param {!number} x The x-coordinate of the center of the circle.
     * @param {!number} y The y-coordinate of the center of the circle.
     * @param {!number} radius The distance from the center of the circle to its side.
     */
    circle(x, y, radius) {
        this.ctx.moveTo(x + radius, y);
        this.ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
    }

    /**
     * @param {!number} x The x-coordinate of the center of the ellipse.
     * @param {!number} y The y-coordinate of the center of the ellipse.
     * @param {!number} horizontal_radius The horizontal distance from the center of the ellipse to its side.
     * @param {!number} vertical_radius The vertical distance from the center of the ellipse to its side.
     */
    ellipse(x, y, horizontal_radius, vertical_radius) {
        this.ctx.save();

        this.ctx.translate(x - horizontal_radius, y - vertical_radius);
        this.ctx.scale(horizontal_radius, vertical_radius);
        this.ctx.moveTo(2, 1);
        this.ctx.arc(1, 1, 1, 0, 2 * Math.PI, false);

        this.ctx.restore();
    }

    /**
     * @param {!number} x
     * @param {!number} y
     * @param {!number} w
     * @param {!number} h
     * @param {!int} numCols
     * @param {!int} numRows
     */
    grid(x, y, w, h, numCols, numRows) {
        let dw = w / numCols;
        let dh = h / numRows;
        let x2 = x + numCols * dw;
        let y2 = y + numRows * dh;
        for (let c = 0; c <= numCols; c++) {
            this.ctx.moveTo(x + c * dw, y);
            this.ctx.lineTo(x + c * dw, y2);
        }
        for (let r = 0; r <= numRows; r++) {
            this.ctx.moveTo(x, y + r * dh);
            this.ctx.lineTo(x2, y + r * dh);
        }
    }

    /**
     * @param {!Array.<!number>|!Float32Array} interleavedCoordinates
     */
    polygon(interleavedCoordinates) {
        if (interleavedCoordinates.length === 0) {
            return;
        }

        let n = interleavedCoordinates.length;
        this.ctx.moveTo(interleavedCoordinates[n-2], interleavedCoordinates[n-1]);
        for (let i = 0; i < n; i += 2) {
            this.ctx.lineTo(interleavedCoordinates[i], interleavedCoordinates[i+1]);
        }
    }

    /**
     * @param {!number} x The x-position of the center of the arrow head.
     * @param {number} y The y-position of the center of the arrow head.
     * @param {number} radius The radius of the circle the arrow head is inscribed inside.
     * @param {number} facingAngle The direction the arrow head is pointing towards.
     * @param {number} sweptAngle The angle swept out by the back of the arrow head, relative to its center (not the
     * point at the front).
     * @param {!string} root
     */
    arrowHead(x, y, radius, facingAngle, sweptAngle, root='center') {
        let a1 = facingAngle + sweptAngle/2 + Math.PI;
        let a2 = facingAngle - sweptAngle/2 + Math.PI;
        let c = Math.cos(facingAngle);
        let s = Math.sin(facingAngle);
        if (root === 'tip') {
            x -= c*radius;
            y -= s*radius;
        }
        if (root === 'stem') {
            x += c*radius;
            y += s*radius;
        }
        this.polygon([
            x + c*radius, y + s*radius,
            x + Math.cos(a1)*radius, y + Math.sin(a1)*radius,
            x + Math.cos(a2)*radius, y + Math.sin(a2)*radius
        ]);
    }

}

/**
 * Strokes/fills a traced path.
 */
class TraceAction {
    constructor(ctx) {
        this.ctx = ctx;
    }

    /**
     * @param {!string} fillStyle
     * @returns {!TraceAction}
     */
    thenFill(fillStyle) {
        this.ctx.fillStyle = fillStyle;
        this.ctx.fill();
        return this;
    }

    /**
     * @param {!string} strokeStyle
     * @param {!number=} lineWidth
     * @returns {!TraceAction}
     */
    thenStroke(strokeStyle, lineWidth = 1) {
        this.ctx.strokeStyle = strokeStyle;
        this.ctx.lineWidth = lineWidth;
        this.ctx.stroke();
        return this;
    }
}

_gen_package_export("src/Painter.js", {Painter});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/BitTable.js", function() {

/**
 * A 2d array of bits.
 */
class BitTable {
    /**
     * @param {!Uint8Array} buf
     * @param {!int} w
     * @param {!int} h
     */
    constructor(buf, w, h) {
        if (buf.length !== w * h) {
            throw new Error('buf.length !== w * h');
        }
        this.buf = buf;
        this.w = w;
        this.h = h;
    }

    /**
     * @param {!Array.<!int|!boolean>} rows
     * @returns {!BitTable}
     */
    static fromRows(...rows) {
        if (rows.length === 0) {
            throw new Error('rows.length === 0');
        }
        let h = rows.length;
        let w = rows[0].length;
        let buf = new Uint8Array(h * w);
        let k = 0;
        for (let row of rows) {
            if (row.length !== w) {
                throw new Error('row.length !== w');
            }
            for (let e of row) {
                buf[k] = e ? 1 : 0;
                k++;
            }
        }
        return new BitTable(buf, w, h);
    }

    /**
     * @returns {!BitTable}
     */
    copy() {
        return new BitTable(
            new Uint8Array(this.buf),
            this.w,
            this.h);
    }

    /**
     * @param {!int} w
     * @param {!int} h
     * @returns {!BitTable}
     */
    static zeros(w, h) {
        let buf = new Uint8Array(w * h);
        return new BitTable(buf, w, h);
    }

    /**
     * @param {!int|undefined=undefined} start
     * @param {!int|undefined=undefined} stop
     * @returns {!BitTable}
     */
    sliceRows(start=undefined, stop=undefined) {
        if (start === undefined) {
            start = 0;
        }
        if (stop === undefined) {
            stop = this.h;
        }
        return new BitTable(this.buf.slice(start*this.w, stop*this.w), this.w, stop - start);
    }

    /**
     * @param {!int} target_row
     * @param {!int} source_row
     */
    ixorRowToFrom(target_row, source_row) {
        let dst = this.w * target_row;
        let src = this.w * source_row;
        for (let col = 0; col < this.w; col++) {
            this.buf[dst + col] ^= this.buf[src + col];
        }
    }

    /**
     * @param {!int} row
     * @param {!int=} start
     * @returns {!Uint8Array}
     */
    row(row, start=0) {
        return this.buf.slice(
            this.w * row + start,
            this.w * (row + 1));
    }

    /**
     * @param {!int} col
     * @param {!int=} start
     * @returns {!Uint8Array}
     */
    col(col, start=0) {
        let result = new Uint8Array(this.h - start);
        for (let row = start; row < this.h; row++) {
            result[row - start] = this.get(row, col);
        }
        return result;
    }

    /**
     * @param {!int} row
     * @param {!int} col
     * @returns {!boolean}
     */
    get(row, col) {
        return this.buf[row * this.w + col] !== 0;
    }

    /**
     * @param {!int} row
     * @param {!int} col
     * @param {!boolean} val
     */
    set(row, col, val) {
        this.buf[row * this.w + col] = val ? 1 : 0;
    }

    /**
     * @param {!object} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (!(other instanceof BitTable)) {
            return false;
        }
        if (other.w !== this.w || other.h !== this.h) {
            return false;
        }
        for (let k = 0; k < this.buf.length; k++) {
            if (this.buf[k] !== other.buf[k]) {
                return false;
            }
        }
        return true;
    }

    toString() {
        let out = '';
        let k = 0;
        for (let row = 0; row < this.h; row++) {
            if (row > 0) {
                out += '\n'
            }
            for (let col = 0; col < this.w; col++) {
                out += this.buf[k] ? '1' : '0';
                k++;
            }
        }
        return out;
    }

    /**
     * @returns {!BitTable}
     */
    gaussianEliminatedMod2() {
        let out = this.copy();

        let h = this.h;
        let w = this.w;
        let next_row = 0;
        for (let col = 0; col < w; col++) {
            // Locate pivot.
            let row = first_non_zero_index(out.col(col, next_row));
            if (row === undefined) {
                continue;
            }
            row += next_row;

            // Eliminate column entry in other rows.
            for (let row2 = 0; row2 < h; row2++) {
                if (out.get(row2, col) && row !== row2) {
                    out.ixorRowToFrom(row2, row);
                }
            }

            // Keep it sorted.
            if (row !== next_row) {
                out.ixorRowToFrom(next_row, row);
                out.ixorRowToFrom(row, next_row);
                out.ixorRowToFrom(next_row, row);
            }
            next_row += 1;
        }
        return out;
    }
}

/**
 * @param {!Uint8Array} items
 * @returns {!int|undefined}
 */
function first_non_zero_index(items) {
    for (let i = 0; i < items.length; i++) {
        if (items[i] !== 0) {
            return i;
        }
    }
    return undefined;
}

_gen_package_export("src/sim/BitTable.js", {BitTable});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/chp_gen.js", function() {

// Copyright 2010 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

Module['arguments'] = [];
Module['thisProgram'] = './this.program';
Module['quit'] = function(status, toThrow) {
  throw toThrow;
};
Module['preRun'] = [];
Module['postRun'] = [];

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_HAS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
ENVIRONMENT_HAS_NODE = typeof process === 'object' && typeof require === 'function';
ENVIRONMENT_IS_NODE = ENVIRONMENT_HAS_NODE && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;



// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)




// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  } else {
    return scriptDirectory + path;
  }
}

if (ENVIRONMENT_IS_NODE) {
  scriptDirectory = __dirname + '/';

  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  var nodeFS;
  var nodePath;

  Module['read'] = function shell_read(filename, binary) {
    var ret;
    ret = tryParseAsDataURI(filename);
    if (!ret) {
      if (!nodeFS) nodeFS = require('fs');
      if (!nodePath) nodePath = require('path');
      filename = nodePath['normalize'](filename);
      ret = nodeFS['readFileSync'](filename);
    }
    return binary ? ret : ret.toString();
  };

  Module['readBinary'] = function readBinary(filename) {
    var ret = Module['read'](filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  if (process['argv'].length > 1) {
    Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
  // Currently node will swallow unhandled rejections, but this behavior is
  // deprecated, and in the future it will exit with error status.
  process['on']('unhandledRejection', abort);

  Module['quit'] = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    Module['read'] = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  Module['readBinary'] = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof quit === 'function') {
    Module['quit'] = function(status) {
      quit(status);
    }
  }
} else
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  Module['read'] = function shell_read(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    Module['readBinary'] = function readBinary(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(xhr.response);
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  Module['readAsync'] = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  Module['setWindowTitle'] = function(title) { document.title = title };
} else
{
}

// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
// If the user provided Module.print or printErr, use that. Otherwise,
// console.log is checked first, as 'print' on the web will open a print dialogue
// printErr is preferable to console.warn (works better in shells)
// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.
var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null));
var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || out));

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = undefined;

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message



// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;


function dynamicAlloc(size) {
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  if (end > _emscripten_get_heap_size()) {
    abort();
  }
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

var asm2wasmImports = { // special asm2wasm imports
    "f64-rem": function(x, y) {
        return x % y;
    },
    "debugger": function() {
        debugger;
    }
};



var jsCallStartIndex = 1;
var functionPointers = new Array(0);


// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {


  var base = 0;
  for (var i = base; i < base + 0; i++) {
    if (!functionPointers[i]) {
      functionPointers[i] = func;
      return jsCallStartIndex + i;
    }
  }
  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';

}

function removeFunction(index) {

  functionPointers[index-jsCallStartIndex] = null;
}

var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

function dynCall(sig, ptr, args) {
  if (args && args.length) {
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
}

var getTempRet0 = function() {
  return tempRet0;
}


var Runtime = {
};

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 8;




// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html





/** @type {function(number, string, boolean=)} */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}




// Wasm globals

var wasmMemory;

// Potentially used for direct table calls.
var wasmTable;


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

/** @type {function(number, number, string, boolean=)} */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}




/** @type {function(number, number=)} */
function Pointer_stringify(ptr, length) {
  abort("this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!");
}

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}


// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = u8Array[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = u8Array[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = u8Array[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}


// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;
function UTF16ToString(ptr) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}





function demangle(func) {
  return func;
}

function demangleAll(text) {
  var regex =
    /__Z[\w\d_]+/g;
  return text.replace(regex,
    function(x) {
      var y = demangle(x);
      return x === y ? x : (y + ' [' + x + ']');
    });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  var js = jsStackTrace();
  if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
  return demangleAll(js);
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferViews() {
  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
}


var STATIC_BASE = 8,
    STACK_BASE = 3392,
    STACKTOP = STACK_BASE,
    STACK_MAX = 5246272,
    DYNAMIC_BASE = 5246272,
    DYNAMICTOP_PTR = 3360;




var TOTAL_STACK = 5242880;

var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
if (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// Initialize the runtime's memory







// Use a provided buffer, if there is one, or else allocate a new one
if (Module['buffer']) {
  buffer = Module['buffer'];
} else {
  // Use a WebAssembly memory where available
  {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
}
updateGlobalBufferViews();


HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;






// Endianness check (note: assumes compiler arch was little-endian)

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  if (runtimeInitialized) return;
  runtimeInitialized = true;

  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {

  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}



var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
}

function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;






// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return String.prototype.startsWith ?
      filename.startsWith(dataURIPrefix) :
      filename.indexOf(dataURIPrefix) === 0;
}





// === Body ===

var ASM_CONSTS = [];





// STATICTOP = STATIC_BASE + 3384;
/* global initializers */  __ATINIT__.push({ func: function() { globalCtors() } });


memoryInitializer = "data:application/octet-stream;base64,AAAAAAAAAACYAQAAUAAAAOgBAADoAQAA2AEAAFAAAADoAQAA2AEAAKgBAAAAAAAAAAAAAAAAAACwAQAAUAAAANgBAADYAQAATAIAAGADAAC4AgAAaAMAAAAAAABQAAAAuAIAAHEDAAABAAAAUAAAAEwCAAC+BQAATAIAAP0FAABMAgAAOwYAAEwCAACBBgAATAIAAL4GAABMAgAA3QYAAEwCAAD8BgAATAIAABsHAABMAgAAOgcAAEwCAABZBwAATAIAAHgHAABMAgAAtQcAAEwCAADUBwAA1AIAAOcHAAAAAAAAAQAAAPgAAAAAAAAATAIAACYIAADUAgAATAgAAAAAAAABAAAA+AAAAAAAAADUAgAAiwgAAAAAAAABAAAA+AAAAAAAAAB0AgAAggkAAEABAAAAAAAAdAIAAC8JAABQAQAAAAAAAEwCAABQCQAAdAIAAF0JAAAwAQAAAAAAAHQCAADICQAAQAEAAAAAAAB0AgAApAkAAGgBAAAAAAAAdAIAAOoJAABAAQAAAAAAAJwCAAASCgAAnAIAABQKAACcAgAAFwoAAJwCAAAZCgAAnAIAABsKAACcAgAAHQoAAJwCAAAfCgAAnAIAACEKAACcAgAAIwoAAJwCAAAlCgAAnAIAACcKAACcAgAAKQoAAJwCAAArCgAAnAIAAC0KAAB0AgAALwoAADABAAAAAAAAWAAAAJgBAABQAAAA6AEAAJgBAABQAAAAUAAAAFAAAACwAQAAUAAAANgBAAAAAAAAMAEAAAEAAAACAAAAAwAAAAQAAAABAAAAAQAAAAEAAAABAAAAAAAAAFgBAAABAAAABQAAAAMAAAAEAAAAAQAAAAIAAAACAAAAAgAAAAAAAACIAQAAAQAAAAYAAAADAAAABAAAAAIAAAAAAAAAeAEAAAEAAAAHAAAAAwAAAAQAAAADAAAAAAAAAAgCAAABAAAACAAAAAMAAAAEAAAAAQAAAAMAAAADAAAAAwAAAFFTdGF0ZQBpbml0X3N0YXRlAGNub3QAaGFkYW1hcmQAcGhhc2UAbWVhc3VyZQBmcmVlX3N0YXRlAGNsb25lX3N0YXRlAHBlZWtfc3RhdGVfeABwZWVrX3N0YXRlX3oAcGVla19zdGF0ZV9yADZRU3RhdGUAUDZRU3RhdGUAUEs2UVN0YXRlAGlpAHYAdmkAdmlpaQB2aWlpaQBpaWlpaWkAdmlpAGlpaQBpaWlpaQBpaWlpAHZvaWQAYm9vbABzdGQ6OnN0cmluZwBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBzdGQ6OndzdHJpbmcAZW1zY3JpcHRlbjo6dmFsAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQ4X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQxNl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MzJfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZyBkb3VibGU+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWVFRQBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lsRUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l0RUUATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4ATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAE4xMGVtc2NyaXB0ZW4zdmFsRQBOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0loTlNfMTFjaGFyX3RyYWl0c0loRUVOU185YWxsb2NhdG9ySWhFRUVFAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAGRvdWJsZQBmbG9hdAB1bnNpZ25lZCBsb25nAGxvbmcAdW5zaWduZWQgaW50AGludAB1bnNpZ25lZCBzaG9ydABzaG9ydAB1bnNpZ25lZCBjaGFyAHNpZ25lZCBjaGFyAGNoYXIATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAU3Q5dHlwZV9pbmZvAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQBOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAE4xMF9fY3h4YWJpdjEyM19fZnVuZGFtZW50YWxfdHlwZV9pbmZvRQB2AERuAGIAYwBoAGEAcwB0AGkAagBsAG0AZgBkAE4xMF9fY3h4YWJpdjEyMV9fdm1pX2NsYXNzX3R5cGVfaW5mb0U=";





/* no memory initializer */
var tempDoublePtr = 3376

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
}

function copyTempDouble(ptr) {
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];
  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];
  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];
  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];
}

// {{PRE_LIBRARY}}



  function getShiftFromSize(size) {
      switch (size) {
          case 1: return 0;
          case 2: return 1;
          case 4: return 2;
          case 8: return 3;
          default:
              throw new TypeError('Unknown type size: ' + size);
      }
    }



  function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }var embind_charCodes=undefined;function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }


  var awaitingDependencies={};

  var registeredTypes={};

  var typeDependencies={};






  var char_0=48;

  var char_9=57;function makeLegalFunctionName(name) {
      if (undefined === name) {
          return '_unknown';
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
          return '_' + name;
      } else {
          return name;
      }
    }function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      /*jshint evil:true*/
      return new Function(
          "body",
          "return function " + name + "() {\n" +
          "    \"use strict\";" +
          "    return body.apply(this, arguments);\n" +
          "};\n"
      )(body);
    }function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;

          var stack = (new Error(message)).stack;
          if (stack !== undefined) {
              this.stack = this.toString() + '\n' +
                  stack.replace(/^Error(:[^\n]*)?\n/, '');
          }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
          if (this.message === undefined) {
              return this.name;
          } else {
              return this.name + ': ' + this.message;
          }
      };

      return errorClass;
    }var BindingError=undefined;function throwBindingError(message) {
      throw new BindingError(message);
    }



  var InternalError=undefined;function throwInternalError(message) {
      throw new InternalError(message);
    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
      });

      function onComplete(typeConverters) {
          var myTypeConverters = getTypeConverters(typeConverters);
          if (myTypeConverters.length !== myTypes.length) {
              throwInternalError('Mismatched type converter count');
          }
          for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
          }
      }

      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach(function(dt, i) {
          if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
          } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                      onComplete(typeConverters);
                  }
              });
          }
      });
      if (0 === unregisteredTypes.length) {
          onComplete(typeConverters);
      }
    }function registerType(rawType, registeredInstance, options) {
      options = options || {};

      if (!('argPackAdvance' in registeredInstance)) {
          throw new TypeError('registerType registeredInstance requires argPackAdvance');
      }

      var name = registeredInstance.name;
      if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
              return;
          } else {
              throwBindingError("Cannot register type '" + name + "' twice");
          }
      }

      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];

      if (awaitingDependencies.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies[rawType];
          delete awaitingDependencies[rawType];
          callbacks.forEach(function(cb) {
              cb();
          });
      }
    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);

      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': function(pointer) {
              // TODO: if heap is fixed (like in asm.js) this could be executed outside
              var heap;
              if (size === 1) {
                  heap = HEAP8;
              } else if (size === 2) {
                  heap = HEAP16;
              } else if (size === 4) {
                  heap = HEAP32;
              } else {
                  throw new TypeError("Unknown boolean type size: " + name);
              }
              return this['fromWireType'](heap[pointer >> shift]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    }




  function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
          return false;
      }
      if (!(other instanceof ClassHandle)) {
          return false;
      }

      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;

      while (leftClass.baseClass) {
          left = leftClass.upcast(left);
          leftClass = leftClass.baseClass;
      }

      while (rightClass.baseClass) {
          right = rightClass.upcast(right);
          rightClass = rightClass.baseClass;
      }

      return leftClass === rightClass && left === right;
    }


  function shallowCopyInternalPointer(o) {
      return {
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType,
      };
    }

  function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    }


  var finalizationGroup=false;

  function detachFinalizer(handle) {}


  function runDestructor($$) {
      if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
          runDestructor($$);
      }
    }function attachFinalizer(handle) {
      if ('undefined' === typeof FinalizationGroup) {
          attachFinalizer = function (handle) { return handle; };
          return handle;
      }
      // If the running environment has a FinalizationGroup (see
      // https://github.com/tc39/proposal-weakrefs), then attach finalizers
      // for class handles.  We check for the presence of FinalizationGroup
      // at run-time, not build-time.
      finalizationGroup = new FinalizationGroup(function (iter) {
          for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                  console.warn('object already deleted: ' + $$.ptr);
              } else {
                  releaseClassHandle($$);
              }
          }
      });
      attachFinalizer = function(handle) {
          finalizationGroup.register(handle, handle.$$, handle.$$);
          return handle;
      };
      detachFinalizer = function(handle) {
          finalizationGroup.unregister(handle.$$);
      };
      return attachFinalizer(handle);
    }function ClassHandle_clone() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }

      if (this.$$.preservePointerOnDelete) {
          this.$$.count.value += 1;
          return this;
      } else {
          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
              $$: {
                  value: shallowCopyInternalPointer(this.$$),
              }
          }));

          clone.$$.count.value += 1;
          clone.$$.deleteScheduled = false;
          return clone;
      }
    }

  function ClassHandle_delete() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }

      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError('Object already scheduled for deletion');
      }

      detachFinalizer(this);
      releaseClassHandle(this.$$);

      if (!this.$$.preservePointerOnDelete) {
          this.$$.smartPtr = undefined;
          this.$$.ptr = undefined;
      }
    }

  function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }


  var delayFunction=undefined;

  var deletionQueue=[];

  function flushPendingDeletes() {
      while (deletionQueue.length) {
          var obj = deletionQueue.pop();
          obj.$$.deleteScheduled = false;
          obj['delete']();
      }
    }function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError('Object already scheduled for deletion');
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
          delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }function init_ClassHandle() {
      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
      ClassHandle.prototype['clone'] = ClassHandle_clone;
      ClassHandle.prototype['delete'] = ClassHandle_delete;
      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
    }function ClassHandle() {
    }

  var registeredPointers={};


  function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
          var prevFunc = proto[methodName];
          // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
          proto[methodName] = function() {
              // TODO This check can be removed in -O3 level "unsafe" optimizations.
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
          };
          // Move the previous function into the overload table.
          proto[methodName].overloadTable = [];
          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
          if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
              throwBindingError("Cannot register public name '" + name + "' twice");
          }

          // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
          // that routes between the two.
          ensureOverloadTable(Module, name, name);
          if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
          }
          // Add the new function into the overload table.
          Module[name].overloadTable[numArguments] = value;
      }
      else {
          Module[name] = value;
          if (undefined !== numArguments) {
              Module[name].numArguments = numArguments;
          }
      }
    }

  function RegisteredClass(
      name,
      constructor,
      instancePrototype,
      rawDestructor,
      baseClass,
      getActualType,
      upcast,
      downcast
    ) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }



  function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
          if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
          }
          ptr = ptrClass.upcast(ptr);
          ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
          return 0;
      }

      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }

  function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }

          if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
          } else {
              return 0;
          }
      }

      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);

      if (this.isSmartPointer) {
          // TODO: this is not strictly true
          // We could support BY_EMVAL conversions from raw pointers to smart pointers
          // because the smart pointer can hold a reference to the handle
          if (undefined === handle.$$.smartPtr) {
              throwBindingError('Passing raw pointer to smart pointer is illegal');
          }

          switch (this.sharingPolicy) {
              case 0: // NONE
                  // no upcasting
                  if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                  } else {
                      throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
                  }
                  break;

              case 1: // INTRUSIVE
                  ptr = handle.$$.smartPtr;
                  break;

              case 2: // BY_EMVAL
                  if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                  } else {
                      var clonedHandle = handle['clone']();
                      ptr = this.rawShare(
                          ptr,
                          __emval_register(function() {
                              clonedHandle['delete']();
                          })
                      );
                      if (destructors !== null) {
                          destructors.push(this.rawDestructor, ptr);
                      }
                  }
                  break;

              default:
                  throwBindingError('Unsupporting sharing policy');
          }
      }
      return ptr;
    }

  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
          return 0;
      }

      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }


  function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2]);
    }

  function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
          ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }

  function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
          this.rawDestructor(ptr);
      }
    }

  function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
          handle['delete']();
      }
    }


  function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
          return ptr;
      }
      if (undefined === desiredClass.baseClass) {
          return null; // no conversion
      }

      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
          return null;
      }
      return desiredClass.downcast(rv);
    }




  function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }

  function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
          }
      }
      return rv;
    }

  function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
          delayFunction(flushPendingDeletes);
      }
    }function init_embind() {
      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
      Module['flushPendingDeletes'] = flushPendingDeletes;
      Module['setDelayFunction'] = setDelayFunction;
    }var registeredInstances={};

  function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
          throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
      }
      return ptr;
    }function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }

  function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
          throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
          throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, {
          $$: {
              value: record,
          },
      }));
    }function RegisteredPointer_fromWireType(ptr) {
      // ptr is a raw pointer (or a raw smartpointer)

      // rawPointer is a maybe-null raw pointer
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
          this.destructor(ptr);
          return null;
      }

      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
          // JS object has been neutered, time to repopulate it
          if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance['clone']();
          } else {
              // else, just increment reference count on existing object
              // it already has a reference to the smart pointer
              var rv = registeredInstance['clone']();
              this.destructor(ptr);
              return rv;
          }
      }

      function makeDefaultHandle() {
          if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this.pointeeType,
                  ptr: rawPointer,
                  smartPtrType: this,
                  smartPtr: ptr,
              });
          } else {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this,
                  ptr: ptr,
              });
          }
      }

      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
          return makeDefaultHandle.call(this);
      }

      var toType;
      if (this.isConst) {
          toType = registeredPointerRecord.constPointerType;
      } else {
          toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
          rawPointer,
          this.registeredClass,
          toType.registeredClass);
      if (dp === null) {
          return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
          return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr,
          });
      } else {
          return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
          });
      }
    }function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype['argPackAdvance'] = 8;
      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
    }function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,

      // smart pointer properties
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;

      // smart pointer properties
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;

      if (!isSmartPointer && registeredClass.baseClass === undefined) {
          if (isConst) {
              this['toWireType'] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
          } else {
              this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
          }
      } else {
          this['toWireType'] = genericPointerToWireType;
          // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
          // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
          // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
          //       craftInvokerFunction altogether.
      }
    }

  function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
          throwInternalError('Replacing nonexistant public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
          Module[name].overloadTable[numArguments] = value;
      }
      else {
          Module[name] = value;
          Module[name].argCount = numArguments;
      }
    }

  function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);

      function makeDynCaller(dynCall) {
          var args = [];
          for (var i = 1; i < signature.length; ++i) {
              args.push('a' + i);
          }

          var name = 'dynCall_' + signature + '_' + rawFunction;
          var body = 'return function ' + name + '(' + args.join(', ') + ') {\n';
          body    += '    return dynCall(rawFunction' + (args.length ? ', ' : '') + args.join(', ') + ');\n';
          body    += '};\n';

          return (new Function('dynCall', 'rawFunction', body))(dynCall, rawFunction);
      }

      var fp;
      if (Module['FUNCTION_TABLE_' + signature] !== undefined) {
          fp = Module['FUNCTION_TABLE_' + signature][rawFunction];
      } else if (typeof FUNCTION_TABLE !== "undefined") {
          fp = FUNCTION_TABLE[rawFunction];
      } else {
          // asm.js does not give direct access to the function tables,
          // and thus we must go through the dynCall interface which allows
          // calling into a signature's function table by pointer value.
          //
          // https://github.com/dherman/asm.js/issues/83
          //
          // This has three main penalties:
          // - dynCall is another function call in the path from JavaScript to C++.
          // - JITs may not predict through the function table indirection at runtime.
          var dc = Module['dynCall_' + signature];
          if (dc === undefined) {
              // We will always enter this branch if the signature
              // contains 'f' and PRECISE_F32 is not enabled.
              //
              // Try again, replacing 'f' with 'd'.
              dc = Module['dynCall_' + signature.replace(/f/g, 'd')];
              if (dc === undefined) {
                  throwBindingError("No dynCall invoker for signature: " + signature);
              }
          }
          fp = makeDynCaller(dc);
      }

      if (typeof fp !== "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
      }
      return fp;
    }


  var UnboundTypeError=undefined;

  function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
          if (seen[type]) {
              return;
          }
          if (registeredTypes[type]) {
              return;
          }
          if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
          }
          unboundTypes.push(type);
          seen[type] = true;
      }
      types.forEach(visit);

      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));
    }function __embind_register_class(
      rawType,
      rawPointerType,
      rawConstPointerType,
      baseClassRawType,
      getActualTypeSignature,
      getActualType,
      upcastSignature,
      upcast,
      downcastSignature,
      downcast,
      name,
      destructorSignature,
      rawDestructor
    ) {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
          upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
          downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);

      exposePublicSymbol(legalFunctionName, function() {
          // this code cannot run if baseClassRawType is zero
          throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
      });

      whenDependentTypesAreResolved(
          [rawType, rawPointerType, rawConstPointerType],
          baseClassRawType ? [baseClassRawType] : [],
          function(base) {
              base = base[0];

              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                  baseClass = base.registeredClass;
                  basePrototype = baseClass.instancePrototype;
              } else {
                  basePrototype = ClassHandle.prototype;
              }

              var constructor = createNamedFunction(legalFunctionName, function() {
                  if (Object.getPrototypeOf(this) !== instancePrototype) {
                      throw new BindingError("Use 'new' to construct " + name);
                  }
                  if (undefined === registeredClass.constructor_body) {
                      throw new BindingError(name + " has no accessible constructor");
                  }
                  var body = registeredClass.constructor_body[arguments.length];
                  if (undefined === body) {
                      throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                  }
                  return body.apply(this, arguments);
              });

              var instancePrototype = Object.create(basePrototype, {
                  constructor: { value: constructor },
              });

              constructor.prototype = instancePrototype;

              var registeredClass = new RegisteredClass(
                  name,
                  constructor,
                  instancePrototype,
                  rawDestructor,
                  baseClass,
                  getActualType,
                  upcast,
                  downcast);

              var referenceConverter = new RegisteredPointer(
                  name,
                  registeredClass,
                  true,
                  false,
                  false);

              var pointerConverter = new RegisteredPointer(
                  name + '*',
                  registeredClass,
                  false,
                  false,
                  false);

              var constPointerConverter = new RegisteredPointer(
                  name + ' const*',
                  registeredClass,
                  false,
                  true,
                  false);

              registeredPointers[rawType] = {
                  pointerType: pointerConverter,
                  constPointerType: constPointerConverter
              };

              replacePublicSymbol(legalFunctionName, constructor);

              return [referenceConverter, pointerConverter, constPointerConverter];
          }
      );
    }


  function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
      }
      return array;
    }

  function runDestructors(destructors) {
      while (destructors.length) {
          var ptr = destructors.pop();
          var del = destructors.pop();
          del(ptr);
      }
    }function __embind_register_class_constructor(
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);

      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = 'constructor ' + classType.name;

          if (undefined === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
          }
          if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount-1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          }
          classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
          };

          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                      throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount-1));
                  }
                  var destructors = [];
                  var args = new Array(argCount);
                  args[0] = rawConstructor;
                  for (var i = 1; i < argCount; ++i) {
                      args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);
                  }

                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);

                  return argTypes[0]['fromWireType'](ptr);
              };
              return [];
          });
          return [];
      });
    }



  var emval_free_list=[];

  var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
          emval_handle_array[handle] = undefined;
          emval_free_list.push(handle);
      }
    }



  function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              ++count;
          }
      }
      return count;
    }

  function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              return emval_handle_array[i];
          }
      }
      return null;
    }function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }function __emval_register(value) {

      switch(value){
        case undefined :{ return 1; }
        case null :{ return 2; }
        case true :{ return 3; }
        case false :{ return 4; }
        default:{
          var handle = emval_free_list.length ?
              emval_free_list.pop() :
              emval_handle_array.length;

          emval_handle_array[handle] = {refcount: 1, value: value};
          return handle;
          }
        }
    }function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
          },
          'toWireType': function(destructors, value) {
              return __emval_register(value);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: null, // This type does not need a destructor

          // TODO: do we need a deleteObject here?  write a test where
          // emval is passed into JS via an interface
      });
    }


  function _embind_repr(v) {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    }

  function floatReadValueFromPointer(name, shift) {
      switch (shift) {
          case 2: return function(pointer) {
              return this['fromWireType'](HEAPF32[pointer >> 2]);
          };
          case 3: return function(pointer) {
              return this['fromWireType'](HEAPF64[pointer >> 3]);
          };
          default:
              throw new TypeError("Unknown float type: " + name);
      }
    }function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              return value;
          },
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following if() and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': floatReadValueFromPointer(name, shift),
          destructorFunction: null, // This type does not need a destructor
      });
    }



  function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
          throw new TypeError('new_ called with constructor type ' + typeof(constructor) + " which is not a function");
      }

      /*
       * Previously, the following line was just:

       function dummy() {};

       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the
       * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which
       * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way
       * to write a test for this behavior.  -NRD 2013.02.22
       */
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});
      dummy.prototype = constructor.prototype;
      var obj = new dummy;

      var r = constructor.apply(obj, argumentList);
      return (r instanceof Object) ? r : obj;
    }function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      var argCount = argTypes.length;

      if (argCount < 2) {
          throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }

      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);

      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
  // TODO: This omits argument count check - enable only at -O3 or similar.
  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
  //       return FUNCTION_TABLE[fn];
  //    }


      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = false;

      for(var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.
          if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack
              needsDestructorStack = true;
              break;
          }
      }

      var returns = (argTypes[0].name !== "void");

      var argsList = "";
      var argsListWired = "";
      for(var i = 0; i < argCount - 2; ++i) {
          argsList += (i!==0?", ":"")+"arg"+i;
          argsListWired += (i!==0?", ":"")+"arg"+i+"Wired";
      }

      var invokerFnBody =
          "return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n" +
          "if (arguments.length !== "+(argCount - 2)+") {\n" +
              "throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount - 2)+" args!');\n" +
          "}\n";


      if (needsDestructorStack) {
          invokerFnBody +=
              "var destructors = [];\n";
      }

      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];


      if (isClassMethodFunc) {
          invokerFnBody += "var thisWired = classParam.toWireType("+dtorStack+", this);\n";
      }

      for(var i = 0; i < argCount - 2; ++i) {
          invokerFnBody += "var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";
          args1.push("argType"+i);
          args2.push(argTypes[i+2]);
      }

      if (isClassMethodFunc) {
          argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }

      invokerFnBody +=
          (returns?"var rv = ":"") + "invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";

      if (needsDestructorStack) {
          invokerFnBody += "runDestructors(destructors);\n";
      } else {
          for(var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
              var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
              if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";
                  args1.push(paramName+"_dtor");
                  args2.push(argTypes[i].destructorFunction);
              }
          }
      }

      if (returns) {
          invokerFnBody += "var ret = retType.fromWireType(rv);\n" +
                           "return ret;\n";
      } else {
      }
      invokerFnBody += "}\n";

      args1.push(invokerFnBody);

      var invokerFunction = new_(Function, args1).apply(null, args2);
      return invokerFunction;
    }function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = readLatin1String(name);

      rawInvoker = embind__requireFunction(signature, rawInvoker);

      exposePublicSymbol(name, function() {
          throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);
      }, argCount - 1);

      whenDependentTypesAreResolved([], argTypes, function(argTypes) {
          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);
          return [];
      });
    }


  function integerReadValueFromPointer(name, shift, signed) {
      // integers are quite common, so generate very specialized functions
      switch (shift) {
          case 0: return signed ?
              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :
              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
          case 1: return signed ?
              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :
              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
          case 2: return signed ?
              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :
              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
          default:
              throw new TypeError("Unknown integer type: " + name);
      }
    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
          maxRange = 4294967295;
      }

      var shift = getShiftFromSize(size);

      var fromWireType = function(value) {
          return value;
      };

      if (minRange === 0) {
          var bitshift = 32 - 8*size;
          fromWireType = function(value) {
              return (value << bitshift) >>> bitshift;
          };
      }

      var isUnsignedType = (name.indexOf('unsigned') != -1);

      registerType(primitiveType, {
          name: name,
          'fromWireType': fromWireType,
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following two if()s and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                  throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');
              }
              return isUnsignedType ? (value >>> 0) : (value | 0);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
      ];

      var TA = typeMapping[dataTypeIndex];

      function decodeMemoryView(handle) {
          handle = handle >> 2;
          var heap = HEAPU32;
          var size = heap[handle]; // in elements
          var data = heap[handle + 1]; // byte offset into emscripten heap
          return new TA(heap['buffer'], data, size);
      }

      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': decodeMemoryView,
          'argPackAdvance': 8,
          'readValueFromPointer': decodeMemoryView,
      }, {
          ignoreDuplicateRegistrations: true,
      });
    }

  function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      var stdStringIsUTF8
      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>
      = (name === "std::string");

      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var length = HEAPU32[value >> 2];

              var str;
              if(stdStringIsUTF8) {
                  //ensure null termination at one-past-end byte if not present yet
                  var endChar = HEAPU8[value + 4 + length];
                  var endCharSwap = 0;
                  if(endChar != 0)
                  {
                    endCharSwap = endChar;
                    HEAPU8[value + 4 + length] = 0;
                  }

                  var decodeStartPtr = value + 4;
                  //looping here to support possible embedded '0' bytes
                  for (var i = 0; i <= length; ++i) {
                    var currentBytePtr = value + 4 + i;
                    if(HEAPU8[currentBytePtr] == 0)
                    {
                      var stringSegment = UTF8ToString(decodeStartPtr);
                      if(str === undefined)
                        str = stringSegment;
                      else
                      {
                        str += String.fromCharCode(0);
                        str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + 1;
                    }
                  }

                  if(endCharSwap != 0)
                    HEAPU8[value + 4 + length] = endCharSwap;
              } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                  }
                  str = a.join('');
              }

              _free(value);

              return str;
          },
          'toWireType': function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
              }

              var getLength;
              var valueIsOfTypeString = (typeof value === 'string');

              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError('Cannot pass non-string to std::string');
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = function() {return lengthBytesUTF8(value);};
              } else {
                  getLength = function() {return value.length;};
              }

              // assumes 4-byte alignment
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;

              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1);
              } else {
                  if(valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                          var charCode = value.charCodeAt(i);
                          if (charCode > 255) {
                              _free(ptr);
                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                          }
                          HEAPU8[ptr + 4 + i] = charCode;
                      }
                  } else {
                      for (var i = 0; i < length; ++i) {
                          HEAPU8[ptr + 4 + i] = value[i];
                      }
                  }
              }

              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_std_wstring(rawType, charSize, name) {
      // nb. do not cache HEAPU16 and HEAPU32, they may be destroyed by emscripten_resize_heap().
      name = readLatin1String(name);
      var getHeap, shift;
      if (charSize === 2) {
          getHeap = function() { return HEAPU16; };
          shift = 1;
      } else if (charSize === 4) {
          getHeap = function() { return HEAPU32; };
          shift = 2;
      }
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var HEAP = getHeap();
              var length = HEAPU32[value >> 2];
              var a = new Array(length);
              var start = (value + 4) >> shift;
              for (var i = 0; i < length; ++i) {
                  a[i] = String.fromCharCode(HEAP[start + i]);
              }
              _free(value);
              return a.join('');
          },
          'toWireType': function(destructors, value) {
              // assumes 4-byte alignment
              var HEAP = getHeap();
              var length = value.length;
              var ptr = _malloc(4 + length * charSize);
              HEAPU32[ptr >> 2] = length;
              var start = (ptr + 4) >> shift;
              for (var i = 0; i < length; ++i) {
                  HEAP[start + i] = value.charCodeAt(i);
              }
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          isVoid: true, // void return values can be optimized out sometimes
          name: name,
          'argPackAdvance': 0,
          'fromWireType': function() {
              return undefined;
          },
          'toWireType': function(destructors, o) {
              // TODO: assert if anything else is given?
              return undefined;
          },
      });
    }

  function _emscripten_get_heap_size() {
      return HEAP8.length;
    }


  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
    }






  function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
      return value;
    }


  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }function _emscripten_resize_heap(requestedSize) {
      abortOnCannotGrowMemory(requestedSize);
    }
embind_init_charCodes();
BindingError = Module['BindingError'] = extendError(Error, 'BindingError');;
InternalError = Module['InternalError'] = extendError(Error, 'InternalError');;
init_ClassHandle();
init_RegisteredPointer();
init_embind();;
UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;
init_emval();;
var ASSERTIONS = false;

// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {String} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


// ASM_LIBRARY EXTERN PRIMITIVES: Int8Array,Int32Array


var asmGlobalArg = { "Int8Array": Int8Array, "Int16Array": Int16Array, "Int32Array": Int32Array, "Uint8Array": Uint8Array, "Uint16Array": Uint16Array }

var asmLibraryArg = {
  "a": abort,
  "b": setTempRet0,
  "c": getTempRet0,
  "d": ClassHandle,
  "e": ClassHandle_clone,
  "f": ClassHandle_delete,
  "g": ClassHandle_deleteLater,
  "h": ClassHandle_isAliasOf,
  "i": ClassHandle_isDeleted,
  "j": RegisteredClass,
  "k": RegisteredPointer,
  "l": RegisteredPointer_deleteObject,
  "m": RegisteredPointer_destructor,
  "n": RegisteredPointer_fromWireType,
  "o": RegisteredPointer_getPointee,
  "p": ___setErrNo,
  "q": __embind_register_bool,
  "r": __embind_register_class,
  "s": __embind_register_class_constructor,
  "t": __embind_register_emval,
  "u": __embind_register_float,
  "v": __embind_register_function,
  "w": __embind_register_integer,
  "x": __embind_register_memory_view,
  "y": __embind_register_std_string,
  "z": __embind_register_std_wstring,
  "A": __embind_register_void,
  "B": __emval_decref,
  "C": __emval_register,
  "D": _embind_repr,
  "E": _emscripten_get_heap_size,
  "F": _emscripten_memcpy_big,
  "G": _emscripten_resize_heap,
  "H": abortOnCannotGrowMemory,
  "I": attachFinalizer,
  "J": constNoSmartPtrRawPointerToWireType,
  "K": count_emval_handles,
  "L": craftInvokerFunction,
  "M": createNamedFunction,
  "N": detachFinalizer,
  "O": downcastPointer,
  "P": embind__requireFunction,
  "Q": embind_init_charCodes,
  "R": ensureOverloadTable,
  "S": exposePublicSymbol,
  "T": extendError,
  "U": floatReadValueFromPointer,
  "V": flushPendingDeletes,
  "W": genericPointerToWireType,
  "X": getBasestPointer,
  "Y": getInheritedInstance,
  "Z": getInheritedInstanceCount,
  "_": getLiveInheritedInstances,
  "$": getShiftFromSize,
  "aa": getTypeName,
  "ab": get_first_emval,
  "ac": heap32VectorToArray,
  "ad": init_ClassHandle,
  "ae": init_RegisteredPointer,
  "af": init_embind,
  "ag": init_emval,
  "ah": integerReadValueFromPointer,
  "ai": makeClassHandle,
  "aj": makeLegalFunctionName,
  "ak": new_,
  "al": nonConstNoSmartPtrRawPointerToWireType,
  "am": readLatin1String,
  "an": registerType,
  "ao": releaseClassHandle,
  "ap": replacePublicSymbol,
  "aq": runDestructor,
  "ar": runDestructors,
  "as": setDelayFunction,
  "at": shallowCopyInternalPointer,
  "au": simpleReadValueFromPointer,
  "av": throwBindingError,
  "aw": throwInstanceAlreadyDeleted,
  "ax": throwInternalError,
  "ay": throwUnboundTypeError,
  "az": upcastPointer,
  "aA": whenDependentTypesAreResolved,
  "aB": tempDoublePtr,
  "aC": DYNAMICTOP_PTR
}
// EMSCRIPTEN_START_ASM
var asm = (/** @suppress {uselessCode} */ function(global, env, buffer) {
'use asm';

  var HEAP8 = new global.Int8Array(buffer),
  HEAP16 = new global.Int16Array(buffer),
  HEAP32 = new global.Int32Array(buffer),
  HEAPU8 = new global.Uint8Array(buffer),
  HEAPU16 = new global.Uint16Array(buffer),
  tempDoublePtr=env.aB|0,
  DYNAMICTOP_PTR=env.aC|0,
  __THREW__ = 0,
  threwValue = 0,
  setjmpId = 0,
  tempInt = 0,
  tempBigInt = 0,
  tempBigIntS = 0,
  tempValue = 0,
  tempDouble = 0.0,
  abort=env.a,
  setTempRet0=env.b,
  getTempRet0=env.c,
  ClassHandle=env.d,
  ClassHandle_clone=env.e,
  ClassHandle_delete=env.f,
  ClassHandle_deleteLater=env.g,
  ClassHandle_isAliasOf=env.h,
  ClassHandle_isDeleted=env.i,
  RegisteredClass=env.j,
  RegisteredPointer=env.k,
  RegisteredPointer_deleteObject=env.l,
  RegisteredPointer_destructor=env.m,
  RegisteredPointer_fromWireType=env.n,
  RegisteredPointer_getPointee=env.o,
  ___setErrNo=env.p,
  __embind_register_bool=env.q,
  __embind_register_class=env.r,
  __embind_register_class_constructor=env.s,
  __embind_register_emval=env.t,
  __embind_register_float=env.u,
  __embind_register_function=env.v,
  __embind_register_integer=env.w,
  __embind_register_memory_view=env.x,
  __embind_register_std_string=env.y,
  __embind_register_std_wstring=env.z,
  __embind_register_void=env.A,
  __emval_decref=env.B,
  __emval_register=env.C,
  _embind_repr=env.D,
  _emscripten_get_heap_size=env.E,
  _emscripten_memcpy_big=env.F,
  _emscripten_resize_heap=env.G,
  abortOnCannotGrowMemory=env.H,
  attachFinalizer=env.I,
  constNoSmartPtrRawPointerToWireType=env.J,
  count_emval_handles=env.K,
  craftInvokerFunction=env.L,
  createNamedFunction=env.M,
  detachFinalizer=env.N,
  downcastPointer=env.O,
  embind__requireFunction=env.P,
  embind_init_charCodes=env.Q,
  ensureOverloadTable=env.R,
  exposePublicSymbol=env.S,
  extendError=env.T,
  floatReadValueFromPointer=env.U,
  flushPendingDeletes=env.V,
  genericPointerToWireType=env.W,
  getBasestPointer=env.X,
  getInheritedInstance=env.Y,
  getInheritedInstanceCount=env.Z,
  getLiveInheritedInstances=env._,
  getShiftFromSize=env.$,
  getTypeName=env.aa,
  get_first_emval=env.ab,
  heap32VectorToArray=env.ac,
  init_ClassHandle=env.ad,
  init_RegisteredPointer=env.ae,
  init_embind=env.af,
  init_emval=env.ag,
  integerReadValueFromPointer=env.ah,
  makeClassHandle=env.ai,
  makeLegalFunctionName=env.aj,
  new_=env.ak,
  nonConstNoSmartPtrRawPointerToWireType=env.al,
  readLatin1String=env.am,
  registerType=env.an,
  releaseClassHandle=env.ao,
  replacePublicSymbol=env.ap,
  runDestructor=env.aq,
  runDestructors=env.ar,
  setDelayFunction=env.as,
  shallowCopyInternalPointer=env.at,
  simpleReadValueFromPointer=env.au,
  throwBindingError=env.av,
  throwInstanceAlreadyDeleted=env.aw,
  throwInternalError=env.ax,
  throwUnboundTypeError=env.ay,
  upcastPointer=env.az,
  whenDependentTypesAreResolved=env.aA,
  STACKTOP = 3392,
  STACK_MAX = 5246272,
  tempFloat = 0.0;

// EMSCRIPTEN_START_FUNCS
  function globalCtors() {
    __GLOBAL__sub_I_chp_cpp();
    __GLOBAL__sub_I_bind_cpp();
  }
function stackAlloc(size) {
  size = size|0;
  var ret = 0;
  ret = STACKTOP;
  STACKTOP = (STACKTOP + size)|0;
  STACKTOP = (STACKTOP + 15)&-16;

  return ret|0;
}
function stackSave() {
  return STACKTOP|0;
}
function stackRestore(top) {
  top = top|0;
  STACKTOP = top;
}
function establishStackSpace(stackBase, stackMax) {
  stackBase = stackBase|0;
  stackMax = stackMax|0;
  STACKTOP = stackBase;
  STACK_MAX = stackMax;
}

function __Z4cnotR6QStatell($q,$b,$c) {
 $q = $q|0;
 $b = $b|0;
 $c = $c|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
 var $8 = 0, $9 = 0, $add = 0, $add74 = 0, $and = 0, $and13 = 0, $and24 = 0, $and29 = 0, $and3 = 0, $and35 = 0, $and41 = 0, $and57 = 0, $and63 = 0, $and69 = 0, $and7 = 0, $arrayidx = 0, $arrayidx10 = 0, $arrayidx11 = 0, $arrayidx12 = 0, $arrayidx18 = 0;
 var $arrayidx34 = 0, $arrayidx4 = 0, $arrayidx40 = 0, $arrayidx44 = 0, $arrayidx5 = 0, $arrayidx6 = 0, $arrayidx62 = 0, $arrayidx68 = 0, $arrayidx73 = 0, $cmp = 0, $cmp64 = 0, $i$065 = 0, $inc = 0, $mul = 0, $r = 0, $rem = 0, $rem75 = 0, $shr = 0, $shr1 = 0, $tobool = 0;
 var $tobool14 = 0, $tobool25 = 0, $tobool30 = 0, $tobool36 = 0, $tobool42 = 0, $tobool58 = 0, $tobool64 = 0, $tobool70 = 0, $x = 0, $xor = 0, $xor19 = 0, $z = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $shr = $b >> 5;
 $shr1 = $c >> 5;
 $and = $b & 31;
 $arrayidx = (((($q)) + 16|0) + ($and<<2)|0);
 $0 = HEAP32[$arrayidx>>2]|0;
 $and3 = $c & 31;
 $arrayidx4 = (((($q)) + 16|0) + ($and3<<2)|0);
 $1 = HEAP32[$arrayidx4>>2]|0;
 $2 = HEAP32[$q>>2]|0;
 $cmp64 = ($2|0)>(0);
 if (!($cmp64)) {
  return;
 }
 $x = ((($q)) + 4|0);
 $3 = HEAP32[$x>>2]|0;
 $z = ((($q)) + 8|0);
 $4 = HEAP32[$z>>2]|0;
 $r = ((($q)) + 12|0);
 $5 = HEAP32[$r>>2]|0;
 $i$065 = 0;
 while(1) {
  $arrayidx5 = (($3) + ($i$065<<2)|0);
  $6 = HEAP32[$arrayidx5>>2]|0;
  $arrayidx6 = (($6) + ($shr<<2)|0);
  $7 = HEAP32[$arrayidx6>>2]|0;
  $and7 = $7 & $0;
  $tobool = ($and7|0)==(0);
  $arrayidx10 = (($6) + ($shr1<<2)|0);
  if (!($tobool)) {
   $8 = HEAP32[$arrayidx10>>2]|0;
   $xor = $8 ^ $1;
   HEAP32[$arrayidx10>>2] = $xor;
  }
  $arrayidx11 = (($4) + ($i$065<<2)|0);
  $9 = HEAP32[$arrayidx11>>2]|0;
  $arrayidx12 = (($9) + ($shr1<<2)|0);
  $10 = HEAP32[$arrayidx12>>2]|0;
  $and13 = $10 & $1;
  $tobool14 = ($and13|0)==(0);
  $arrayidx18 = (($9) + ($shr<<2)|0);
  if (!($tobool14)) {
   $11 = HEAP32[$arrayidx18>>2]|0;
   $xor19 = $11 ^ $0;
   HEAP32[$arrayidx18>>2] = $xor19;
  }
  $12 = HEAP32[$arrayidx6>>2]|0;
  $and24 = $12 & $0;
  $tobool25 = ($and24|0)==(0);
  if (!($tobool25)) {
   $13 = HEAP32[$arrayidx12>>2]|0;
   $and29 = $13 & $1;
   $tobool30 = ($and29|0)==(0);
   if (!($tobool30)) {
    $arrayidx34 = (($6) + ($shr1<<2)|0);
    $14 = HEAP32[$arrayidx34>>2]|0;
    $and35 = $14 & $1;
    $tobool36 = ($and35|0)==(0);
    if (!($tobool36)) {
     $arrayidx40 = (($9) + ($shr<<2)|0);
     $15 = HEAP32[$arrayidx40>>2]|0;
     $and41 = $15 & $0;
     $tobool42 = ($and41|0)==(0);
     if (!($tobool42)) {
      $arrayidx44 = (($5) + ($i$065<<2)|0);
      $16 = HEAP32[$arrayidx44>>2]|0;
      $add = (($16) + 2)|0;
      $rem = (($add|0) % 4)&-1;
      HEAP32[$arrayidx44>>2] = $rem;
     }
    }
   }
   $17 = HEAP32[$arrayidx12>>2]|0;
   $and57 = $17 & $1;
   $tobool58 = ($and57|0)==(0);
   if (!($tobool58)) {
    $arrayidx62 = (($6) + ($shr1<<2)|0);
    $18 = HEAP32[$arrayidx62>>2]|0;
    $and63 = $18 & $1;
    $tobool64 = ($and63|0)==(0);
    if ($tobool64) {
     $arrayidx68 = (($9) + ($shr<<2)|0);
     $19 = HEAP32[$arrayidx68>>2]|0;
     $and69 = $19 & $0;
     $tobool70 = ($and69|0)==(0);
     if ($tobool70) {
      $arrayidx73 = (($5) + ($i$065<<2)|0);
      $20 = HEAP32[$arrayidx73>>2]|0;
      $add74 = (($20) + 2)|0;
      $rem75 = (($add74|0) % 4)&-1;
      HEAP32[$arrayidx73>>2] = $rem75;
     }
    }
   }
  }
  $inc = (($i$065) + 1)|0;
  $21 = HEAP32[$q>>2]|0;
  $mul = $21 << 1;
  $cmp = ($inc|0)<($mul|0);
  if ($cmp) {
   $i$065 = $inc;
  } else {
   break;
  }
 }
 return;
}
function __Z8hadamardR6QStatel($q,$b) {
 $q = $q|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $add = 0, $and = 0, $and18 = 0, $and26 = 0, $and30 = 0, $and9 = 0, $arrayidx = 0;
 var $arrayidx2 = 0, $arrayidx3 = 0, $arrayidx32 = 0, $arrayidx7 = 0, $arrayidx8 = 0, $cmp = 0, $cmp39 = 0, $i$040 = 0, $inc = 0, $mul = 0, $or$cond = 0, $r = 0, $rem = 0, $shr = 0, $tobool = 0, $tobool31 = 0, $x = 0, $xor = 0, $xor13 = 0, $xor17 = 0;
 var $xor22 = 0, $z = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $shr = $b >> 5;
 $and = $b & 31;
 $arrayidx = (((($q)) + 16|0) + ($and<<2)|0);
 $0 = HEAP32[$arrayidx>>2]|0;
 $1 = HEAP32[$q>>2]|0;
 $cmp39 = ($1|0)>(0);
 if (!($cmp39)) {
  return;
 }
 $x = ((($q)) + 4|0);
 $2 = HEAP32[$x>>2]|0;
 $z = ((($q)) + 8|0);
 $3 = HEAP32[$z>>2]|0;
 $r = ((($q)) + 12|0);
 $4 = HEAP32[$r>>2]|0;
 $i$040 = 0;
 while(1) {
  $arrayidx2 = (($2) + ($i$040<<2)|0);
  $5 = HEAP32[$arrayidx2>>2]|0;
  $arrayidx3 = (($5) + ($shr<<2)|0);
  $6 = HEAP32[$arrayidx3>>2]|0;
  $arrayidx7 = (($3) + ($i$040<<2)|0);
  $7 = HEAP32[$arrayidx7>>2]|0;
  $arrayidx8 = (($7) + ($shr<<2)|0);
  $8 = HEAP32[$arrayidx8>>2]|0;
  $xor = $8 ^ $6;
  $and9 = $xor & $0;
  $xor13 = $and9 ^ $6;
  HEAP32[$arrayidx3>>2] = $xor13;
  $9 = HEAP32[$arrayidx8>>2]|0;
  $xor17 = $9 ^ $6;
  $and18 = $xor17 & $0;
  $xor22 = $and18 ^ $9;
  HEAP32[$arrayidx8>>2] = $xor22;
  $10 = HEAP32[$arrayidx3>>2]|0;
  $and26 = $10 & $0;
  $tobool = ($and26|0)==(0);
  $and30 = $xor22 & $0;
  $tobool31 = ($and30|0)==(0);
  $or$cond = $tobool | $tobool31;
  if (!($or$cond)) {
   $arrayidx32 = (($4) + ($i$040<<2)|0);
   $11 = HEAP32[$arrayidx32>>2]|0;
   $add = (($11) + 2)|0;
   $rem = (($add|0) % 4)&-1;
   HEAP32[$arrayidx32>>2] = $rem;
  }
  $inc = (($i$040) + 1)|0;
  $12 = HEAP32[$q>>2]|0;
  $mul = $12 << 1;
  $cmp = ($inc|0)<($mul|0);
  if ($cmp) {
   $i$040 = $inc;
  } else {
   break;
  }
 }
 return;
}
function __Z5phaseR6QStatel($q,$b) {
 $q = $q|0;
 $b = $b|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $add = 0, $and = 0, $and4 = 0, $and7 = 0, $arrayidx = 0, $arrayidx17 = 0, $arrayidx18 = 0;
 var $arrayidx2 = 0, $arrayidx3 = 0, $arrayidx5 = 0, $arrayidx6 = 0, $arrayidx9 = 0, $cmp = 0, $cmp25 = 0, $i$026 = 0, $inc = 0, $mul = 0, $r = 0, $rem = 0, $shr = 0, $tobool = 0, $tobool8 = 0, $x = 0, $xor = 0, $z16 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $shr = $b >> 5;
 $and = $b & 31;
 $arrayidx = (((($q)) + 16|0) + ($and<<2)|0);
 $0 = HEAP32[$arrayidx>>2]|0;
 $1 = HEAP32[$q>>2]|0;
 $cmp25 = ($1|0)>(0);
 if (!($cmp25)) {
  return;
 }
 $x = ((($q)) + 4|0);
 $2 = HEAP32[$x>>2]|0;
 $z16 = ((($q)) + 8|0);
 $3 = HEAP32[$z16>>2]|0;
 $r = ((($q)) + 12|0);
 $4 = HEAP32[$r>>2]|0;
 $i$026 = 0;
 while(1) {
  $arrayidx2 = (($2) + ($i$026<<2)|0);
  $5 = HEAP32[$arrayidx2>>2]|0;
  $arrayidx3 = (($5) + ($shr<<2)|0);
  $6 = HEAP32[$arrayidx3>>2]|0;
  $and4 = $6 & $0;
  $tobool = ($and4|0)==(0);
  if (!($tobool)) {
   $arrayidx5 = (($3) + ($i$026<<2)|0);
   $7 = HEAP32[$arrayidx5>>2]|0;
   $arrayidx6 = (($7) + ($shr<<2)|0);
   $8 = HEAP32[$arrayidx6>>2]|0;
   $and7 = $8 & $0;
   $tobool8 = ($and7|0)==(0);
   if (!($tobool8)) {
    $arrayidx9 = (($4) + ($i$026<<2)|0);
    $9 = HEAP32[$arrayidx9>>2]|0;
    $add = (($9) + 2)|0;
    $rem = (($add|0) % 4)&-1;
    HEAP32[$arrayidx9>>2] = $rem;
   }
  }
  $arrayidx17 = (($3) + ($i$026<<2)|0);
  $10 = HEAP32[$arrayidx17>>2]|0;
  $arrayidx18 = (($10) + ($shr<<2)|0);
  $11 = HEAP32[$arrayidx18>>2]|0;
  $xor = $11 ^ $and4;
  HEAP32[$arrayidx18>>2] = $xor;
  $inc = (($i$026) + 1)|0;
  $12 = HEAP32[$q>>2]|0;
  $mul = $12 << 1;
  $cmp = ($inc|0)<($mul|0);
  if ($cmp) {
   $i$026 = $inc;
  } else {
   break;
  }
 }
 return;
}
function __Z7rowcopyR6QStatell($q,$i,$k) {
 $q = $q|0;
 $i = $i|0;
 $k = $k|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $arrayidx = 0, $arrayidx1 = 0, $arrayidx10 = 0, $arrayidx12 = 0, $arrayidx3 = 0, $arrayidx4 = 0, $arrayidx5 = 0, $arrayidx6 = 0;
 var $arrayidx8 = 0, $arrayidx9 = 0, $cmp = 0, $cmp16 = 0, $inc = 0, $j$017 = 0, $over32 = 0, $r = 0, $x = 0, $z = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $over32 = ((($q)) + 144|0);
 $0 = HEAP32[$over32>>2]|0;
 $cmp16 = ($0|0)>(0);
 if (!($cmp16)) {
  $r = ((($q)) + 12|0);
  $10 = HEAP32[$r>>2]|0;
  $arrayidx10 = (($10) + ($k<<2)|0);
  $11 = HEAP32[$arrayidx10>>2]|0;
  $arrayidx12 = (($10) + ($i<<2)|0);
  HEAP32[$arrayidx12>>2] = $11;
  return;
 }
 $x = ((($q)) + 4|0);
 $1 = HEAP32[$x>>2]|0;
 $arrayidx = (($1) + ($k<<2)|0);
 $2 = HEAP32[$arrayidx>>2]|0;
 $arrayidx3 = (($1) + ($i<<2)|0);
 $3 = HEAP32[$arrayidx3>>2]|0;
 $z = ((($q)) + 8|0);
 $4 = HEAP32[$z>>2]|0;
 $arrayidx5 = (($4) + ($k<<2)|0);
 $5 = HEAP32[$arrayidx5>>2]|0;
 $arrayidx8 = (($4) + ($i<<2)|0);
 $6 = HEAP32[$arrayidx8>>2]|0;
 $j$017 = 0;
 while(1) {
  $arrayidx1 = (($2) + ($j$017<<2)|0);
  $7 = HEAP32[$arrayidx1>>2]|0;
  $arrayidx4 = (($3) + ($j$017<<2)|0);
  HEAP32[$arrayidx4>>2] = $7;
  $arrayidx6 = (($5) + ($j$017<<2)|0);
  $8 = HEAP32[$arrayidx6>>2]|0;
  $arrayidx9 = (($6) + ($j$017<<2)|0);
  HEAP32[$arrayidx9>>2] = $8;
  $inc = (($j$017) + 1)|0;
  $9 = HEAP32[$over32>>2]|0;
  $cmp = ($inc|0)<($9|0);
  if ($cmp) {
   $j$017 = $inc;
  } else {
   break;
  }
 }
 $r = ((($q)) + 12|0);
 $10 = HEAP32[$r>>2]|0;
 $arrayidx10 = (($10) + ($k<<2)|0);
 $11 = HEAP32[$arrayidx10>>2]|0;
 $arrayidx12 = (($10) + ($i<<2)|0);
 HEAP32[$arrayidx12>>2] = $11;
 return;
}
function __Z6rowsetR6QStatell($q,$i,$b) {
 $q = $q|0;
 $i = $i|0;
 $b = $b|0;
 var $$sink = 0, $$sink$in = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $and14$pn = 0, $arrayidx = 0, $arrayidx1 = 0, $arrayidx18 = 0, $arrayidx19 = 0, $arrayidx2 = 0, $arrayidx3 = 0, $arrayidx4 = 0;
 var $cmp = 0, $cmp25 = 0, $cmp5 = 0, $inc = 0, $j$026 = 0, $over32 = 0, $r = 0, $shr11$sink = 0, $shr11$sink$in = 0, $sub = 0, $x = 0, $x7 = 0, $z = 0, $z17 = 0, $z17$sink = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $over32 = ((($q)) + 144|0);
 $0 = HEAP32[$over32>>2]|0;
 $cmp25 = ($0|0)>(0);
 if ($cmp25) {
  $x = ((($q)) + 4|0);
  $1 = HEAP32[$x>>2]|0;
  $arrayidx = (($1) + ($i<<2)|0);
  $2 = HEAP32[$arrayidx>>2]|0;
  $z = ((($q)) + 8|0);
  $3 = HEAP32[$z>>2]|0;
  $arrayidx2 = (($3) + ($i<<2)|0);
  $4 = HEAP32[$arrayidx2>>2]|0;
  $j$026 = 0;
  while(1) {
   $arrayidx1 = (($2) + ($j$026<<2)|0);
   HEAP32[$arrayidx1>>2] = 0;
   $arrayidx3 = (($4) + ($j$026<<2)|0);
   HEAP32[$arrayidx3>>2] = 0;
   $inc = (($j$026) + 1)|0;
   $5 = HEAP32[$over32>>2]|0;
   $cmp = ($inc|0)<($5|0);
   if ($cmp) {
    $j$026 = $inc;
   } else {
    break;
   }
  }
 }
 $r = ((($q)) + 12|0);
 $6 = HEAP32[$r>>2]|0;
 $arrayidx4 = (($6) + ($i<<2)|0);
 HEAP32[$arrayidx4>>2] = 0;
 $7 = HEAP32[$q>>2]|0;
 $cmp5 = ($7|0)>($b|0);
 $sub = (($b) - ($7))|0;
 $z17 = ((($q)) + 8|0);
 $x7 = ((($q)) + 4|0);
 $z17$sink = $cmp5 ? $x7 : $z17;
 $shr11$sink$in = $cmp5 ? $b : $sub;
 $and14$pn = $shr11$sink$in & 31;
 $$sink$in = (((($q)) + 16|0) + ($and14$pn<<2)|0);
 $$sink = HEAP32[$$sink$in>>2]|0;
 $shr11$sink = $shr11$sink$in >> 5;
 $8 = HEAP32[$z17$sink>>2]|0;
 $arrayidx18 = (($8) + ($i<<2)|0);
 $9 = HEAP32[$arrayidx18>>2]|0;
 $arrayidx19 = (($9) + ($shr11$sink<<2)|0);
 HEAP32[$arrayidx19>>2] = $$sink;
 return;
}
function __Z8cliffordR6QStatell($q,$i,$k) {
 $q = $q|0;
 $i = $i|0;
 $k = $k|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0;
 var $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $add = 0, $add126 = 0, $add129 = 0, $and = 0, $and113 = 0, $and14 = 0, $and32 = 0, $and46 = 0, $and52 = 0, $and58 = 0, $and87 = 0;
 var $and93 = 0, $and99 = 0, $arrayidx = 0, $arrayidx111 = 0, $arrayidx112 = 0, $arrayidx12 = 0, $arrayidx123 = 0, $arrayidx125 = 0, $arrayidx13 = 0, $arrayidx30 = 0, $arrayidx31 = 0, $arrayidx44 = 0, $arrayidx45 = 0, $arrayidx5 = 0, $arrayidx50 = 0, $arrayidx51 = 0, $arrayidx56 = 0, $arrayidx57 = 0, $arrayidx6 = 0, $arrayidx85 = 0;
 var $arrayidx86 = 0, $arrayidx91 = 0, $arrayidx92 = 0, $arrayidx97 = 0, $arrayidx98 = 0, $cmp = 0, $cmp100 = 0, $cmp127 = 0, $dec = 0, $dec116 = 0, $dec75 = 0, $e$0$lcssa = 0, $e$0102 = 0, $e$199 = 0, $e$3$ph = 0, $e$7 = 0, $exitcond = 0, $inc = 0, $inc102 = 0, $inc119 = 0;
 var $inc121 = 0, $inc61 = 0, $j$0101 = 0, $l$098 = 0, $not$tobool59 = 0, $over32 = 0, $r = 0, $rem = 0, $retval$0 = 0, $spec$select = 0, $spec$select90 = 0, $spec$select91 = 0, $spec$select92 = 0, $spec$select93 = 0, $spec$select94 = 0, $tobool = 0, $tobool100 = 0, $tobool114 = 0, $tobool15 = 0, $tobool33 = 0;
 var $tobool47 = 0, $tobool53 = 0, $tobool59 = 0, $tobool88 = 0, $tobool94 = 0, $x = 0, $z43 = 0, $z84 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $over32 = ((($q)) + 144|0);
 $0 = HEAP32[$over32>>2]|0;
 $cmp100 = ($0|0)>(0);
 if (!($cmp100)) {
  $e$0$lcssa = 0;
  $r = ((($q)) + 12|0);
  $26 = HEAP32[$r>>2]|0;
  $arrayidx123 = (($26) + ($i<<2)|0);
  $27 = HEAP32[$arrayidx123>>2]|0;
  $add = (($27) + ($e$0$lcssa))|0;
  $arrayidx125 = (($26) + ($k<<2)|0);
  $28 = HEAP32[$arrayidx125>>2]|0;
  $add126 = (($add) + ($28))|0;
  $rem = (($add126|0) % 4)&-1;
  $cmp127 = ($rem|0)>(-1);
  $add129 = (($rem) + 4)|0;
  $retval$0 = $cmp127 ? $rem : $add129;
  return ($retval$0|0);
 }
 $x = ((($q)) + 4|0);
 $1 = HEAP32[$x>>2]|0;
 $arrayidx5 = (($1) + ($k<<2)|0);
 $2 = HEAP32[$arrayidx5>>2]|0;
 $z84 = ((($q)) + 8|0);
 $3 = HEAP32[$z84>>2]|0;
 $arrayidx85 = (($3) + ($k<<2)|0);
 $4 = HEAP32[$arrayidx85>>2]|0;
 $arrayidx91 = (($1) + ($i<<2)|0);
 $arrayidx12 = (($1) + ($i<<2)|0);
 $arrayidx30 = (($3) + ($i<<2)|0);
 $z43 = ((($q)) + 8|0);
 $5 = HEAP32[$z43>>2]|0;
 $arrayidx44 = (($5) + ($k<<2)|0);
 $arrayidx97 = (($3) + ($i<<2)|0);
 $arrayidx111 = (($3) + ($i<<2)|0);
 $arrayidx50 = (($1) + ($i<<2)|0);
 $arrayidx56 = (($5) + ($i<<2)|0);
 $6 = HEAP32[$over32>>2]|0;
 $e$0102 = 0;$j$0101 = 0;
 while(1) {
  $arrayidx6 = (($2) + ($j$0101<<2)|0);
  $7 = HEAP32[$arrayidx6>>2]|0;
  $arrayidx86 = (($4) + ($j$0101<<2)|0);
  $8 = HEAP32[$arrayidx86>>2]|0;
  $e$199 = $e$0102;$l$098 = 0;
  while(1) {
   $arrayidx = (((($q)) + 16|0) + ($l$098<<2)|0);
   $9 = HEAP32[$arrayidx>>2]|0;
   $and = $7 & $9;
   $tobool = ($and|0)==(0);
   $and87 = $8 & $9;
   $tobool88 = ($and87|0)==(0);
   do {
    if ($tobool) {
     if ($tobool88) {
      $e$7 = $e$199;
     } else {
      $20 = HEAP32[$arrayidx91>>2]|0;
      $arrayidx92 = (($20) + ($j$0101<<2)|0);
      $21 = HEAP32[$arrayidx92>>2]|0;
      $and93 = $21 & $9;
      $tobool94 = ($and93|0)==(0);
      if ($tobool94) {
       $e$7 = $e$199;
      } else {
       $22 = HEAP32[$arrayidx97>>2]|0;
       $arrayidx98 = (($22) + ($j$0101<<2)|0);
       $23 = HEAP32[$arrayidx98>>2]|0;
       $and99 = $23 & $9;
       $tobool100 = ($and99|0)==(0);
       $inc102 = $tobool100&1;
       $spec$select93 = (($e$199) + ($inc102))|0;
       $24 = HEAP32[$arrayidx111>>2]|0;
       $arrayidx112 = (($24) + ($j$0101<<2)|0);
       $25 = HEAP32[$arrayidx112>>2]|0;
       $and113 = $25 & $9;
       $tobool114 = ($and113|0)!=(0);
       $dec116 = $tobool114 << 31 >> 31;
       $spec$select94 = (($spec$select93) + ($dec116))|0;
       $e$7 = $spec$select94;
      }
     }
    } else {
     do {
      if ($tobool88) {
       $10 = HEAP32[$arrayidx12>>2]|0;
       $arrayidx13 = (($10) + ($j$0101<<2)|0);
       $11 = HEAP32[$arrayidx13>>2]|0;
       $and14 = $11 & $9;
       $tobool15 = ($and14|0)==(0);
       $12 = HEAP32[$arrayidx30>>2]|0;
       $arrayidx31 = (($12) + ($j$0101<<2)|0);
       $13 = HEAP32[$arrayidx31>>2]|0;
       $and32 = $13 & $9;
       $tobool33 = ($and32|0)!=(0);
       if ($tobool15) {
        $dec = $tobool33 << 31 >> 31;
        $spec$select90 = (($e$199) + ($dec))|0;
        $e$3$ph = $spec$select90;
        break;
       } else {
        $inc = $tobool33&1;
        $spec$select = (($e$199) + ($inc))|0;
        $e$3$ph = $spec$select;
        break;
       }
      } else {
       $e$3$ph = $e$199;
      }
     } while(0);
     $14 = HEAP32[$arrayidx44>>2]|0;
     $arrayidx45 = (($14) + ($j$0101<<2)|0);
     $15 = HEAP32[$arrayidx45>>2]|0;
     $and46 = $15 & $9;
     $tobool47 = ($and46|0)==(0);
     if ($tobool47) {
      $e$7 = $e$3$ph;
     } else {
      $16 = HEAP32[$arrayidx50>>2]|0;
      $arrayidx51 = (($16) + ($j$0101<<2)|0);
      $17 = HEAP32[$arrayidx51>>2]|0;
      $and52 = $17 & $9;
      $tobool53 = ($and52|0)==(0);
      $18 = HEAP32[$arrayidx56>>2]|0;
      $arrayidx57 = (($18) + ($j$0101<<2)|0);
      $19 = HEAP32[$arrayidx57>>2]|0;
      $and58 = $19 & $9;
      $tobool59 = ($and58|0)==(0);
      if ($tobool53) {
       $not$tobool59 = $tobool59 ^ 1;
       $inc61 = $not$tobool59&1;
       $spec$select91 = (($e$3$ph) + ($inc61))|0;
       $e$7 = $spec$select91;
       break;
      } else {
       $dec75 = $tobool59 << 31 >> 31;
       $spec$select92 = (($e$3$ph) + ($dec75))|0;
       $e$7 = $spec$select92;
       break;
      }
     }
    }
   } while(0);
   $inc119 = (($l$098) + 1)|0;
   $exitcond = ($inc119|0)==(32);
   if ($exitcond) {
    break;
   } else {
    $e$199 = $e$7;$l$098 = $inc119;
   }
  }
  $inc121 = (($j$0101) + 1)|0;
  $cmp = ($inc121|0)<($6|0);
  if ($cmp) {
   $e$0102 = $e$7;$j$0101 = $inc121;
  } else {
   $e$0$lcssa = $e$7;
   break;
  }
 }
 $r = ((($q)) + 12|0);
 $26 = HEAP32[$r>>2]|0;
 $arrayidx123 = (($26) + ($i<<2)|0);
 $27 = HEAP32[$arrayidx123>>2]|0;
 $add = (($27) + ($e$0$lcssa))|0;
 $arrayidx125 = (($26) + ($k<<2)|0);
 $28 = HEAP32[$arrayidx125>>2]|0;
 $add126 = (($add) + ($28))|0;
 $rem = (($add126|0) % 4)&-1;
 $cmp127 = ($rem|0)>(-1);
 $add129 = (($rem) + 4)|0;
 $retval$0 = $cmp127 ? $rem : $add129;
 return ($retval$0|0);
}
function __Z7rowmultR6QStatell($q,$i,$k) {
 $q = $q|0;
 $i = $i|0;
 $k = $k|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $arrayidx = 0, $arrayidx1 = 0, $arrayidx10 = 0, $arrayidx2 = 0, $arrayidx4 = 0, $arrayidx5 = 0, $arrayidx6 = 0;
 var $arrayidx7 = 0, $arrayidx9 = 0, $call = 0, $cmp = 0, $cmp18 = 0, $inc = 0, $j$019 = 0, $over32 = 0, $r = 0, $x = 0, $xor = 0, $xor11 = 0, $z = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__Z8cliffordR6QStatell($q,$i,$k)|0);
 $r = ((($q)) + 12|0);
 $0 = HEAP32[$r>>2]|0;
 $arrayidx = (($0) + ($i<<2)|0);
 HEAP32[$arrayidx>>2] = $call;
 $over32 = ((($q)) + 144|0);
 $1 = HEAP32[$over32>>2]|0;
 $cmp18 = ($1|0)>(0);
 if (!($cmp18)) {
  return;
 }
 $x = ((($q)) + 4|0);
 $2 = HEAP32[$x>>2]|0;
 $arrayidx1 = (($2) + ($k<<2)|0);
 $3 = HEAP32[$arrayidx1>>2]|0;
 $arrayidx4 = (($2) + ($i<<2)|0);
 $4 = HEAP32[$arrayidx4>>2]|0;
 $z = ((($q)) + 8|0);
 $5 = HEAP32[$z>>2]|0;
 $arrayidx6 = (($5) + ($k<<2)|0);
 $6 = HEAP32[$arrayidx6>>2]|0;
 $arrayidx9 = (($5) + ($i<<2)|0);
 $7 = HEAP32[$arrayidx9>>2]|0;
 $j$019 = 0;
 while(1) {
  $arrayidx2 = (($3) + ($j$019<<2)|0);
  $8 = HEAP32[$arrayidx2>>2]|0;
  $arrayidx5 = (($4) + ($j$019<<2)|0);
  $9 = HEAP32[$arrayidx5>>2]|0;
  $xor = $9 ^ $8;
  HEAP32[$arrayidx5>>2] = $xor;
  $arrayidx7 = (($6) + ($j$019<<2)|0);
  $10 = HEAP32[$arrayidx7>>2]|0;
  $arrayidx10 = (($7) + ($j$019<<2)|0);
  $11 = HEAP32[$arrayidx10>>2]|0;
  $xor11 = $11 ^ $10;
  HEAP32[$arrayidx10>>2] = $xor11;
  $inc = (($j$019) + 1)|0;
  $12 = HEAP32[$over32>>2]|0;
  $cmp = ($inc|0)<($12|0);
  if ($cmp) {
   $j$019 = $inc;
  } else {
   break;
  }
 }
 return;
}
function __Z7measureR6QStatelib($q,$b,$sup,$random_result) {
 $q = $q|0;
 $b = $b|0;
 $sup = $sup|0;
 $random_result = $random_result|0;
 var $$ = 0, $$64 = 0, $$lcssa = 0, $$lcssa66 = 0, $$lcssa67 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0;
 var $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $add = 0, $add12 = 0, $add14 = 0, $add16 = 0, $add19 = 0, $add39 = 0, $add65 = 0;
 var $add80 = 0, $and = 0, $and30 = 0, $and5 = 0, $and55 = 0, $and74 = 0, $arrayidx = 0, $arrayidx20 = 0, $arrayidx28 = 0, $arrayidx29 = 0, $arrayidx3 = 0, $arrayidx4 = 0, $arrayidx40 = 0, $arrayidx53 = 0, $arrayidx54 = 0, $arrayidx72 = 0, $arrayidx73 = 0, $arrayidx88 = 0, $cmp = 0, $cmp24 = 0;
 var $cmp2472 = 0, $cmp26 = 0, $cmp50 = 0, $cmp5078 = 0, $cmp69 = 0, $cmp6975 = 0, $cmp82 = 0, $cond = 0, $i$073 = 0, $i$1 = 0, $i$174 = 0, $i$176 = 0, $inc = 0, $inc35 = 0, $inc60 = 0, $m$0$lcssa = 0, $m$079 = 0, $mul = 0, $mul23 = 0, $mul63 = 0;
 var $mul78 = 0, $mul87 = 0, $p$083 = 0, $r = 0, $r85 = 0, $retval$0 = 0, $shr = 0, $tobool = 0, $tobool31 = 0, $tobool41 = 0, $tobool46 = 0, $tobool56 = 0, $tobool75 = 0, $tobool89 = 0, $x = 0, $x27 = 0, $x52 = 0, $x71 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $shr = $b >> 5;
 $and = $b & 31;
 $arrayidx = (((($q)) + 16|0) + ($and<<2)|0);
 $0 = HEAP32[$arrayidx>>2]|0;
 $1 = HEAP32[$q>>2]|0;
 $cmp82 = ($1|0)>(0);
 L1: do {
  if ($cmp82) {
   $x = ((($q)) + 4|0);
   $2 = HEAP32[$x>>2]|0;
   $3 = HEAP32[$q>>2]|0;
   $4 = $1;$p$083 = 0;
   while(1) {
    $add = (($4) + ($p$083))|0;
    $arrayidx3 = (($2) + ($add<<2)|0);
    $5 = HEAP32[$arrayidx3>>2]|0;
    $arrayidx4 = (($5) + ($shr<<2)|0);
    $6 = HEAP32[$arrayidx4>>2]|0;
    $and5 = $6 & $0;
    $tobool = ($and5|0)==(0);
    if (!($tobool)) {
     break;
    }
    $inc = (($p$083) + 1)|0;
    $cmp = ($inc|0)<($3|0);
    if ($cmp) {
     $4 = $3;$p$083 = $inc;
    } else {
     $$lcssa67 = $3;
     break L1;
    }
   }
   $add12 = (($4) + ($p$083))|0;
   __Z7rowcopyR6QStatell($q,$p$083,$add12);
   $7 = HEAP32[$q>>2]|0;
   $add14 = (($7) + ($p$083))|0;
   $add16 = (($7) + ($b))|0;
   __Z6rowsetR6QStatell($q,$add14,$add16);
   $cond = $random_result&1;
   $mul = $cond << 1;
   $r = ((($q)) + 12|0);
   $8 = HEAP32[$r>>2]|0;
   $9 = HEAP32[$q>>2]|0;
   $add19 = (($9) + ($p$083))|0;
   $arrayidx20 = (($8) + ($add19<<2)|0);
   HEAP32[$arrayidx20>>2] = $mul;
   $10 = HEAP32[$q>>2]|0;
   $cmp2472 = ($10|0)>(0);
   if ($cmp2472) {
    $x27 = ((($q)) + 4|0);
    $i$073 = 0;
    while(1) {
     $cmp26 = ($i$073|0)==($p$083|0);
     if (!($cmp26)) {
      $11 = HEAP32[$x27>>2]|0;
      $arrayidx28 = (($11) + ($i$073<<2)|0);
      $12 = HEAP32[$arrayidx28>>2]|0;
      $arrayidx29 = (($12) + ($shr<<2)|0);
      $13 = HEAP32[$arrayidx29>>2]|0;
      $and30 = $13 & $0;
      $tobool31 = ($and30|0)==(0);
      if (!($tobool31)) {
       __Z7rowmultR6QStatell($q,$i$073,$p$083);
      }
     }
     $inc35 = (($i$073) + 1)|0;
     $14 = HEAP32[$q>>2]|0;
     $mul23 = $14 << 1;
     $cmp24 = ($inc35|0)<($mul23|0);
     if ($cmp24) {
      $i$073 = $inc35;
     } else {
      $$lcssa = $14;
      break;
     }
    }
   } else {
    $$lcssa = $10;
   }
   $15 = HEAP32[$r>>2]|0;
   $add39 = (($$lcssa) + ($p$083))|0;
   $arrayidx40 = (($15) + ($add39<<2)|0);
   $16 = HEAP32[$arrayidx40>>2]|0;
   $tobool41 = ($16|0)==(0);
   $$ = $tobool41 ? 2 : 3;
   $retval$0 = $$;
   return ($retval$0|0);
  } else {
   $$lcssa67 = $1;
  }
 } while(0);
 $tobool46 = ($sup|0)==(0);
 if (!($tobool46)) {
  $retval$0 = 0;
  return ($retval$0|0);
 }
 $cmp5078 = ($$lcssa67|0)>(0);
 L21: do {
  if ($cmp5078) {
   $x52 = ((($q)) + 4|0);
   $17 = HEAP32[$x52>>2]|0;
   $m$079 = 0;
   while(1) {
    $arrayidx53 = (($17) + ($m$079<<2)|0);
    $18 = HEAP32[$arrayidx53>>2]|0;
    $arrayidx54 = (($18) + ($shr<<2)|0);
    $19 = HEAP32[$arrayidx54>>2]|0;
    $and55 = $19 & $0;
    $tobool56 = ($and55|0)==(0);
    if (!($tobool56)) {
     $m$0$lcssa = $m$079;
     break L21;
    }
    $inc60 = (($m$079) + 1)|0;
    $cmp50 = ($inc60|0)<($$lcssa67|0);
    if ($cmp50) {
     $m$079 = $inc60;
    } else {
     $m$0$lcssa = $inc60;
     break;
    }
   }
  } else {
   $m$0$lcssa = 0;
  }
 } while(0);
 $mul63 = $$lcssa67 << 1;
 $add65 = (($m$0$lcssa) + ($$lcssa67))|0;
 __Z7rowcopyR6QStatell($q,$mul63,$add65);
 $i$174 = (($m$0$lcssa) + 1)|0;
 $20 = HEAP32[$q>>2]|0;
 $cmp6975 = ($i$174|0)<($20|0);
 if ($cmp6975) {
  $x71 = ((($q)) + 4|0);
  $24 = $20;$i$176 = $i$174;
  while(1) {
   $21 = HEAP32[$x71>>2]|0;
   $arrayidx72 = (($21) + ($i$176<<2)|0);
   $22 = HEAP32[$arrayidx72>>2]|0;
   $arrayidx73 = (($22) + ($shr<<2)|0);
   $23 = HEAP32[$arrayidx73>>2]|0;
   $and74 = $23 & $0;
   $tobool75 = ($and74|0)==(0);
   if (!($tobool75)) {
    $add80 = (($i$176) + ($24))|0;
    $mul78 = $24 << 1;
    __Z7rowmultR6QStatell($q,$mul78,$add80);
   }
   $i$1 = (($i$176) + 1)|0;
   $25 = HEAP32[$q>>2]|0;
   $cmp69 = ($i$1|0)<($25|0);
   if ($cmp69) {
    $24 = $25;$i$176 = $i$1;
   } else {
    $$lcssa66 = $25;
    break;
   }
  }
 } else {
  $$lcssa66 = $20;
 }
 $r85 = ((($q)) + 12|0);
 $26 = HEAP32[$r85>>2]|0;
 $mul87 = $$lcssa66 << 1;
 $arrayidx88 = (($26) + ($mul87<<2)|0);
 $27 = HEAP32[$arrayidx88>>2]|0;
 $tobool89 = ($27|0)!=(0);
 $$64 = $tobool89&1;
 $retval$0 = $$64;
 return ($retval$0|0);
}
function __Z9initstae_R6QStatel($q,$n) {
 $q = $q|0;
 $n = $n|0;
 var $$sink = 0, $$sink$in = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $add = 0, $add15 = 0, $add24 = 0, $add2455 = 0, $and65$pn = 0, $and65$pn$in = 0, $arrayidx = 0, $arrayidx20 = 0, $arrayidx20$1 = 0, $arrayidx20$10 = 0, $arrayidx20$11 = 0, $arrayidx20$12 = 0, $arrayidx20$13 = 0, $arrayidx20$14 = 0, $arrayidx20$15 = 0, $arrayidx20$16 = 0, $arrayidx20$17 = 0, $arrayidx20$18 = 0, $arrayidx20$19 = 0, $arrayidx20$2 = 0;
 var $arrayidx20$20 = 0, $arrayidx20$21 = 0, $arrayidx20$22 = 0, $arrayidx20$23 = 0, $arrayidx20$24 = 0, $arrayidx20$25 = 0, $arrayidx20$26 = 0, $arrayidx20$27 = 0, $arrayidx20$28 = 0, $arrayidx20$29 = 0, $arrayidx20$3 = 0, $arrayidx20$30 = 0, $arrayidx20$4 = 0, $arrayidx20$5 = 0, $arrayidx20$6 = 0, $arrayidx20$7 = 0, $arrayidx20$8 = 0, $arrayidx20$9 = 0, $arrayidx31 = 0, $arrayidx36 = 0;
 var $arrayidx42 = 0, $arrayidx43 = 0, $arrayidx45 = 0, $arrayidx46 = 0, $arrayidx55 = 0, $arrayidx57 = 0, $arrayidx68 = 0, $arrayidx70 = 0, $arrayidx70$sink = 0, $arrayidx73 = 0, $call = 0, $call13 = 0, $call29 = 0, $call34 = 0, $call8 = 0, $cmp25 = 0, $cmp2556 = 0, $cmp39 = 0, $cmp3952 = 0, $cmp51 = 0;
 var $cmp60 = 0, $i$157 = 0, $inc48 = 0, $inc75 = 0, $j$053 = 0, $mul = 0, $mul23 = 0, $mul2354 = 0, $mul28 = 0, $mul59 = 0, $over32 = 0, $r = 0, $shr = 0, $shr69 = 0, $sub63 = 0, $x = 0, $z = 0, label = 0, sp = 0;
 sp = STACKTOP;
 HEAP32[$q>>2] = $n;
 $mul = $n << 3;
 $add = $mul | 4;
 $call = (_malloc($add)|0);
 $x = ((($q)) + 4|0);
 HEAP32[$x>>2] = $call;
 $call8 = (_malloc($add)|0);
 $z = ((($q)) + 8|0);
 HEAP32[$z>>2] = $call8;
 $call13 = (_malloc($add)|0);
 $r = ((($q)) + 12|0);
 HEAP32[$r>>2] = $call13;
 $shr = $n >> 5;
 $add15 = (($shr) + 1)|0;
 $over32 = ((($q)) + 144|0);
 HEAP32[$over32>>2] = $add15;
 $arrayidx = ((($q)) + 16|0);
 HEAP32[$arrayidx>>2] = 1;
 $arrayidx20 = ((($q)) + 20|0);
 HEAP32[$arrayidx20>>2] = 2;
 $arrayidx20$1 = ((($q)) + 24|0);
 HEAP32[$arrayidx20$1>>2] = 4;
 $arrayidx20$2 = ((($q)) + 28|0);
 HEAP32[$arrayidx20$2>>2] = 8;
 $arrayidx20$3 = ((($q)) + 32|0);
 HEAP32[$arrayidx20$3>>2] = 16;
 $arrayidx20$4 = ((($q)) + 36|0);
 HEAP32[$arrayidx20$4>>2] = 32;
 $arrayidx20$5 = ((($q)) + 40|0);
 HEAP32[$arrayidx20$5>>2] = 64;
 $arrayidx20$6 = ((($q)) + 44|0);
 HEAP32[$arrayidx20$6>>2] = 128;
 $arrayidx20$7 = ((($q)) + 48|0);
 HEAP32[$arrayidx20$7>>2] = 256;
 $arrayidx20$8 = ((($q)) + 52|0);
 HEAP32[$arrayidx20$8>>2] = 512;
 $arrayidx20$9 = ((($q)) + 56|0);
 HEAP32[$arrayidx20$9>>2] = 1024;
 $arrayidx20$10 = ((($q)) + 60|0);
 HEAP32[$arrayidx20$10>>2] = 2048;
 $arrayidx20$11 = ((($q)) + 64|0);
 HEAP32[$arrayidx20$11>>2] = 4096;
 $arrayidx20$12 = ((($q)) + 68|0);
 HEAP32[$arrayidx20$12>>2] = 8192;
 $arrayidx20$13 = ((($q)) + 72|0);
 HEAP32[$arrayidx20$13>>2] = 16384;
 $arrayidx20$14 = ((($q)) + 76|0);
 HEAP32[$arrayidx20$14>>2] = 32768;
 $arrayidx20$15 = ((($q)) + 80|0);
 HEAP32[$arrayidx20$15>>2] = 65536;
 $arrayidx20$16 = ((($q)) + 84|0);
 HEAP32[$arrayidx20$16>>2] = 131072;
 $arrayidx20$17 = ((($q)) + 88|0);
 HEAP32[$arrayidx20$17>>2] = 262144;
 $arrayidx20$18 = ((($q)) + 92|0);
 HEAP32[$arrayidx20$18>>2] = 524288;
 $arrayidx20$19 = ((($q)) + 96|0);
 HEAP32[$arrayidx20$19>>2] = 1048576;
 $arrayidx20$20 = ((($q)) + 100|0);
 HEAP32[$arrayidx20$20>>2] = 2097152;
 $arrayidx20$21 = ((($q)) + 104|0);
 HEAP32[$arrayidx20$21>>2] = 4194304;
 $arrayidx20$22 = ((($q)) + 108|0);
 HEAP32[$arrayidx20$22>>2] = 8388608;
 $arrayidx20$23 = ((($q)) + 112|0);
 HEAP32[$arrayidx20$23>>2] = 16777216;
 $arrayidx20$24 = ((($q)) + 116|0);
 HEAP32[$arrayidx20$24>>2] = 33554432;
 $arrayidx20$25 = ((($q)) + 120|0);
 HEAP32[$arrayidx20$25>>2] = 67108864;
 $arrayidx20$26 = ((($q)) + 124|0);
 HEAP32[$arrayidx20$26>>2] = 134217728;
 $arrayidx20$27 = ((($q)) + 128|0);
 HEAP32[$arrayidx20$27>>2] = 268435456;
 $arrayidx20$28 = ((($q)) + 132|0);
 HEAP32[$arrayidx20$28>>2] = 536870912;
 $arrayidx20$29 = ((($q)) + 136|0);
 HEAP32[$arrayidx20$29>>2] = 1073741824;
 $arrayidx20$30 = ((($q)) + 140|0);
 HEAP32[$arrayidx20$30>>2] = -2147483648;
 $0 = HEAP32[$q>>2]|0;
 $mul2354 = $0 << 1;
 $add2455 = $mul2354 | 1;
 $cmp2556 = ($add2455|0)>(0);
 if (!($cmp2556)) {
  return;
 }
 $i$157 = 0;
 while(1) {
  $1 = HEAP32[$over32>>2]|0;
  $mul28 = $1 << 2;
  $call29 = (_malloc($mul28)|0);
  $2 = HEAP32[$x>>2]|0;
  $arrayidx31 = (($2) + ($i$157<<2)|0);
  HEAP32[$arrayidx31>>2] = $call29;
  $call34 = (_malloc($mul28)|0);
  $3 = HEAP32[$z>>2]|0;
  $arrayidx36 = (($3) + ($i$157<<2)|0);
  HEAP32[$arrayidx36>>2] = $call34;
  $4 = HEAP32[$over32>>2]|0;
  $cmp3952 = ($4|0)>(0);
  if ($cmp3952) {
   $5 = HEAP32[$x>>2]|0;
   $arrayidx42 = (($5) + ($i$157<<2)|0);
   $6 = HEAP32[$arrayidx42>>2]|0;
   $7 = HEAP32[$z>>2]|0;
   $arrayidx45 = (($7) + ($i$157<<2)|0);
   $8 = HEAP32[$arrayidx45>>2]|0;
   $j$053 = 0;
   while(1) {
    $arrayidx43 = (($6) + ($j$053<<2)|0);
    HEAP32[$arrayidx43>>2] = 0;
    $arrayidx46 = (($8) + ($j$053<<2)|0);
    HEAP32[$arrayidx46>>2] = 0;
    $inc48 = (($j$053) + 1)|0;
    $9 = HEAP32[$over32>>2]|0;
    $cmp39 = ($inc48|0)<($9|0);
    if ($cmp39) {
     $j$053 = $inc48;
    } else {
     break;
    }
   }
  }
  $10 = HEAP32[$q>>2]|0;
  $cmp51 = ($i$157|0)<($10|0);
  if ($cmp51) {
   $11 = HEAP32[$x>>2]|0;
   $arrayidx55 = (($11) + ($i$157<<2)|0);
   $12 = HEAP32[$arrayidx55>>2]|0;
   $13 = $i$157 >>> 5;
   $arrayidx57 = (($12) + ($13<<2)|0);
   $and65$pn$in = $i$157;$arrayidx70$sink = $arrayidx57;
   label = 10;
  } else {
   $mul59 = $10 << 1;
   $cmp60 = ($i$157|0)<($mul59|0);
   if ($cmp60) {
    $sub63 = (($i$157) - ($10))|0;
    $14 = HEAP32[$z>>2]|0;
    $arrayidx68 = (($14) + ($i$157<<2)|0);
    $15 = HEAP32[$arrayidx68>>2]|0;
    $shr69 = $sub63 >> 5;
    $arrayidx70 = (($15) + ($shr69<<2)|0);
    $and65$pn$in = $sub63;$arrayidx70$sink = $arrayidx70;
    label = 10;
   }
  }
  if ((label|0) == 10) {
   label = 0;
   $and65$pn = $and65$pn$in & 31;
   $$sink$in = (((($q)) + 16|0) + ($and65$pn<<2)|0);
   $$sink = HEAP32[$$sink$in>>2]|0;
   HEAP32[$arrayidx70$sink>>2] = $$sink;
  }
  $16 = HEAP32[$r>>2]|0;
  $arrayidx73 = (($16) + ($i$157<<2)|0);
  HEAP32[$arrayidx73>>2] = 0;
  $inc75 = (($i$157) + 1)|0;
  $17 = HEAP32[$q>>2]|0;
  $mul23 = $17 << 1;
  $add24 = $mul23 | 1;
  $cmp25 = ($inc75|0)<($add24|0);
  if ($cmp25) {
   $i$157 = $inc75;
  } else {
   break;
  }
 }
 return;
}
function __Z10free_stateR6QState($q) {
 $q = $q|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $add = 0, $add11 = 0, $arrayidx = 0, $arrayidx1 = 0, $cmp = 0, $cmp12 = 0, $i$013 = 0, $inc = 0, $mul = 0, $mul10 = 0, $r = 0;
 var $x = 0, $z = 0, $z3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP32[$q>>2]|0;
 $mul10 = $0 << 1;
 $add11 = $mul10 | 1;
 $cmp12 = ($add11|0)>(0);
 $x = ((($q)) + 4|0);
 if ($cmp12) {
  $z = ((($q)) + 8|0);
  $i$013 = 0;
  while(1) {
   $4 = HEAP32[$x>>2]|0;
   $arrayidx = (($4) + ($i$013<<2)|0);
   $5 = HEAP32[$arrayidx>>2]|0;
   _free($5);
   $6 = HEAP32[$z>>2]|0;
   $arrayidx1 = (($6) + ($i$013<<2)|0);
   $7 = HEAP32[$arrayidx1>>2]|0;
   _free($7);
   $inc = (($i$013) + 1)|0;
   $8 = HEAP32[$q>>2]|0;
   $mul = $8 << 1;
   $add = $mul | 1;
   $cmp = ($inc|0)<($add|0);
   if ($cmp) {
    $i$013 = $inc;
   } else {
    break;
   }
  }
 }
 $1 = HEAP32[$x>>2]|0;
 _free($1);
 $z3 = ((($q)) + 8|0);
 $2 = HEAP32[$z3>>2]|0;
 _free($2);
 $r = ((($q)) + 12|0);
 $3 = HEAP32[$r>>2]|0;
 _free($3);
 return;
}
function __Z11clone_stateRK6QState($agg$result,$src) {
 $agg$result = $agg$result|0;
 $src = $src|0;
 var $0 = 0, $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $add = 0, $arraydecay = 0, $arraydecay4 = 0, $arrayidx = 0, $arrayidx22 = 0, $arrayidx26 = 0, $arrayidx32 = 0, $call = 0, $call11 = 0;
 var $call13 = 0, $call16 = 0, $call20 = 0, $cmp19 = 0, $exitcond = 0, $i$020 = 0, $inc = 0, $mul = 0, $mul15 = 0, $mul6 = 0, $over32 = 0, $over322 = 0, $r = 0, $r8 = 0, $x = 0, $x25 = 0, $z = 0, $z31 = 0, dest = 0, label = 0;
 var sp = 0, src = 0, stop = 0;
 sp = STACKTOP;
 $0 = HEAP32[$src>>2]|0;
 HEAP32[$agg$result>>2] = $0;
 $over32 = ((($src)) + 144|0);
 $1 = HEAP32[$over32>>2]|0;
 $over322 = ((($agg$result)) + 144|0);
 HEAP32[$over322>>2] = $1;
 $arraydecay = ((($agg$result)) + 16|0);
 $arraydecay4 = ((($src)) + 16|0);
 dest=$arraydecay; src=$arraydecay4; stop=dest+128|0; do { HEAP32[dest>>2]=HEAP32[src>>2]|0; dest=dest+4|0; src=src+4|0; } while ((dest|0) < (stop|0));
 $mul = $0 << 1;
 $add = $mul | 1;
 $mul6 = $add << 2;
 $call = (_malloc($mul6)|0);
 $r = ((($agg$result)) + 12|0);
 HEAP32[$r>>2] = $call;
 $r8 = ((($src)) + 12|0);
 $2 = HEAP32[$r8>>2]|0;
 _memcpy(($call|0),($2|0),($mul6|0))|0;
 $call11 = (_malloc($mul6)|0);
 $x = ((($agg$result)) + 4|0);
 HEAP32[$x>>2] = $call11;
 $call13 = (_malloc($mul6)|0);
 $z = ((($agg$result)) + 8|0);
 HEAP32[$z>>2] = $call13;
 $cmp19 = ($add|0)>(0);
 if (!($cmp19)) {
  return;
 }
 $mul15 = $1 << 2;
 $3 = HEAP32[$x>>2]|0;
 $4 = HEAP32[$z>>2]|0;
 $x25 = ((($src)) + 4|0);
 $z31 = ((($src)) + 8|0);
 $i$020 = 0;
 while(1) {
  $call16 = (_malloc($mul15)|0);
  $arrayidx = (($3) + ($i$020<<2)|0);
  HEAP32[$arrayidx>>2] = $call16;
  $call20 = (_malloc($mul15)|0);
  $arrayidx22 = (($4) + ($i$020<<2)|0);
  HEAP32[$arrayidx22>>2] = $call20;
  $5 = HEAP32[$arrayidx>>2]|0;
  $6 = HEAP32[$x25>>2]|0;
  $arrayidx26 = (($6) + ($i$020<<2)|0);
  $7 = HEAP32[$arrayidx26>>2]|0;
  _memcpy(($5|0),($7|0),($mul15|0))|0;
  $8 = HEAP32[$arrayidx22>>2]|0;
  $9 = HEAP32[$z31>>2]|0;
  $arrayidx32 = (($9) + ($i$020<<2)|0);
  $10 = HEAP32[$arrayidx32>>2]|0;
  _memcpy(($8|0),($10|0),($mul15|0))|0;
  $inc = (($i$020) + 1)|0;
  $exitcond = ($inc|0)==($add|0);
  if ($exitcond) {
   break;
  } else {
   $i$020 = $inc;
  }
 }
 return;
}
function __Z12peek_state_xRK6QStateii($src,$row,$col) {
 $src = $src|0;
 $row = $row|0;
 $col = $col|0;
 var $0 = 0, $1 = 0, $2 = 0, $and = 0, $and2 = 0, $arrayidx = 0, $arrayidx1 = 0, $conv = 0, $shl = 0, $shr = 0, $tobool = 0, $x = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $shr = $col >> 5;
 $and = $col & 31;
 $shl = 1 << $and;
 $x = ((($src)) + 4|0);
 $0 = HEAP32[$x>>2]|0;
 $arrayidx = (($0) + ($row<<2)|0);
 $1 = HEAP32[$arrayidx>>2]|0;
 $arrayidx1 = (($1) + ($shr<<2)|0);
 $2 = HEAP32[$arrayidx1>>2]|0;
 $and2 = $2 & $shl;
 $tobool = ($and2|0)!=(0);
 $conv = $tobool&1;
 return ($conv|0);
}
function __Z12peek_state_zRK6QStateii($src,$row,$col) {
 $src = $src|0;
 $row = $row|0;
 $col = $col|0;
 var $0 = 0, $1 = 0, $2 = 0, $and = 0, $and2 = 0, $arrayidx = 0, $arrayidx1 = 0, $conv = 0, $shl = 0, $shr = 0, $tobool = 0, $z = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $shr = $col >> 5;
 $and = $col & 31;
 $shl = 1 << $and;
 $z = ((($src)) + 8|0);
 $0 = HEAP32[$z>>2]|0;
 $arrayidx = (($0) + ($row<<2)|0);
 $1 = HEAP32[$arrayidx>>2]|0;
 $arrayidx1 = (($1) + ($shr<<2)|0);
 $2 = HEAP32[$arrayidx1>>2]|0;
 $and2 = $2 & $shl;
 $tobool = ($and2|0)!=(0);
 $conv = $tobool&1;
 return ($conv|0);
}
function __Z12peek_state_rRK6QStatei($src,$row) {
 $src = $src|0;
 $row = $row|0;
 var $0 = 0, $1 = 0, $arrayidx = 0, $conv = 0, $r = 0, $tobool = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $r = ((($src)) + 12|0);
 $0 = HEAP32[$r>>2]|0;
 $arrayidx = (($0) + ($row<<2)|0);
 $1 = HEAP32[$arrayidx>>2]|0;
 $tobool = ($1|0)!=(0);
 $conv = $tobool&1;
 return ($conv|0);
}
function ___cxx_global_var_init() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN38EmscriptenBindingInitializer_my_moduleC2Ev(0);
 return;
}
function __ZN38EmscriptenBindingInitializer_my_moduleC2Ev($this) {
 $this = $this|0;
 var $args$i$i = 0, $call$i = 0, $call$i$i = 0, $call$i$i$i = 0, $call$i$i$i$i = 0, $call$i$i10$i = 0, $call$i$i11$i = 0, $call$i$i9$i = 0, $call2$i = 0, $call2$i$i = 0, $call3$i = 0, $call3$i$i = 0, $call4$i = 0, $call5$i = 0, $call6$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args$i$i = sp;
 __ZN10emscripten8internal11NoBaseClass6verifyI6QStateEEvv();
 $call$i = (__ZN10emscripten8internal11NoBaseClass11getUpcasterI6QStateEEPFvvEv()|0);
 $call2$i = (__ZN10emscripten8internal11NoBaseClass13getDowncasterI6QStateEEPFvvEv()|0);
 $call3$i = (__ZN10emscripten8internal6TypeIDI6QStateE3getEv()|0);
 $call4$i = (__ZN10emscripten8internal6TypeIDINS0_17AllowedRawPointerI6QStateEEE3getEv()|0);
 $call5$i = (__ZN10emscripten8internal6TypeIDINS0_17AllowedRawPointerIK6QStateEEE3getEv()|0);
 $call6$i = (__ZN10emscripten8internal11NoBaseClass3getEv()|0);
 $call$i$i$i = (__ZN10emscripten8internal19getGenericSignatureIJiiEEEPKcv()|0);
 $call$i$i9$i = (__ZN10emscripten8internal19getGenericSignatureIJvEEEPKcv()|0);
 $call$i$i10$i = (__ZN10emscripten8internal19getGenericSignatureIJvEEEPKcv()|0);
 $call$i$i11$i = (__ZN10emscripten8internal19getGenericSignatureIJviEEEPKcv()|0);
 __embind_register_class(($call3$i|0),($call4$i|0),($call5$i|0),($call6$i|0),($call$i$i$i|0),(1|0),($call$i$i9$i|0),($call$i|0),($call$i$i10$i|0),($call2$i|0),(756|0),($call$i$i11$i|0),(9|0));
 $call$i$i = (__ZN10emscripten8internal6TypeIDI6QStateE3getEv()|0);
 $call2$i$i = (__ZNK10emscripten8internal12WithPoliciesIJNS_18allow_raw_pointersEEE11ArgTypeListIJP6QStateEE8getCountEv($args$i$i)|0);
 $call3$i$i = (__ZNK10emscripten8internal12WithPoliciesIJNS_18allow_raw_pointersEEE11ArgTypeListIJP6QStateEE8getTypesEv($args$i$i)|0);
 $call$i$i$i$i = (__ZN10emscripten8internal19getGenericSignatureIJiiEEEPKcv()|0);
 __embind_register_class_constructor(($call$i$i|0),($call2$i$i|0),($call3$i$i|0),($call$i$i$i$i|0),(2|0),(1|0));
 __ZN10emscripten8functionIvJR6QStatelEJEEEvPKcPFT_DpT0_EDpT1_(763,1);
 __ZN10emscripten8functionIvJR6QStatellEJEEEvPKcPFT_DpT0_EDpT1_(774,1);
 __ZN10emscripten8functionIvJR6QStatelEJEEEvPKcPFT_DpT0_EDpT1_(779,2);
 __ZN10emscripten8functionIvJR6QStatelEJEEEvPKcPFT_DpT0_EDpT1_(788,3);
 __ZN10emscripten8functionIiJR6QStatelibEJEEEvPKcPFT_DpT0_EDpT1_(794,1);
 __ZN10emscripten8functionIvJR6QStateEJEEEvPKcPFT_DpT0_EDpT1_(802,10);
 __ZN10emscripten8functionI6QStateJRKS1_EJEEEvPKcPFT_DpT0_EDpT1_(813,4);
 __ZN10emscripten8functionIcJRK6QStateiiEJEEEvPKcPFT_DpT0_EDpT1_(825,4);
 __ZN10emscripten8functionIcJRK6QStateiiEJEEEvPKcPFT_DpT0_EDpT1_(838,5);
 __ZN10emscripten8functionIcJRK6QStateiEJEEEvPKcPFT_DpT0_EDpT1_(851,1);
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionIvJR6QStatelEJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatelEE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatelEE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJviiiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(2|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionIvJR6QStatellEJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatellEE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatellEE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJviiiiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(4|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionIiJR6QStatelibEJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiR6QStatelibEE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiR6QStatelibEE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJiiiiiiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(1|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionIvJR6QStateEJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStateEE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStateEE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJviiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(5|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionI6QStateJRKS1_EJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJ6QStateRKS4_EE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJ6QStateRKS4_EE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJiiiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(2|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionIcJRK6QStateiiEJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiiEE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiiEE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJiiiiiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(2|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8functionIcJRK6QStateiEJEEEvPKcPFT_DpT0_EDpT1_($name,$fn) {
 $name = $name|0;
 $fn = $fn|0;
 var $args = 0, $call = 0, $call$i$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $args = sp;
 $call = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiEE8getCountEv($args)|0);
 $call1 = (__ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiEE8getTypesEv($args)|0);
 $call$i$i = (__ZN10emscripten8internal19getGenericSignatureIJiiiiEEEPKcv()|0);
 __embind_register_function(($name|0),($call|0),($call1|0),($call$i$i|0),(6|0),($fn|0));
 STACKTOP = sp;return;
}
function __ZN10emscripten8internal11NoBaseClass6verifyI6QStateEEvv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return;
}
function __ZN10emscripten8internal13getActualTypeI6QStateEEPKvPT_($ptr) {
 $ptr = $ptr|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14getLightTypeIDI6QStateEEPKvRKT_($ptr)|0);
 return ($call|0);
}
function __ZN10emscripten8internal11NoBaseClass11getUpcasterI6QStateEEPFvvEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (0|0);
}
function __ZN10emscripten8internal11NoBaseClass13getDowncasterI6QStateEEPFvvEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (0|0);
}
function __ZN10emscripten8internal14raw_destructorI6QStateEEvPT_($ptr) {
 $ptr = $ptr|0;
 var $isnull = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $isnull = ($ptr|0)==(0|0);
 if ($isnull) {
  return;
 }
 __ZdlPv($ptr);
 return;
}
function __ZN10emscripten8internal6TypeIDI6QStateE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDI6QStateE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal6TypeIDINS0_17AllowedRawPointerI6QStateEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIP6QStateE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal6TypeIDINS0_17AllowedRawPointerIK6QStateEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIPK6QStateE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11NoBaseClass3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (0|0);
}
function __ZN10emscripten8internal14getLightTypeIDI6QStateEEPKvRKT_($value) {
 $value = $value|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (80|0);
}
function __ZN10emscripten8internal11LightTypeIDI6QStateE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (80|0);
}
function __ZN10emscripten8internal11LightTypeIDIP6QStateE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (88|0);
}
function __ZN10emscripten8internal11LightTypeIDIPK6QStateE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (104|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (891|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJvEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (894|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJviEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (896|0);
}
function __ZN10emscripten8internal12operator_newI6QStateJEEEPT_DpOT0_() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__Znwm(148)|0);
 _memset(($call|0),0,148)|0;
 return ($call|0);
}
function __ZN10emscripten8internal7InvokerIP6QStateJEE6invokeEPFS3_vE($fn) {
 $fn = $fn|0;
 var $call = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (FUNCTION_TABLE_i[$fn & 1]()|0);
 $call1 = (__ZN10emscripten8internal11BindingTypeIP6QStateE10toWireTypeES3_($call)|0);
 return ($call1|0);
}
function __ZNK10emscripten8internal12WithPoliciesIJNS_18allow_raw_pointersEEE11ArgTypeListIJP6QStateEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 1;
}
function __ZNK10emscripten8internal12WithPoliciesIJNS_18allow_raw_pointersEEE11ArgTypeListIJP6QStateEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJNS0_17AllowedRawPointerI6QStateEEEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11BindingTypeIP6QStateE10toWireTypeES3_($p) {
 $p = $p|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return ($p|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJNS0_17AllowedRawPointerI6QStateEEEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (536|0);
}
function __ZN10emscripten8internal7InvokerIvJR6QStatelEE6invokeEPFvS3_lEPS2_l($fn,$args,$args1) {
 $fn = $fn|0;
 $args = $args|0;
 $args1 = $args1|0;
 var $call = 0, $call3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 $call3 = (__ZN10emscripten8internal11BindingTypeIlE12fromWireTypeEl($args1)|0);
 FUNCTION_TABLE_vii[$fn & 7]($call,$call3);
 return;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatelEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 3;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatelEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvR6QStatelEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($p) {
 $p = $p|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return ($p|0);
}
function __ZN10emscripten8internal11BindingTypeIlE12fromWireTypeEl($v) {
 $v = $v|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return ($v|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvR6QStatelEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (540|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJviiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (899|0);
}
function __ZN10emscripten8internal7InvokerIvJR6QStatellEE6invokeEPFvS3_llEPS2_ll($fn,$args,$args1,$args3) {
 $fn = $fn|0;
 $args = $args|0;
 $args1 = $args1|0;
 $args3 = $args3|0;
 var $call = 0, $call5 = 0, $call6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 $call5 = (__ZN10emscripten8internal11BindingTypeIlE12fromWireTypeEl($args1)|0);
 $call6 = (__ZN10emscripten8internal11BindingTypeIlE12fromWireTypeEl($args3)|0);
 FUNCTION_TABLE_viii[$fn & 3]($call,$call5,$call6);
 return;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatellEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 4;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStatellEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvR6QStatellEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvR6QStatellEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (16|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJviiiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (904|0);
}
function __ZN10emscripten8internal7InvokerIiJR6QStatelibEE6invokeEPFiS3_libEPS2_lib($fn,$args,$args1,$args3,$args5) {
 $fn = $fn|0;
 $args = $args|0;
 $args1 = $args1|0;
 $args3 = $args3|0;
 $args5 = $args5|0;
 var $call = 0, $call10 = 0, $call11 = 0, $call7 = 0, $call8 = 0, $call9 = 0, $ref$tmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $ref$tmp = sp;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 $call7 = (__ZN10emscripten8internal11BindingTypeIlE12fromWireTypeEl($args1)|0);
 $call8 = (__ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($args3)|0);
 $call9 = (__ZN10emscripten8internal11BindingTypeIbE12fromWireTypeEb($args5)|0);
 $call10 = (FUNCTION_TABLE_iiiii[$fn & 3]($call,$call7,$call8,$call9)|0);
 HEAP32[$ref$tmp>>2] = $call10;
 $call11 = (__ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($ref$tmp)|0);
 STACKTOP = sp;return ($call11|0);
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiR6QStatelibEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 5;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJiR6QStatelibEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiR6QStatelibEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11BindingTypeIiE10toWireTypeERKi($v) {
 $v = $v|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP32[$v>>2]|0;
 return ($0|0);
}
function __ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($v) {
 $v = $v|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return ($v|0);
}
function __ZN10emscripten8internal11BindingTypeIbE12fromWireTypeEb($wt) {
 $wt = $wt|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return ($wt|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJiR6QStatelibEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (32|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJiiiiiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (910|0);
}
function __ZN10emscripten8internal7InvokerIvJR6QStateEE6invokeEPFvS3_EPS2_($fn,$args) {
 $fn = $fn|0;
 $args = $args|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 FUNCTION_TABLE_vi[$fn & 15]($call);
 return;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStateEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 2;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJvR6QStateEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvR6QStateEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJvR6QStateEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (552|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJviiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (917|0);
}
function __ZN10emscripten8internal7InvokerI6QStateJRKS2_EE6invokeEPFS2_S4_EPS2_($fn,$args) {
 $fn = $fn|0;
 $args = $args|0;
 var $call = 0, $call1 = 0, $ref$tmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160|0;
 $ref$tmp = sp;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 FUNCTION_TABLE_vii[$fn & 7]($ref$tmp,$call);
 $call1 = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE10toWireTypeEOS2_($ref$tmp)|0);
 STACKTOP = sp;return ($call1|0);
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJ6QStateRKS4_EE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 2;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJ6QStateRKS4_EE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJ6QStateRKS3_EEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal18GenericBindingTypeI6QStateE10toWireTypeEOS2_($v) {
 $v = $v|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__Znwm(148)|0);
 _memcpy(($call|0),($v|0),148)|0;
 return ($call|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJ6QStateRKS3_EEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (560|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJiiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (921|0);
}
function __ZN10emscripten8internal7InvokerIcJRK6QStateiiEE6invokeEPFcS4_iiEPS2_ii($fn,$args,$args1,$args3) {
 $fn = $fn|0;
 $args = $args|0;
 $args1 = $args1|0;
 $args3 = $args3|0;
 var $call = 0, $call5 = 0, $call6 = 0, $call7 = 0, $call8 = 0, $ref$tmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $ref$tmp = sp;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 $call5 = (__ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($args1)|0);
 $call6 = (__ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($args3)|0);
 $call7 = (FUNCTION_TABLE_iiii[$fn & 7]($call,$call5,$call6)|0);
 HEAP8[$ref$tmp>>0] = $call7;
 $call8 = (__ZN10emscripten8internal11BindingTypeIcE10toWireTypeERKc($ref$tmp)|0);
 STACKTOP = sp;return ($call8|0);
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiiEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 4;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiiEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJcRK6QStateiiEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11BindingTypeIcE10toWireTypeERKc($v) {
 $v = $v|0;
 var $0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP8[$v>>0]|0;
 return ($0|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJcRK6QStateiiEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (64|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJiiiiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (925|0);
}
function __ZN10emscripten8internal7InvokerIcJRK6QStateiEE6invokeEPFcS4_iEPS2_i($fn,$args,$args1) {
 $fn = $fn|0;
 $args = $args|0;
 $args1 = $args1|0;
 var $call = 0, $call3 = 0, $call4 = 0, $call5 = 0, $ref$tmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $ref$tmp = sp;
 $call = (__ZN10emscripten8internal18GenericBindingTypeI6QStateE12fromWireTypeEPS2_($args)|0);
 $call3 = (__ZN10emscripten8internal11BindingTypeIiE12fromWireTypeEi($args1)|0);
 $call4 = (FUNCTION_TABLE_iii[$fn & 3]($call,$call3)|0);
 HEAP8[$ref$tmp>>0] = $call4;
 $call5 = (__ZN10emscripten8internal11BindingTypeIcE10toWireTypeERKc($ref$tmp)|0);
 STACKTOP = sp;return ($call5|0);
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiEE8getCountEv($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return 3;
}
function __ZNK10emscripten8internal12WithPoliciesIJEE11ArgTypeListIJcRK6QStateiEE8getTypesEv($this) {
 $this = $this|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJcRK6QStateiEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal14ArgArrayGetterINS0_8TypeListIJcRK6QStateiEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (568|0);
}
function __ZN10emscripten8internal19getGenericSignatureIJiiiiEEEPKcv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (931|0);
}
function __GLOBAL__sub_I_chp_cpp() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 ___cxx_global_var_init();
 return;
}
function __GLOBAL__sub_I_bind_cpp() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 ___cxx_global_var_init_2();
 return;
}
function ___cxx_global_var_init_2() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev(0);
 return;
}
function __ZN53EmscriptenBindingInitializer_native_and_builtin_typesC2Ev($this) {
 $this = $this|0;
 var $call = 0, $call2 = 0, $call3 = 0, $call4 = 0, $call5 = 0, $call6 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIvE3getEv()|0);
 __embind_register_void(($call|0),(936|0));
 $call2 = (__ZN10emscripten8internal6TypeIDIbE3getEv()|0);
 __embind_register_bool(($call2|0),(941|0),1,1,0);
 __ZN12_GLOBAL__N_116register_integerIcEEvPKc();
 __ZN12_GLOBAL__N_116register_integerIaEEvPKc();
 __ZN12_GLOBAL__N_116register_integerIhEEvPKc();
 __ZN12_GLOBAL__N_116register_integerIsEEvPKc();
 __ZN12_GLOBAL__N_116register_integerItEEvPKc();
 __ZN12_GLOBAL__N_116register_integerIiEEvPKc();
 __ZN12_GLOBAL__N_116register_integerIjEEvPKc();
 __ZN12_GLOBAL__N_116register_integerIlEEvPKc();
 __ZN12_GLOBAL__N_116register_integerImEEvPKc();
 __ZN12_GLOBAL__N_114register_floatIfEEvPKc();
 __ZN12_GLOBAL__N_114register_floatIdEEvPKc();
 $call3 = (__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv()|0);
 __embind_register_std_string(($call3|0),(946|0));
 $call4 = (__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv()|0);
 __embind_register_std_string(($call4|0),(958|0));
 $call5 = (__ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv()|0);
 __embind_register_std_wstring(($call5|0),4,(991|0));
 $call6 = (__ZN10emscripten8internal6TypeIDINS_3valEE3getEv()|0);
 __embind_register_emval(($call6|0),(1004|0));
 __ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc();
 __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc(1020);
 __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc(1057);
 __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc(1096);
 __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc(1127);
 __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc(1167);
 __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc(1196);
 __ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc();
 __ZN12_GLOBAL__N_120register_memory_viewImEEvPKc();
 __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc(1234);
 __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc(1266);
 __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc(1299);
 __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc(1332);
 __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc(1366);
 __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc(1399);
 __ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc();
 __ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc();
 __ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc();
 return;
}
function __ZN10emscripten8internal6TypeIDIvE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIvE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal6TypeIDIbE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIbE3getEv()|0);
 return ($call|0);
}
function __ZN12_GLOBAL__N_116register_integerIcEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIcE3getEv()|0);
 __embind_register_integer(($call|0),(2346|0),1,-128,127);
 return;
}
function __ZN12_GLOBAL__N_116register_integerIaEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIaE3getEv()|0);
 __embind_register_integer(($call|0),(2334|0),1,-128,127);
 return;
}
function __ZN12_GLOBAL__N_116register_integerIhEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIhE3getEv()|0);
 __embind_register_integer(($call|0),(2320|0),1,0,255);
 return;
}
function __ZN12_GLOBAL__N_116register_integerIsEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIsE3getEv()|0);
 __embind_register_integer(($call|0),(2314|0),2,-32768,32767);
 return;
}
function __ZN12_GLOBAL__N_116register_integerItEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDItE3getEv()|0);
 __embind_register_integer(($call|0),(2299|0),2,0,65535);
 return;
}
function __ZN12_GLOBAL__N_116register_integerIiEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIiE3getEv()|0);
 __embind_register_integer(($call|0),(2295|0),4,-2147483648,2147483647);
 return;
}
function __ZN12_GLOBAL__N_116register_integerIjEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIjE3getEv()|0);
 __embind_register_integer(($call|0),(2282|0),4,0,-1);
 return;
}
function __ZN12_GLOBAL__N_116register_integerIlEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIlE3getEv()|0);
 __embind_register_integer(($call|0),(2277|0),4,-2147483648,2147483647);
 return;
}
function __ZN12_GLOBAL__N_116register_integerImEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDImE3getEv()|0);
 __embind_register_integer(($call|0),(2263|0),4,0,-1);
 return;
}
function __ZN12_GLOBAL__N_114register_floatIfEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIfE3getEv()|0);
 __embind_register_float(($call|0),(2257|0),4);
 return;
}
function __ZN12_GLOBAL__N_114register_floatIdEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDIdE3getEv()|0);
 __embind_register_float(($call|0),(2250|0),8);
 return;
}
function __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal6TypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal6TypeIDINS_3valEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv()|0);
 return ($call|0);
}
function __ZN12_GLOBAL__N_120register_memory_viewIcEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEE3getEv()|0);
 __embind_register_memory_view(($call|0),0,(1943|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIaEEvPKc($name) {
 $name = $name|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEE3getEv()|0);
 __embind_register_memory_view(($call|0),0,($name|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIhEEvPKc($name) {
 $name = $name|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEE3getEv()|0);
 __embind_register_memory_view(($call|0),1,($name|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIsEEvPKc($name) {
 $name = $name|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEE3getEv()|0);
 __embind_register_memory_view(($call|0),2,($name|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewItEEvPKc($name) {
 $name = $name|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewItEEE3getEv()|0);
 __embind_register_memory_view(($call|0),3,($name|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIiEEvPKc($name) {
 $name = $name|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEE3getEv()|0);
 __embind_register_memory_view(($call|0),4,($name|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIjEEvPKc($name) {
 $name = $name|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEE3getEv()|0);
 __embind_register_memory_view(($call|0),5,($name|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIlEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEE3getEv()|0);
 __embind_register_memory_view(($call|0),4,(1696|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewImEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewImEEE3getEv()|0);
 __embind_register_memory_view(($call|0),5,(1626|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIfEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEE3getEv()|0);
 __embind_register_memory_view(($call|0),6,(1564|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIdEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEE3getEv()|0);
 __embind_register_memory_view(($call|0),7,(1501|0));
 return;
}
function __ZN12_GLOBAL__N_120register_memory_viewIeEEvPKc() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEE3getEv()|0);
 __embind_register_memory_view(($call|0),7,(1433|0));
 return;
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIeEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIeEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (120|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIdEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIdEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (128|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIfEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIfEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (136|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewImEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewImEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (144|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIlEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIlEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (152|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIjEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIjEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (160|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIiEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIiEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (168|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewItEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewItEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (176|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIsEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIsEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (184|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIhEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIhEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (192|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIaEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIaEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (200|0);
}
function __ZN10emscripten8internal6TypeIDINS_11memory_viewIcEEE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_11memory_viewIcEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (208|0);
}
function __ZN10emscripten8internal11LightTypeIDINS_3valEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (216|0);
}
function __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIwNS2_11char_traitsIwEENS2_9allocatorIwEEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (224|0);
}
function __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIhNS2_11char_traitsIhEENS2_9allocatorIhEEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (256|0);
}
function __ZN10emscripten8internal11LightTypeIDINSt3__212basic_stringIcNS2_11char_traitsIcEENS2_9allocatorIcEEEEE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (280|0);
}
function __ZN10emscripten8internal6TypeIDIdE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIdE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIdE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (512|0);
}
function __ZN10emscripten8internal6TypeIDIfE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIfE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIfE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (504|0);
}
function __ZN10emscripten8internal6TypeIDImE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDImE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDImE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (496|0);
}
function __ZN10emscripten8internal6TypeIDIlE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIlE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIlE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (488|0);
}
function __ZN10emscripten8internal6TypeIDIjE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIjE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIjE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (480|0);
}
function __ZN10emscripten8internal6TypeIDIiE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIiE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIiE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (472|0);
}
function __ZN10emscripten8internal6TypeIDItE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDItE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDItE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (464|0);
}
function __ZN10emscripten8internal6TypeIDIsE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIsE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIsE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (456|0);
}
function __ZN10emscripten8internal6TypeIDIhE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIhE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIhE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (440|0);
}
function __ZN10emscripten8internal6TypeIDIaE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIaE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIaE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (448|0);
}
function __ZN10emscripten8internal6TypeIDIcE3getEv() {
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10emscripten8internal11LightTypeIDIcE3getEv()|0);
 return ($call|0);
}
function __ZN10emscripten8internal11LightTypeIDIcE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (432|0);
}
function __ZN10emscripten8internal11LightTypeIDIbE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (424|0);
}
function __ZN10emscripten8internal11LightTypeIDIvE3getEv() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (408|0);
}
function ___getTypeName($ti) {
 $ti = $ti|0;
 var $0 = 0, $__type_name$i = 0, $call1 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $__type_name$i = ((($ti)) + 4|0);
 $0 = HEAP32[$__type_name$i>>2]|0;
 $call1 = (___strdup($0)|0);
 return ($call1|0);
}
function ___errno_location() {
 var label = 0, sp = 0;
 sp = STACKTOP;
 return (2656|0);
}
function _strlen($s) {
 $s = $s|0;
 var $$pn = 0, $$pn24 = 0, $$pre = 0, $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $and = 0, $and3 = 0, $incdec$ptr = 0, $incdec$ptr1323 = 0, $incdec$ptr7 = 0, $neg = 0, $rem = 0, $rem13 = 0, $retval$0 = 0, $s$addr$0$lcssa = 0, $s$addr$015 = 0;
 var $s$addr$1$lcssa = 0, $sub = 0, $sub$ptr$lhs$cast15 = 0, $tobool = 0, $tobool1 = 0, $tobool10 = 0, $tobool1021 = 0, $tobool14 = 0, $tobool4 = 0, $w$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = $s;
 $rem13 = $0 & 3;
 $tobool14 = ($rem13|0)==(0);
 L1: do {
  if ($tobool14) {
   $s$addr$0$lcssa = $s;
   label = 5;
  } else {
   $5 = $0;$s$addr$015 = $s;
   while(1) {
    $1 = HEAP8[$s$addr$015>>0]|0;
    $tobool1 = ($1<<24>>24)==(0);
    if ($tobool1) {
     $$pn = $5;
     break L1;
    }
    $incdec$ptr = ((($s$addr$015)) + 1|0);
    $2 = $incdec$ptr;
    $rem = $2 & 3;
    $tobool = ($rem|0)==(0);
    if ($tobool) {
     $s$addr$0$lcssa = $incdec$ptr;
     label = 5;
     break;
    } else {
     $5 = $2;$s$addr$015 = $incdec$ptr;
    }
   }
  }
 } while(0);
 if ((label|0) == 5) {
  $w$0 = $s$addr$0$lcssa;
  while(1) {
   $3 = HEAP32[$w$0>>2]|0;
   $sub = (($3) + -16843009)|0;
   $neg = $3 & -2139062144;
   $and = $neg ^ -2139062144;
   $and3 = $and & $sub;
   $tobool4 = ($and3|0)==(0);
   $incdec$ptr7 = ((($w$0)) + 4|0);
   if ($tobool4) {
    $w$0 = $incdec$ptr7;
   } else {
    break;
   }
  }
  $4 = $3&255;
  $tobool1021 = ($4<<24>>24)==(0);
  if ($tobool1021) {
   $s$addr$1$lcssa = $w$0;
  } else {
   $$pn24 = $w$0;
   while(1) {
    $incdec$ptr1323 = ((($$pn24)) + 1|0);
    $$pre = HEAP8[$incdec$ptr1323>>0]|0;
    $tobool10 = ($$pre<<24>>24)==(0);
    if ($tobool10) {
     $s$addr$1$lcssa = $incdec$ptr1323;
     break;
    } else {
     $$pn24 = $incdec$ptr1323;
    }
   }
  }
  $sub$ptr$lhs$cast15 = $s$addr$1$lcssa;
  $$pn = $sub$ptr$lhs$cast15;
 }
 $retval$0 = (($$pn) - ($0))|0;
 return ($retval$0|0);
}
function ___strdup($s) {
 $s = $s|0;
 var $add = 0, $call = 0, $call1 = 0, $call3 = 0, $retval$0 = 0, $tobool = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (_strlen($s)|0);
 $add = (($call) + 1)|0;
 $call1 = (_malloc($add)|0);
 $tobool = ($call1|0)==(0|0);
 if ($tobool) {
  $retval$0 = 0;
 } else {
  $call3 = (_memcpy(($call1|0),($s|0),($add|0))|0);
  $retval$0 = $call3;
 }
 return ($retval$0|0);
}
function _malloc($bytes) {
 $bytes = $bytes|0;
 var $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i134 = 0, $$pre$i194 = 0, $$pre$i31$i = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i195Z2D = 0, $$pre$phi$i32$iZ2D = 0, $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0;
 var $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0;
 var $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0;
 var $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0;
 var $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0;
 var $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0;
 var $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0;
 var $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0;
 var $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $F$0$i$i = 0, $F104$0 = 0, $F197$0$i = 0, $F224$0$i$i = 0, $F290$0$i = 0, $I252$0$i$i = 0, $I316$0$i = 0, $I57$0$i$i = 0, $K105$010$i$i = 0;
 var $K305$08$i$i = 0, $K373$015$i = 0, $R$1$i = 0, $R$1$i$be = 0, $R$1$i$i = 0, $R$1$i$i$be = 0, $R$1$i$i$ph = 0, $R$1$i$ph = 0, $R$1$i183 = 0, $R$1$i183$be = 0, $R$1$i183$ph = 0, $R$3$i = 0, $R$3$i$i = 0, $R$3$i188 = 0, $RP$1$i = 0, $RP$1$i$be = 0, $RP$1$i$i = 0, $RP$1$i$i$be = 0, $RP$1$i$i$ph = 0, $RP$1$i$ph = 0;
 var $RP$1$i182 = 0, $RP$1$i182$be = 0, $RP$1$i182$ph = 0, $T$0$lcssa$i = 0, $T$0$lcssa$i$i = 0, $T$0$lcssa$i34$i = 0, $T$014$i = 0, $T$07$i$i = 0, $T$09$i$i = 0, $add$i = 0, $add$i$i = 0, $add$i135 = 0, $add$i155 = 0, $add$ptr = 0, $add$ptr$i = 0, $add$ptr$i$i = 0, $add$ptr$i$i$i = 0, $add$ptr$i141 = 0, $add$ptr$i174 = 0, $add$ptr$i2$i$i = 0;
 var $add$ptr$i35$i = 0, $add$ptr$i43$i = 0, $add$ptr$i57$i = 0, $add$ptr14$i$i = 0, $add$ptr15$i$i = 0, $add$ptr16$i$i = 0, $add$ptr166 = 0, $add$ptr169 = 0, $add$ptr17$i$i = 0, $add$ptr178 = 0, $add$ptr181$i = 0, $add$ptr182 = 0, $add$ptr189$i = 0, $add$ptr190$i = 0, $add$ptr193 = 0, $add$ptr199 = 0, $add$ptr2$i$i = 0, $add$ptr205$i$i = 0, $add$ptr212$i$i = 0, $add$ptr225$i = 0;
 var $add$ptr227$i = 0, $add$ptr24$i$i = 0, $add$ptr262$i = 0, $add$ptr269$i = 0, $add$ptr273$i = 0, $add$ptr282$i = 0, $add$ptr3$i$i = 0, $add$ptr30$i$i = 0, $add$ptr369$i$i = 0, $add$ptr4$i$i = 0, $add$ptr4$i$i$i = 0, $add$ptr4$i41$i = 0, $add$ptr4$i49$i = 0, $add$ptr441$i = 0, $add$ptr5$i$i = 0, $add$ptr6$i$i = 0, $add$ptr6$i$i$i = 0, $add$ptr6$i53$i = 0, $add$ptr7$i$i = 0, $add$ptr81$i$i = 0;
 var $add$ptr95 = 0, $add$ptr98 = 0, $add10$i = 0, $add101$i = 0, $add110$i = 0, $add13$i = 0, $add14$i = 0, $add140$i = 0, $add144 = 0, $add150$i = 0, $add17$i = 0, $add17$i158 = 0, $add177$i = 0, $add18$i = 0, $add19$i = 0, $add2 = 0, $add20$i = 0, $add206$i$i = 0, $add212$i = 0, $add215$i = 0;
 var $add22$i = 0, $add246$i = 0, $add26$i$i = 0, $add268$i = 0, $add269$i$i = 0, $add274$i$i = 0, $add278$i$i = 0, $add280$i$i = 0, $add283$i$i = 0, $add337$i = 0, $add342$i = 0, $add346$i = 0, $add348$i = 0, $add351$i = 0, $add46$i = 0, $add50 = 0, $add51$i = 0, $add54 = 0, $add54$i = 0, $add58 = 0;
 var $add62 = 0, $add64 = 0, $add74$i$i = 0, $add77$i = 0, $add78$i = 0, $add79$i$i = 0, $add8 = 0, $add82$i = 0, $add83$i$i = 0, $add85$i$i = 0, $add86$i = 0, $add88$i$i = 0, $add9$i = 0, $add90$i = 0, $add92$i = 0, $and = 0, $and$i = 0, $and$i$i = 0, $and$i$i$i = 0, $and$i14$i = 0;
 var $and$i152 = 0, $and$i36$i = 0, $and$i44$i = 0, $and100$i = 0, $and103$i = 0, $and104$i = 0, $and106 = 0, $and11$i = 0, $and119$i$i = 0, $and1197$i$i = 0, $and12$i = 0, $and13$i = 0, $and13$i$i = 0, $and133$i$i = 0, $and14 = 0, $and145 = 0, $and17$i = 0, $and194$i = 0, $and194$i191 = 0, $and199$i = 0;
 var $and209$i$i = 0, $and21$i = 0, $and21$i159 = 0, $and227$i$i = 0, $and236$i = 0, $and264$i$i = 0, $and268$i$i = 0, $and273$i$i = 0, $and282$i$i = 0, $and29$i = 0, $and292$i = 0, $and295$i$i = 0, $and3$i = 0, $and3$i$i = 0, $and3$i$i$i = 0, $and3$i39$i = 0, $and3$i47$i = 0, $and30$i = 0, $and318$i$i = 0, $and3185$i$i = 0;
 var $and32$i = 0, $and32$i$i = 0, $and33$i$i = 0, $and331$i = 0, $and336$i = 0, $and341$i = 0, $and350$i = 0, $and363$i = 0, $and37$i$i = 0, $and387$i = 0, $and38712$i = 0, $and4 = 0, $and40$i$i = 0, $and41 = 0, $and42$i = 0, $and43 = 0, $and46 = 0, $and49 = 0, $and49$i = 0, $and49$i$i = 0;
 var $and53 = 0, $and57 = 0, $and6$i = 0, $and6$i$i = 0, $and6$i13$i = 0, $and6$i18$i = 0, $and61 = 0, $and64$i = 0, $and68$i = 0, $and69$i$i = 0, $and7 = 0, $and73$i = 0, $and73$i$i = 0, $and74 = 0, $and77$i = 0, $and78$i$i = 0, $and8$i = 0, $and80$i = 0, $and81$i = 0, $and85$i = 0;
 var $and87$i$i = 0, $and89$i = 0, $and9$i = 0, $and96$i$i = 0, $arrayidx = 0, $arrayidx$i = 0, $arrayidx$i$i = 0, $arrayidx$i160 = 0, $arrayidx103 = 0, $arrayidx103$i$i = 0, $arrayidx106$i = 0, $arrayidx107$i$i = 0, $arrayidx113$i = 0, $arrayidx113$i173 = 0, $arrayidx121$i = 0, $arrayidx121$i$sink = 0, $arrayidx123$i$i = 0, $arrayidx126$i$i = 0, $arrayidx137$i = 0, $arrayidx143$i$i = 0;
 var $arrayidx148$i = 0, $arrayidx151$i = 0, $arrayidx151$i$i = 0, $arrayidx151$i$i$sink = 0, $arrayidx154$i = 0, $arrayidx155$i = 0, $arrayidx161$i = 0, $arrayidx165$i = 0, $arrayidx165$i185 = 0, $arrayidx178$i$i = 0, $arrayidx184$i = 0, $arrayidx184$i$i = 0, $arrayidx195$i$i = 0, $arrayidx196$i = 0, $arrayidx204$i = 0, $arrayidx212$i = 0, $arrayidx212$i$sink = 0, $arrayidx223$i$i = 0, $arrayidx228$i = 0, $arrayidx23$i = 0;
 var $arrayidx239$i = 0, $arrayidx245$i = 0, $arrayidx256$i = 0, $arrayidx27$i = 0, $arrayidx287$i$i = 0, $arrayidx289$i = 0, $arrayidx290$i$i = 0, $arrayidx325$i$i = 0, $arrayidx355$i = 0, $arrayidx358$i = 0, $arrayidx394$i = 0, $arrayidx40$i = 0, $arrayidx44$i = 0, $arrayidx61$i = 0, $arrayidx65$i = 0, $arrayidx66 = 0, $arrayidx71$i = 0, $arrayidx75$i = 0, $arrayidx91$i$i = 0, $arrayidx92$i$i = 0;
 var $arrayidx94$i = 0, $arrayidx94$i170 = 0, $arrayidx96$i$i = 0, $bk$i = 0, $bk$i$i = 0, $bk$i176 = 0, $bk$i26$i = 0, $bk102$i$i = 0, $bk122 = 0, $bk124 = 0, $bk139$i$i = 0, $bk145$i = 0, $bk158$i$i = 0, $bk161$i$i = 0, $bk18 = 0, $bk218$i = 0, $bk220$i = 0, $bk246$i$i = 0, $bk248$i$i = 0, $bk302$i$i = 0;
 var $bk311$i = 0, $bk313$i = 0, $bk338$i$i = 0, $bk357$i$i = 0, $bk360$i$i = 0, $bk370$i = 0, $bk407$i = 0, $bk429$i = 0, $bk432$i = 0, $bk55$i$i = 0, $bk56$i = 0, $bk67$i$i = 0, $bk74$i$i = 0, $bk85 = 0, $bk91$i$i = 0, $br$2$ph$i = 0, $call107$i = 0, $call131$i = 0, $call132$i = 0, $call275$i = 0;
 var $call37$i = 0, $call68$i = 0, $call83$i = 0, $child$i$i = 0, $child166$i$i = 0, $child289$i$i = 0, $child357$i = 0, $cmp = 0, $cmp$i = 0, $cmp$i$i$i = 0, $cmp$i12$i = 0, $cmp$i133 = 0, $cmp$i149 = 0, $cmp$i15$i = 0, $cmp$i3$i$i = 0, $cmp$i37$i = 0, $cmp$i45$i = 0, $cmp$i55$i = 0, $cmp1 = 0, $cmp1$i = 0;
 var $cmp10 = 0, $cmp100$i$i = 0, $cmp102$i = 0, $cmp104$i$i = 0, $cmp105$i = 0, $cmp106$i$i = 0, $cmp107$i = 0, $cmp108$i = 0, $cmp108$i$i = 0, $cmp114$i = 0, $cmp116$i = 0, $cmp118$i = 0, $cmp119$i = 0, $cmp12$i = 0, $cmp120$i$i = 0, $cmp120$i28$i = 0, $cmp1208$i$i = 0, $cmp123$i = 0, $cmp124$i$i = 0, $cmp126$i = 0;
 var $cmp127$i = 0, $cmp128 = 0, $cmp128$i = 0, $cmp128$i$i = 0, $cmp133$i = 0, $cmp135$i = 0, $cmp137$i = 0, $cmp138$i = 0, $cmp139 = 0, $cmp141$i = 0, $cmp144$i$i = 0, $cmp146 = 0, $cmp147$i = 0, $cmp14799$i = 0, $cmp15$i = 0, $cmp151$i = 0, $cmp152$i = 0, $cmp155$i = 0, $cmp156 = 0, $cmp156$i = 0;
 var $cmp156$i$i = 0, $cmp157$i = 0, $cmp159$i = 0, $cmp162 = 0, $cmp162$i = 0, $cmp162$i184 = 0, $cmp166$i = 0, $cmp168$i$i = 0, $cmp174$i = 0, $cmp180$i = 0, $cmp185$i = 0, $cmp185$i$i = 0, $cmp186 = 0, $cmp186$i = 0, $cmp19$i = 0, $cmp190$i = 0, $cmp191$i = 0, $cmp2$i$i = 0, $cmp2$i$i$i = 0, $cmp20$i$i = 0;
 var $cmp203$i = 0, $cmp205$i = 0, $cmp209$i = 0, $cmp21$i = 0, $cmp215$i$i = 0, $cmp217$i = 0, $cmp218$i = 0, $cmp224$i = 0, $cmp228$i = 0, $cmp229$i = 0, $cmp24$i = 0, $cmp24$i$i = 0, $cmp246$i = 0, $cmp254$i$i = 0, $cmp257$i = 0, $cmp258$i$i = 0, $cmp26$i = 0, $cmp265$i = 0, $cmp27$i$i = 0, $cmp28$i = 0;
 var $cmp28$i$i = 0, $cmp284$i = 0, $cmp29 = 0, $cmp3$i$i = 0, $cmp306$i$i = 0, $cmp31 = 0, $cmp319$i = 0, $cmp319$i$i = 0, $cmp3196$i$i = 0, $cmp32$i = 0, $cmp32$i138 = 0, $cmp323$i = 0, $cmp327$i$i = 0, $cmp34$i = 0, $cmp34$i$i = 0, $cmp35$i = 0, $cmp36$i = 0, $cmp36$i$i = 0, $cmp374$i = 0, $cmp38$i = 0;
 var $cmp38$i$i = 0, $cmp388$i = 0, $cmp38813$i = 0, $cmp396$i = 0, $cmp40$i = 0, $cmp43$i = 0, $cmp45$i = 0, $cmp46$i = 0, $cmp46$i$i = 0, $cmp49$i = 0, $cmp5 = 0, $cmp55$i = 0, $cmp55$i166 = 0, $cmp57$i = 0, $cmp57$i167 = 0, $cmp59$i$i = 0, $cmp60$i = 0, $cmp62$i = 0, $cmp63$i = 0, $cmp63$i$i = 0;
 var $cmp65$i = 0, $cmp66$i = 0, $cmp66$i140 = 0, $cmp69$i = 0, $cmp7$i$i = 0, $cmp70 = 0, $cmp72$i = 0, $cmp75$i$i = 0, $cmp76$i = 0, $cmp81$i = 0, $cmp85$i = 0, $cmp89$i = 0, $cmp9$i$i = 0, $cmp90$i = 0, $cmp91$i = 0, $cmp93$i = 0, $cmp95$i = 0, $cmp96$i = 0, $cmp97$i = 0, $cmp97$i$i = 0;
 var $cmp9716$i = 0, $cmp99 = 0, $cond = 0, $cond$i = 0, $cond$i$i = 0, $cond$i$i$i = 0, $cond$i17$i = 0, $cond$i40$i = 0, $cond$i48$i = 0, $cond1$i$i = 0, $cond115$i = 0, $cond115$i$i = 0, $cond13$i$i = 0, $cond15$i$i = 0, $cond2$i = 0, $cond3$i = 0, $cond315$i$i = 0, $cond383$i = 0, $cond4$i = 0, $fd$i = 0;
 var $fd$i$i = 0, $fd$i177 = 0, $fd103$i$i = 0, $fd123 = 0, $fd140$i$i = 0, $fd146$i = 0, $fd148$i$i = 0, $fd160$i$i = 0, $fd219$i = 0, $fd247$i$i = 0, $fd303$i$i = 0, $fd312$i = 0, $fd339$i$i = 0, $fd344$i$i = 0, $fd359$i$i = 0, $fd371$i = 0, $fd408$i = 0, $fd416$i = 0, $fd431$i = 0, $fd54$i$i = 0;
 var $fd57$i = 0, $fd68$i$i = 0, $fd69 = 0, $fd78$i$i = 0, $fd9 = 0, $fd92$i$i = 0, $head = 0, $head$i = 0, $head$i$i = 0, $head$i$i$i = 0, $head$i164 = 0, $head$i22$i = 0, $head$i42$i = 0, $head$i52$i = 0, $head118$i$i = 0, $head1186$i$i = 0, $head168 = 0, $head173 = 0, $head177 = 0, $head179 = 0;
 var $head179$i = 0, $head182$i = 0, $head187$i = 0, $head189$i = 0, $head195 = 0, $head198 = 0, $head208$i$i = 0, $head211$i$i = 0, $head23$i$i = 0, $head25 = 0, $head26$i$i = 0, $head265$i = 0, $head268$i = 0, $head271$i = 0, $head274$i = 0, $head279$i = 0, $head281$i = 0, $head29$i = 0, $head29$i$i = 0, $head317$i$i = 0;
 var $head3174$i$i = 0, $head32$i$i = 0, $head34$i$i = 0, $head386$i = 0, $head38611$i = 0, $head7$i$i = 0, $head7$i$i$i = 0, $head7$i54$i = 0, $head94 = 0, $head97 = 0, $head99$i = 0, $idx$0$i = 0, $index$i = 0, $index$i$i = 0, $index$i189 = 0, $index$i29$i = 0, $index288$i$i = 0, $index356$i = 0, $magic$i$i = 0, $nb$0 = 0;
 var $neg = 0, $neg$i = 0, $neg$i$i = 0, $neg$i137 = 0, $neg$i190 = 0, $neg103$i = 0, $neg13 = 0, $neg132$i$i = 0, $neg48$i = 0, $neg73 = 0, $next$i = 0, $next$i$i = 0, $next$i$i$i = 0, $next231$i = 0, $not$cmp141$i = 0, $oldfirst$0$i$i = 0, $or$cond$i = 0, $or$cond$i168 = 0, $or$cond1$i = 0, $or$cond1$i165 = 0;
 var $or$cond11$i = 0, $or$cond2$i = 0, $or$cond4$i = 0, $or$cond5$i = 0, $or$cond7$i = 0, $or$cond8$i = 0, $or$cond8$not$i = 0, $or$cond97$i = 0, $or$cond98$i = 0, $or$i = 0, $or$i$i = 0, $or$i$i$i = 0, $or$i169 = 0, $or$i51$i = 0, $or101$i$i = 0, $or110 = 0, $or167 = 0, $or172 = 0, $or176 = 0, $or178$i = 0;
 var $or180 = 0, $or183$i = 0, $or186$i = 0, $or188$i = 0, $or19$i$i = 0, $or194 = 0, $or197 = 0, $or204$i = 0, $or210$i$i = 0, $or22$i$i = 0, $or23 = 0, $or232$i$i = 0, $or26 = 0, $or264$i = 0, $or267$i = 0, $or270$i = 0, $or275$i = 0, $or278$i = 0, $or28$i$i = 0, $or280$i = 0;
 var $or297$i = 0, $or300$i$i = 0, $or33$i$i = 0, $or368$i = 0, $or40 = 0, $or44$i$i = 0, $or93 = 0, $or96 = 0, $parent$i = 0, $parent$i$i = 0, $parent$i175 = 0, $parent$i27$i = 0, $parent135$i = 0, $parent138$i$i = 0, $parent149$i = 0, $parent162$i$i = 0, $parent165$i$i = 0, $parent166$i = 0, $parent179$i$i = 0, $parent196$i$i = 0;
 var $parent226$i = 0, $parent240$i = 0, $parent257$i = 0, $parent301$i$i = 0, $parent337$i$i = 0, $parent361$i$i = 0, $parent369$i = 0, $parent406$i = 0, $parent433$i = 0, $qsize$0$i$i = 0, $retval$0 = 0, $rsize$0$i = 0, $rsize$0$i162 = 0, $rsize$1$i = 0, $rsize$3$i = 0, $rsize$4$lcssa$i = 0, $rsize$418$i = 0, $rsize$418$i$ph = 0, $rst$0$i = 0, $rst$1$i = 0;
 var $sflags193$i = 0, $sflags235$i = 0, $shl = 0, $shl$i = 0, $shl$i$i = 0, $shl$i153 = 0, $shl102 = 0, $shl105 = 0, $shl116$i$i = 0, $shl12 = 0, $shl127$i$i = 0, $shl131$i$i = 0, $shl15$i = 0, $shl18$i = 0, $shl192$i = 0, $shl195$i = 0, $shl198$i = 0, $shl22 = 0, $shl222$i$i = 0, $shl226$i$i = 0;
 var $shl265$i$i = 0, $shl270$i$i = 0, $shl276$i$i = 0, $shl279$i$i = 0, $shl288$i = 0, $shl291$i = 0, $shl294$i$i = 0, $shl31$i = 0, $shl316$i$i = 0, $shl326$i$i = 0, $shl333$i = 0, $shl338$i = 0, $shl344$i = 0, $shl347$i = 0, $shl35 = 0, $shl362$i = 0, $shl37 = 0, $shl384$i = 0, $shl39$i$i = 0, $shl395$i = 0;
 var $shl48$i$i = 0, $shl60$i = 0, $shl65 = 0, $shl70$i$i = 0, $shl72 = 0, $shl75$i$i = 0, $shl81$i$i = 0, $shl84$i$i = 0, $shl9$i = 0, $shl90 = 0, $shl95$i$i = 0, $shr = 0, $shr$i = 0, $shr$i$i = 0, $shr$i148 = 0, $shr$i25$i = 0, $shr101 = 0, $shr11$i = 0, $shr11$i156 = 0, $shr110$i$i = 0;
 var $shr12$i = 0, $shr124$i$i = 0, $shr15$i = 0, $shr16$i = 0, $shr16$i157 = 0, $shr19$i = 0, $shr194$i = 0, $shr20$i = 0, $shr214$i$i = 0, $shr253$i$i = 0, $shr263$i$i = 0, $shr267$i$i = 0, $shr27$i = 0, $shr272$i$i = 0, $shr277$i$i = 0, $shr281$i$i = 0, $shr283$i = 0, $shr3 = 0, $shr310$i$i = 0, $shr318$i = 0;
 var $shr323$i$i = 0, $shr330$i = 0, $shr335$i = 0, $shr340$i = 0, $shr345$i = 0, $shr349$i = 0, $shr378$i = 0, $shr392$i = 0, $shr4$i = 0, $shr42$i = 0, $shr45 = 0, $shr47 = 0, $shr48 = 0, $shr5$i = 0, $shr5$i151 = 0, $shr51 = 0, $shr52 = 0, $shr55 = 0, $shr56 = 0, $shr58$i$i = 0;
 var $shr59 = 0, $shr60 = 0, $shr63 = 0, $shr68$i$i = 0, $shr7$i = 0, $shr7$i154 = 0, $shr72$i = 0, $shr72$i$i = 0, $shr75$i = 0, $shr76$i = 0, $shr77$i$i = 0, $shr79$i = 0, $shr8$i = 0, $shr80$i = 0, $shr82$i$i = 0, $shr83$i = 0, $shr84$i = 0, $shr86$i$i = 0, $shr87$i = 0, $shr88$i = 0;
 var $shr91$i = 0, $size$i$i = 0, $size$i$i$i = 0, $size$i$i$le = 0, $size188$i = 0, $size188$i$le = 0, $size245$i = 0, $sizebits$0$i = 0, $sp$0$i$i = 0, $sp$0$i$i$i = 0, $sp$0112$i = 0, $sp$1111$i = 0, $spec$select$i = 0, $spec$select$i171 = 0, $spec$select1$i = 0, $spec$select2$i = 0, $spec$select5$i = 0, $spec$select9$i = 0, $spec$select96$i = 0, $ssize$2$ph$i = 0;
 var $sub = 0, $sub$i = 0, $sub$i$i = 0, $sub$i$i$i = 0, $sub$i136 = 0, $sub$i147 = 0, $sub$i16$i = 0, $sub$i38$i = 0, $sub$i46$i = 0, $sub$ptr$lhs$cast$i = 0, $sub$ptr$lhs$cast$i$i = 0, $sub$ptr$lhs$cast$i19$i = 0, $sub$ptr$rhs$cast$i = 0, $sub$ptr$rhs$cast$i$i = 0, $sub$ptr$rhs$cast$i20$i = 0, $sub$ptr$sub$i = 0, $sub$ptr$sub$i$i = 0, $sub$ptr$sub$i21$i = 0, $sub10$i = 0, $sub101$i = 0;
 var $sub112$i = 0, $sub113$i$i = 0, $sub118$i = 0, $sub12$i$i = 0, $sub14$i = 0, $sub16$i$i = 0, $sub160 = 0, $sub172$i = 0, $sub18$i$i = 0, $sub190 = 0, $sub2$i = 0, $sub22$i = 0, $sub260$i = 0, $sub262$i$i = 0, $sub266$i$i = 0, $sub271$i$i = 0, $sub275$i$i = 0, $sub30$i = 0, $sub31$i = 0, $sub313$i$i = 0;
 var $sub329$i = 0, $sub33$i = 0, $sub334$i = 0, $sub339$i = 0, $sub343$i = 0, $sub381$i = 0, $sub4$i = 0, $sub41$i = 0, $sub42 = 0, $sub44 = 0, $sub5$i$i = 0, $sub5$i$i$i = 0, $sub5$i50$i = 0, $sub50$i = 0, $sub6$i = 0, $sub63$i = 0, $sub67$i = 0, $sub67$i$i = 0, $sub70$i = 0, $sub71$i$i = 0;
 var $sub76$i$i = 0, $sub80$i$i = 0, $sub91 = 0, $sub99$i = 0, $t$0$i = 0, $t$0$i161 = 0, $t$2$i = 0, $t$4$i = 0, $t$517$i = 0, $t$517$i$ph = 0, $tbase$795$i = 0, $tobool$i$i = 0, $tobool107 = 0, $tobool195$i = 0, $tobool200$i = 0, $tobool228$i$i = 0, $tobool237$i = 0, $tobool293$i = 0, $tobool296$i$i = 0, $tobool30$i = 0;
 var $tobool364$i = 0, $tobool97$i$i = 0, $tsize$2647482$i = 0, $tsize$4$i = 0, $tsize$794$i = 0, $v$0$i = 0, $v$0$i163 = 0, $v$1$i = 0, $v$3$i = 0, $v$3$i204 = 0, $v$4$lcssa$i = 0, $v$419$i = 0, $v$419$i$ph = 0, $xor$i$i = 0, label = 0, sp = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16|0;
 $magic$i$i = sp;
 $cmp = ($bytes>>>0)<(245);
 do {
  if ($cmp) {
   $cmp1 = ($bytes>>>0)<(11);
   $add2 = (($bytes) + 11)|0;
   $and = $add2 & -8;
   $cond = $cmp1 ? 16 : $and;
   $shr = $cond >>> 3;
   $0 = HEAP32[665]|0;
   $shr3 = $0 >>> $shr;
   $and4 = $shr3 & 3;
   $cmp5 = ($and4|0)==(0);
   if (!($cmp5)) {
    $neg = $shr3 & 1;
    $and7 = $neg ^ 1;
    $add8 = (($and7) + ($shr))|0;
    $shl = $add8 << 1;
    $arrayidx = (2700 + ($shl<<2)|0);
    $1 = ((($arrayidx)) + 8|0);
    $2 = HEAP32[$1>>2]|0;
    $fd9 = ((($2)) + 8|0);
    $3 = HEAP32[$fd9>>2]|0;
    $cmp10 = ($3|0)==($arrayidx|0);
    if ($cmp10) {
     $shl12 = 1 << $add8;
     $neg13 = $shl12 ^ -1;
     $and14 = $0 & $neg13;
     HEAP32[665] = $and14;
    } else {
     $bk18 = ((($3)) + 12|0);
     HEAP32[$bk18>>2] = $arrayidx;
     HEAP32[$1>>2] = $3;
    }
    $shl22 = $add8 << 3;
    $or23 = $shl22 | 3;
    $head = ((($2)) + 4|0);
    HEAP32[$head>>2] = $or23;
    $add$ptr = (($2) + ($shl22)|0);
    $head25 = ((($add$ptr)) + 4|0);
    $4 = HEAP32[$head25>>2]|0;
    $or26 = $4 | 1;
    HEAP32[$head25>>2] = $or26;
    $retval$0 = $fd9;
    STACKTOP = sp;return ($retval$0|0);
   }
   $5 = HEAP32[(2668)>>2]|0;
   $cmp29 = ($cond>>>0)>($5>>>0);
   if ($cmp29) {
    $cmp31 = ($shr3|0)==(0);
    if (!($cmp31)) {
     $shl35 = $shr3 << $shr;
     $shl37 = 2 << $shr;
     $sub = (0 - ($shl37))|0;
     $or40 = $shl37 | $sub;
     $and41 = $shl35 & $or40;
     $sub42 = (0 - ($and41))|0;
     $and43 = $and41 & $sub42;
     $sub44 = (($and43) + -1)|0;
     $shr45 = $sub44 >>> 12;
     $and46 = $shr45 & 16;
     $shr47 = $sub44 >>> $and46;
     $shr48 = $shr47 >>> 5;
     $and49 = $shr48 & 8;
     $add50 = $and49 | $and46;
     $shr51 = $shr47 >>> $and49;
     $shr52 = $shr51 >>> 2;
     $and53 = $shr52 & 4;
     $add54 = $add50 | $and53;
     $shr55 = $shr51 >>> $and53;
     $shr56 = $shr55 >>> 1;
     $and57 = $shr56 & 2;
     $add58 = $add54 | $and57;
     $shr59 = $shr55 >>> $and57;
     $shr60 = $shr59 >>> 1;
     $and61 = $shr60 & 1;
     $add62 = $add58 | $and61;
     $shr63 = $shr59 >>> $and61;
     $add64 = (($add62) + ($shr63))|0;
     $shl65 = $add64 << 1;
     $arrayidx66 = (2700 + ($shl65<<2)|0);
     $6 = ((($arrayidx66)) + 8|0);
     $7 = HEAP32[$6>>2]|0;
     $fd69 = ((($7)) + 8|0);
     $8 = HEAP32[$fd69>>2]|0;
     $cmp70 = ($8|0)==($arrayidx66|0);
     if ($cmp70) {
      $shl72 = 1 << $add64;
      $neg73 = $shl72 ^ -1;
      $and74 = $0 & $neg73;
      HEAP32[665] = $and74;
      $10 = $and74;
     } else {
      $bk85 = ((($8)) + 12|0);
      HEAP32[$bk85>>2] = $arrayidx66;
      HEAP32[$6>>2] = $8;
      $10 = $0;
     }
     $shl90 = $add64 << 3;
     $sub91 = (($shl90) - ($cond))|0;
     $or93 = $cond | 3;
     $head94 = ((($7)) + 4|0);
     HEAP32[$head94>>2] = $or93;
     $add$ptr95 = (($7) + ($cond)|0);
     $or96 = $sub91 | 1;
     $head97 = ((($add$ptr95)) + 4|0);
     HEAP32[$head97>>2] = $or96;
     $add$ptr98 = (($7) + ($shl90)|0);
     HEAP32[$add$ptr98>>2] = $sub91;
     $cmp99 = ($5|0)==(0);
     if (!($cmp99)) {
      $9 = HEAP32[(2680)>>2]|0;
      $shr101 = $5 >>> 3;
      $shl102 = $shr101 << 1;
      $arrayidx103 = (2700 + ($shl102<<2)|0);
      $shl105 = 1 << $shr101;
      $and106 = $10 & $shl105;
      $tobool107 = ($and106|0)==(0);
      if ($tobool107) {
       $or110 = $10 | $shl105;
       HEAP32[665] = $or110;
       $$pre = ((($arrayidx103)) + 8|0);
       $$pre$phiZ2D = $$pre;$F104$0 = $arrayidx103;
      } else {
       $11 = ((($arrayidx103)) + 8|0);
       $12 = HEAP32[$11>>2]|0;
       $$pre$phiZ2D = $11;$F104$0 = $12;
      }
      HEAP32[$$pre$phiZ2D>>2] = $9;
      $bk122 = ((($F104$0)) + 12|0);
      HEAP32[$bk122>>2] = $9;
      $fd123 = ((($9)) + 8|0);
      HEAP32[$fd123>>2] = $F104$0;
      $bk124 = ((($9)) + 12|0);
      HEAP32[$bk124>>2] = $arrayidx103;
     }
     HEAP32[(2668)>>2] = $sub91;
     HEAP32[(2680)>>2] = $add$ptr95;
     $retval$0 = $fd69;
     STACKTOP = sp;return ($retval$0|0);
    }
    $13 = HEAP32[(2664)>>2]|0;
    $cmp128 = ($13|0)==(0);
    if ($cmp128) {
     $nb$0 = $cond;
    } else {
     $sub$i = (0 - ($13))|0;
     $and$i = $13 & $sub$i;
     $sub2$i = (($and$i) + -1)|0;
     $shr$i = $sub2$i >>> 12;
     $and3$i = $shr$i & 16;
     $shr4$i = $sub2$i >>> $and3$i;
     $shr5$i = $shr4$i >>> 5;
     $and6$i = $shr5$i & 8;
     $add$i = $and6$i | $and3$i;
     $shr7$i = $shr4$i >>> $and6$i;
     $shr8$i = $shr7$i >>> 2;
     $and9$i = $shr8$i & 4;
     $add10$i = $add$i | $and9$i;
     $shr11$i = $shr7$i >>> $and9$i;
     $shr12$i = $shr11$i >>> 1;
     $and13$i = $shr12$i & 2;
     $add14$i = $add10$i | $and13$i;
     $shr15$i = $shr11$i >>> $and13$i;
     $shr16$i = $shr15$i >>> 1;
     $and17$i = $shr16$i & 1;
     $add18$i = $add14$i | $and17$i;
     $shr19$i = $shr15$i >>> $and17$i;
     $add20$i = (($add18$i) + ($shr19$i))|0;
     $arrayidx$i = (2964 + ($add20$i<<2)|0);
     $14 = HEAP32[$arrayidx$i>>2]|0;
     $head$i = ((($14)) + 4|0);
     $15 = HEAP32[$head$i>>2]|0;
     $and21$i = $15 & -8;
     $sub22$i = (($and21$i) - ($cond))|0;
     $rsize$0$i = $sub22$i;$t$0$i = $14;$v$0$i = $14;
     while(1) {
      $arrayidx23$i = ((($t$0$i)) + 16|0);
      $16 = HEAP32[$arrayidx23$i>>2]|0;
      $cmp$i = ($16|0)==(0|0);
      if ($cmp$i) {
       $arrayidx27$i = ((($t$0$i)) + 20|0);
       $17 = HEAP32[$arrayidx27$i>>2]|0;
       $cmp28$i = ($17|0)==(0|0);
       if ($cmp28$i) {
        break;
       } else {
        $cond4$i = $17;
       }
      } else {
       $cond4$i = $16;
      }
      $head29$i = ((($cond4$i)) + 4|0);
      $18 = HEAP32[$head29$i>>2]|0;
      $and30$i = $18 & -8;
      $sub31$i = (($and30$i) - ($cond))|0;
      $cmp32$i = ($sub31$i>>>0)<($rsize$0$i>>>0);
      $spec$select$i = $cmp32$i ? $sub31$i : $rsize$0$i;
      $spec$select1$i = $cmp32$i ? $cond4$i : $v$0$i;
      $rsize$0$i = $spec$select$i;$t$0$i = $cond4$i;$v$0$i = $spec$select1$i;
     }
     $add$ptr$i = (($v$0$i) + ($cond)|0);
     $cmp35$i = ($add$ptr$i>>>0)>($v$0$i>>>0);
     if ($cmp35$i) {
      $parent$i = ((($v$0$i)) + 24|0);
      $19 = HEAP32[$parent$i>>2]|0;
      $bk$i = ((($v$0$i)) + 12|0);
      $20 = HEAP32[$bk$i>>2]|0;
      $cmp40$i = ($20|0)==($v$0$i|0);
      do {
       if ($cmp40$i) {
        $arrayidx61$i = ((($v$0$i)) + 20|0);
        $22 = HEAP32[$arrayidx61$i>>2]|0;
        $cmp62$i = ($22|0)==(0|0);
        if ($cmp62$i) {
         $arrayidx65$i = ((($v$0$i)) + 16|0);
         $23 = HEAP32[$arrayidx65$i>>2]|0;
         $cmp66$i = ($23|0)==(0|0);
         if ($cmp66$i) {
          $R$3$i = 0;
          break;
         } else {
          $R$1$i$ph = $23;$RP$1$i$ph = $arrayidx65$i;
         }
        } else {
         $R$1$i$ph = $22;$RP$1$i$ph = $arrayidx61$i;
        }
        $R$1$i = $R$1$i$ph;$RP$1$i = $RP$1$i$ph;
        while(1) {
         $arrayidx71$i = ((($R$1$i)) + 20|0);
         $24 = HEAP32[$arrayidx71$i>>2]|0;
         $cmp72$i = ($24|0)==(0|0);
         if ($cmp72$i) {
          $arrayidx75$i = ((($R$1$i)) + 16|0);
          $25 = HEAP32[$arrayidx75$i>>2]|0;
          $cmp76$i = ($25|0)==(0|0);
          if ($cmp76$i) {
           break;
          } else {
           $R$1$i$be = $25;$RP$1$i$be = $arrayidx75$i;
          }
         } else {
          $R$1$i$be = $24;$RP$1$i$be = $arrayidx71$i;
         }
         $R$1$i = $R$1$i$be;$RP$1$i = $RP$1$i$be;
        }
        HEAP32[$RP$1$i>>2] = 0;
        $R$3$i = $R$1$i;
       } else {
        $fd$i = ((($v$0$i)) + 8|0);
        $21 = HEAP32[$fd$i>>2]|0;
        $bk56$i = ((($21)) + 12|0);
        HEAP32[$bk56$i>>2] = $20;
        $fd57$i = ((($20)) + 8|0);
        HEAP32[$fd57$i>>2] = $21;
        $R$3$i = $20;
       }
      } while(0);
      $cmp90$i = ($19|0)==(0|0);
      do {
       if (!($cmp90$i)) {
        $index$i = ((($v$0$i)) + 28|0);
        $26 = HEAP32[$index$i>>2]|0;
        $arrayidx94$i = (2964 + ($26<<2)|0);
        $27 = HEAP32[$arrayidx94$i>>2]|0;
        $cmp95$i = ($v$0$i|0)==($27|0);
        if ($cmp95$i) {
         HEAP32[$arrayidx94$i>>2] = $R$3$i;
         $cond2$i = ($R$3$i|0)==(0|0);
         if ($cond2$i) {
          $shl$i = 1 << $26;
          $neg$i = $shl$i ^ -1;
          $and103$i = $13 & $neg$i;
          HEAP32[(2664)>>2] = $and103$i;
          break;
         }
        } else {
         $arrayidx113$i = ((($19)) + 16|0);
         $28 = HEAP32[$arrayidx113$i>>2]|0;
         $cmp114$i = ($28|0)==($v$0$i|0);
         $arrayidx121$i = ((($19)) + 20|0);
         $arrayidx121$i$sink = $cmp114$i ? $arrayidx113$i : $arrayidx121$i;
         HEAP32[$arrayidx121$i$sink>>2] = $R$3$i;
         $cmp126$i = ($R$3$i|0)==(0|0);
         if ($cmp126$i) {
          break;
         }
        }
        $parent135$i = ((($R$3$i)) + 24|0);
        HEAP32[$parent135$i>>2] = $19;
        $arrayidx137$i = ((($v$0$i)) + 16|0);
        $29 = HEAP32[$arrayidx137$i>>2]|0;
        $cmp138$i = ($29|0)==(0|0);
        if (!($cmp138$i)) {
         $arrayidx148$i = ((($R$3$i)) + 16|0);
         HEAP32[$arrayidx148$i>>2] = $29;
         $parent149$i = ((($29)) + 24|0);
         HEAP32[$parent149$i>>2] = $R$3$i;
        }
        $arrayidx154$i = ((($v$0$i)) + 20|0);
        $30 = HEAP32[$arrayidx154$i>>2]|0;
        $cmp155$i = ($30|0)==(0|0);
        if (!($cmp155$i)) {
         $arrayidx165$i = ((($R$3$i)) + 20|0);
         HEAP32[$arrayidx165$i>>2] = $30;
         $parent166$i = ((($30)) + 24|0);
         HEAP32[$parent166$i>>2] = $R$3$i;
        }
       }
      } while(0);
      $cmp174$i = ($rsize$0$i>>>0)<(16);
      if ($cmp174$i) {
       $add177$i = (($rsize$0$i) + ($cond))|0;
       $or178$i = $add177$i | 3;
       $head179$i = ((($v$0$i)) + 4|0);
       HEAP32[$head179$i>>2] = $or178$i;
       $add$ptr181$i = (($v$0$i) + ($add177$i)|0);
       $head182$i = ((($add$ptr181$i)) + 4|0);
       $31 = HEAP32[$head182$i>>2]|0;
       $or183$i = $31 | 1;
       HEAP32[$head182$i>>2] = $or183$i;
      } else {
       $or186$i = $cond | 3;
       $head187$i = ((($v$0$i)) + 4|0);
       HEAP32[$head187$i>>2] = $or186$i;
       $or188$i = $rsize$0$i | 1;
       $head189$i = ((($add$ptr$i)) + 4|0);
       HEAP32[$head189$i>>2] = $or188$i;
       $add$ptr190$i = (($add$ptr$i) + ($rsize$0$i)|0);
       HEAP32[$add$ptr190$i>>2] = $rsize$0$i;
       $cmp191$i = ($5|0)==(0);
       if (!($cmp191$i)) {
        $32 = HEAP32[(2680)>>2]|0;
        $shr194$i = $5 >>> 3;
        $shl195$i = $shr194$i << 1;
        $arrayidx196$i = (2700 + ($shl195$i<<2)|0);
        $shl198$i = 1 << $shr194$i;
        $and199$i = $shl198$i & $0;
        $tobool200$i = ($and199$i|0)==(0);
        if ($tobool200$i) {
         $or204$i = $shl198$i | $0;
         HEAP32[665] = $or204$i;
         $$pre$i = ((($arrayidx196$i)) + 8|0);
         $$pre$phi$iZ2D = $$pre$i;$F197$0$i = $arrayidx196$i;
        } else {
         $33 = ((($arrayidx196$i)) + 8|0);
         $34 = HEAP32[$33>>2]|0;
         $$pre$phi$iZ2D = $33;$F197$0$i = $34;
        }
        HEAP32[$$pre$phi$iZ2D>>2] = $32;
        $bk218$i = ((($F197$0$i)) + 12|0);
        HEAP32[$bk218$i>>2] = $32;
        $fd219$i = ((($32)) + 8|0);
        HEAP32[$fd219$i>>2] = $F197$0$i;
        $bk220$i = ((($32)) + 12|0);
        HEAP32[$bk220$i>>2] = $arrayidx196$i;
       }
       HEAP32[(2668)>>2] = $rsize$0$i;
       HEAP32[(2680)>>2] = $add$ptr$i;
      }
      $add$ptr225$i = ((($v$0$i)) + 8|0);
      $retval$0 = $add$ptr225$i;
      STACKTOP = sp;return ($retval$0|0);
     } else {
      $nb$0 = $cond;
     }
    }
   } else {
    $nb$0 = $cond;
   }
  } else {
   $cmp139 = ($bytes>>>0)>(4294967231);
   if ($cmp139) {
    $nb$0 = -1;
   } else {
    $add144 = (($bytes) + 11)|0;
    $and145 = $add144 & -8;
    $35 = HEAP32[(2664)>>2]|0;
    $cmp146 = ($35|0)==(0);
    if ($cmp146) {
     $nb$0 = $and145;
    } else {
     $sub$i147 = (0 - ($and145))|0;
     $shr$i148 = $add144 >>> 8;
     $cmp$i149 = ($shr$i148|0)==(0);
     if ($cmp$i149) {
      $idx$0$i = 0;
     } else {
      $cmp1$i = ($and145>>>0)>(16777215);
      if ($cmp1$i) {
       $idx$0$i = 31;
      } else {
       $sub4$i = (($shr$i148) + 1048320)|0;
       $shr5$i151 = $sub4$i >>> 16;
       $and$i152 = $shr5$i151 & 8;
       $shl$i153 = $shr$i148 << $and$i152;
       $sub6$i = (($shl$i153) + 520192)|0;
       $shr7$i154 = $sub6$i >>> 16;
       $and8$i = $shr7$i154 & 4;
       $add$i155 = $and8$i | $and$i152;
       $shl9$i = $shl$i153 << $and8$i;
       $sub10$i = (($shl9$i) + 245760)|0;
       $shr11$i156 = $sub10$i >>> 16;
       $and12$i = $shr11$i156 & 2;
       $add13$i = $add$i155 | $and12$i;
       $sub14$i = (14 - ($add13$i))|0;
       $shl15$i = $shl9$i << $and12$i;
       $shr16$i157 = $shl15$i >>> 15;
       $add17$i158 = (($sub14$i) + ($shr16$i157))|0;
       $shl18$i = $add17$i158 << 1;
       $add19$i = (($add17$i158) + 7)|0;
       $shr20$i = $and145 >>> $add19$i;
       $and21$i159 = $shr20$i & 1;
       $add22$i = $and21$i159 | $shl18$i;
       $idx$0$i = $add22$i;
      }
     }
     $arrayidx$i160 = (2964 + ($idx$0$i<<2)|0);
     $36 = HEAP32[$arrayidx$i160>>2]|0;
     $cmp24$i = ($36|0)==(0|0);
     L79: do {
      if ($cmp24$i) {
       $rsize$3$i = $sub$i147;$t$2$i = 0;$v$3$i = 0;
       label = 61;
      } else {
       $cmp26$i = ($idx$0$i|0)==(31);
       $shr27$i = $idx$0$i >>> 1;
       $sub30$i = (25 - ($shr27$i))|0;
       $cond$i = $cmp26$i ? 0 : $sub30$i;
       $shl31$i = $and145 << $cond$i;
       $rsize$0$i162 = $sub$i147;$rst$0$i = 0;$sizebits$0$i = $shl31$i;$t$0$i161 = $36;$v$0$i163 = 0;
       while(1) {
        $head$i164 = ((($t$0$i161)) + 4|0);
        $37 = HEAP32[$head$i164>>2]|0;
        $and32$i = $37 & -8;
        $sub33$i = (($and32$i) - ($and145))|0;
        $cmp34$i = ($sub33$i>>>0)<($rsize$0$i162>>>0);
        if ($cmp34$i) {
         $cmp36$i = ($sub33$i|0)==(0);
         if ($cmp36$i) {
          $rsize$418$i$ph = 0;$t$517$i$ph = $t$0$i161;$v$419$i$ph = $t$0$i161;
          label = 65;
          break L79;
         } else {
          $rsize$1$i = $sub33$i;$v$1$i = $t$0$i161;
         }
        } else {
         $rsize$1$i = $rsize$0$i162;$v$1$i = $v$0$i163;
        }
        $arrayidx40$i = ((($t$0$i161)) + 20|0);
        $38 = HEAP32[$arrayidx40$i>>2]|0;
        $shr42$i = $sizebits$0$i >>> 31;
        $arrayidx44$i = (((($t$0$i161)) + 16|0) + ($shr42$i<<2)|0);
        $39 = HEAP32[$arrayidx44$i>>2]|0;
        $cmp45$i = ($38|0)==(0|0);
        $cmp46$i = ($38|0)==($39|0);
        $or$cond1$i165 = $cmp45$i | $cmp46$i;
        $rst$1$i = $or$cond1$i165 ? $rst$0$i : $38;
        $cmp49$i = ($39|0)==(0|0);
        $spec$select5$i = $sizebits$0$i << 1;
        if ($cmp49$i) {
         $rsize$3$i = $rsize$1$i;$t$2$i = $rst$1$i;$v$3$i = $v$1$i;
         label = 61;
         break;
        } else {
         $rsize$0$i162 = $rsize$1$i;$rst$0$i = $rst$1$i;$sizebits$0$i = $spec$select5$i;$t$0$i161 = $39;$v$0$i163 = $v$1$i;
        }
       }
      }
     } while(0);
     if ((label|0) == 61) {
      $cmp55$i166 = ($t$2$i|0)==(0|0);
      $cmp57$i167 = ($v$3$i|0)==(0|0);
      $or$cond$i168 = $cmp55$i166 & $cmp57$i167;
      if ($or$cond$i168) {
       $shl60$i = 2 << $idx$0$i;
       $sub63$i = (0 - ($shl60$i))|0;
       $or$i169 = $shl60$i | $sub63$i;
       $and64$i = $or$i169 & $35;
       $cmp65$i = ($and64$i|0)==(0);
       if ($cmp65$i) {
        $nb$0 = $and145;
        break;
       }
       $sub67$i = (0 - ($and64$i))|0;
       $and68$i = $and64$i & $sub67$i;
       $sub70$i = (($and68$i) + -1)|0;
       $shr72$i = $sub70$i >>> 12;
       $and73$i = $shr72$i & 16;
       $shr75$i = $sub70$i >>> $and73$i;
       $shr76$i = $shr75$i >>> 5;
       $and77$i = $shr76$i & 8;
       $add78$i = $and77$i | $and73$i;
       $shr79$i = $shr75$i >>> $and77$i;
       $shr80$i = $shr79$i >>> 2;
       $and81$i = $shr80$i & 4;
       $add82$i = $add78$i | $and81$i;
       $shr83$i = $shr79$i >>> $and81$i;
       $shr84$i = $shr83$i >>> 1;
       $and85$i = $shr84$i & 2;
       $add86$i = $add82$i | $and85$i;
       $shr87$i = $shr83$i >>> $and85$i;
       $shr88$i = $shr87$i >>> 1;
       $and89$i = $shr88$i & 1;
       $add90$i = $add86$i | $and89$i;
       $shr91$i = $shr87$i >>> $and89$i;
       $add92$i = (($add90$i) + ($shr91$i))|0;
       $arrayidx94$i170 = (2964 + ($add92$i<<2)|0);
       $40 = HEAP32[$arrayidx94$i170>>2]|0;
       $t$4$i = $40;$v$3$i204 = 0;
      } else {
       $t$4$i = $t$2$i;$v$3$i204 = $v$3$i;
      }
      $cmp9716$i = ($t$4$i|0)==(0|0);
      if ($cmp9716$i) {
       $rsize$4$lcssa$i = $rsize$3$i;$v$4$lcssa$i = $v$3$i204;
      } else {
       $rsize$418$i$ph = $rsize$3$i;$t$517$i$ph = $t$4$i;$v$419$i$ph = $v$3$i204;
       label = 65;
      }
     }
     if ((label|0) == 65) {
      $rsize$418$i = $rsize$418$i$ph;$t$517$i = $t$517$i$ph;$v$419$i = $v$419$i$ph;
      while(1) {
       $head99$i = ((($t$517$i)) + 4|0);
       $41 = HEAP32[$head99$i>>2]|0;
       $and100$i = $41 & -8;
       $sub101$i = (($and100$i) - ($and145))|0;
       $cmp102$i = ($sub101$i>>>0)<($rsize$418$i>>>0);
       $spec$select$i171 = $cmp102$i ? $sub101$i : $rsize$418$i;
       $spec$select2$i = $cmp102$i ? $t$517$i : $v$419$i;
       $arrayidx106$i = ((($t$517$i)) + 16|0);
       $42 = HEAP32[$arrayidx106$i>>2]|0;
       $cmp107$i = ($42|0)==(0|0);
       if ($cmp107$i) {
        $arrayidx113$i173 = ((($t$517$i)) + 20|0);
        $43 = HEAP32[$arrayidx113$i173>>2]|0;
        $cond115$i = $43;
       } else {
        $cond115$i = $42;
       }
       $cmp97$i = ($cond115$i|0)==(0|0);
       if ($cmp97$i) {
        $rsize$4$lcssa$i = $spec$select$i171;$v$4$lcssa$i = $spec$select2$i;
        break;
       } else {
        $rsize$418$i = $spec$select$i171;$t$517$i = $cond115$i;$v$419$i = $spec$select2$i;
       }
      }
     }
     $cmp116$i = ($v$4$lcssa$i|0)==(0|0);
     if ($cmp116$i) {
      $nb$0 = $and145;
     } else {
      $44 = HEAP32[(2668)>>2]|0;
      $sub118$i = (($44) - ($and145))|0;
      $cmp119$i = ($rsize$4$lcssa$i>>>0)<($sub118$i>>>0);
      if ($cmp119$i) {
       $add$ptr$i174 = (($v$4$lcssa$i) + ($and145)|0);
       $cmp123$i = ($add$ptr$i174>>>0)>($v$4$lcssa$i>>>0);
       if ($cmp123$i) {
        $parent$i175 = ((($v$4$lcssa$i)) + 24|0);
        $45 = HEAP32[$parent$i175>>2]|0;
        $bk$i176 = ((($v$4$lcssa$i)) + 12|0);
        $46 = HEAP32[$bk$i176>>2]|0;
        $cmp128$i = ($46|0)==($v$4$lcssa$i|0);
        do {
         if ($cmp128$i) {
          $arrayidx151$i = ((($v$4$lcssa$i)) + 20|0);
          $48 = HEAP32[$arrayidx151$i>>2]|0;
          $cmp152$i = ($48|0)==(0|0);
          if ($cmp152$i) {
           $arrayidx155$i = ((($v$4$lcssa$i)) + 16|0);
           $49 = HEAP32[$arrayidx155$i>>2]|0;
           $cmp156$i = ($49|0)==(0|0);
           if ($cmp156$i) {
            $R$3$i188 = 0;
            break;
           } else {
            $R$1$i183$ph = $49;$RP$1$i182$ph = $arrayidx155$i;
           }
          } else {
           $R$1$i183$ph = $48;$RP$1$i182$ph = $arrayidx151$i;
          }
          $R$1$i183 = $R$1$i183$ph;$RP$1$i182 = $RP$1$i182$ph;
          while(1) {
           $arrayidx161$i = ((($R$1$i183)) + 20|0);
           $50 = HEAP32[$arrayidx161$i>>2]|0;
           $cmp162$i184 = ($50|0)==(0|0);
           if ($cmp162$i184) {
            $arrayidx165$i185 = ((($R$1$i183)) + 16|0);
            $51 = HEAP32[$arrayidx165$i185>>2]|0;
            $cmp166$i = ($51|0)==(0|0);
            if ($cmp166$i) {
             break;
            } else {
             $R$1$i183$be = $51;$RP$1$i182$be = $arrayidx165$i185;
            }
           } else {
            $R$1$i183$be = $50;$RP$1$i182$be = $arrayidx161$i;
           }
           $R$1$i183 = $R$1$i183$be;$RP$1$i182 = $RP$1$i182$be;
          }
          HEAP32[$RP$1$i182>>2] = 0;
          $R$3$i188 = $R$1$i183;
         } else {
          $fd$i177 = ((($v$4$lcssa$i)) + 8|0);
          $47 = HEAP32[$fd$i177>>2]|0;
          $bk145$i = ((($47)) + 12|0);
          HEAP32[$bk145$i>>2] = $46;
          $fd146$i = ((($46)) + 8|0);
          HEAP32[$fd146$i>>2] = $47;
          $R$3$i188 = $46;
         }
        } while(0);
        $cmp180$i = ($45|0)==(0|0);
        do {
         if ($cmp180$i) {
          $61 = $35;
         } else {
          $index$i189 = ((($v$4$lcssa$i)) + 28|0);
          $52 = HEAP32[$index$i189>>2]|0;
          $arrayidx184$i = (2964 + ($52<<2)|0);
          $53 = HEAP32[$arrayidx184$i>>2]|0;
          $cmp185$i = ($v$4$lcssa$i|0)==($53|0);
          if ($cmp185$i) {
           HEAP32[$arrayidx184$i>>2] = $R$3$i188;
           $cond3$i = ($R$3$i188|0)==(0|0);
           if ($cond3$i) {
            $shl192$i = 1 << $52;
            $neg$i190 = $shl192$i ^ -1;
            $and194$i191 = $35 & $neg$i190;
            HEAP32[(2664)>>2] = $and194$i191;
            $61 = $and194$i191;
            break;
           }
          } else {
           $arrayidx204$i = ((($45)) + 16|0);
           $54 = HEAP32[$arrayidx204$i>>2]|0;
           $cmp205$i = ($54|0)==($v$4$lcssa$i|0);
           $arrayidx212$i = ((($45)) + 20|0);
           $arrayidx212$i$sink = $cmp205$i ? $arrayidx204$i : $arrayidx212$i;
           HEAP32[$arrayidx212$i$sink>>2] = $R$3$i188;
           $cmp217$i = ($R$3$i188|0)==(0|0);
           if ($cmp217$i) {
            $61 = $35;
            break;
           }
          }
          $parent226$i = ((($R$3$i188)) + 24|0);
          HEAP32[$parent226$i>>2] = $45;
          $arrayidx228$i = ((($v$4$lcssa$i)) + 16|0);
          $55 = HEAP32[$arrayidx228$i>>2]|0;
          $cmp229$i = ($55|0)==(0|0);
          if (!($cmp229$i)) {
           $arrayidx239$i = ((($R$3$i188)) + 16|0);
           HEAP32[$arrayidx239$i>>2] = $55;
           $parent240$i = ((($55)) + 24|0);
           HEAP32[$parent240$i>>2] = $R$3$i188;
          }
          $arrayidx245$i = ((($v$4$lcssa$i)) + 20|0);
          $56 = HEAP32[$arrayidx245$i>>2]|0;
          $cmp246$i = ($56|0)==(0|0);
          if ($cmp246$i) {
           $61 = $35;
          } else {
           $arrayidx256$i = ((($R$3$i188)) + 20|0);
           HEAP32[$arrayidx256$i>>2] = $56;
           $parent257$i = ((($56)) + 24|0);
           HEAP32[$parent257$i>>2] = $R$3$i188;
           $61 = $35;
          }
         }
        } while(0);
        $cmp265$i = ($rsize$4$lcssa$i>>>0)<(16);
        L128: do {
         if ($cmp265$i) {
          $add268$i = (($rsize$4$lcssa$i) + ($and145))|0;
          $or270$i = $add268$i | 3;
          $head271$i = ((($v$4$lcssa$i)) + 4|0);
          HEAP32[$head271$i>>2] = $or270$i;
          $add$ptr273$i = (($v$4$lcssa$i) + ($add268$i)|0);
          $head274$i = ((($add$ptr273$i)) + 4|0);
          $57 = HEAP32[$head274$i>>2]|0;
          $or275$i = $57 | 1;
          HEAP32[$head274$i>>2] = $or275$i;
         } else {
          $or278$i = $and145 | 3;
          $head279$i = ((($v$4$lcssa$i)) + 4|0);
          HEAP32[$head279$i>>2] = $or278$i;
          $or280$i = $rsize$4$lcssa$i | 1;
          $head281$i = ((($add$ptr$i174)) + 4|0);
          HEAP32[$head281$i>>2] = $or280$i;
          $add$ptr282$i = (($add$ptr$i174) + ($rsize$4$lcssa$i)|0);
          HEAP32[$add$ptr282$i>>2] = $rsize$4$lcssa$i;
          $shr283$i = $rsize$4$lcssa$i >>> 3;
          $cmp284$i = ($rsize$4$lcssa$i>>>0)<(256);
          if ($cmp284$i) {
           $shl288$i = $shr283$i << 1;
           $arrayidx289$i = (2700 + ($shl288$i<<2)|0);
           $58 = HEAP32[665]|0;
           $shl291$i = 1 << $shr283$i;
           $and292$i = $58 & $shl291$i;
           $tobool293$i = ($and292$i|0)==(0);
           if ($tobool293$i) {
            $or297$i = $58 | $shl291$i;
            HEAP32[665] = $or297$i;
            $$pre$i194 = ((($arrayidx289$i)) + 8|0);
            $$pre$phi$i195Z2D = $$pre$i194;$F290$0$i = $arrayidx289$i;
           } else {
            $59 = ((($arrayidx289$i)) + 8|0);
            $60 = HEAP32[$59>>2]|0;
            $$pre$phi$i195Z2D = $59;$F290$0$i = $60;
           }
           HEAP32[$$pre$phi$i195Z2D>>2] = $add$ptr$i174;
           $bk311$i = ((($F290$0$i)) + 12|0);
           HEAP32[$bk311$i>>2] = $add$ptr$i174;
           $fd312$i = ((($add$ptr$i174)) + 8|0);
           HEAP32[$fd312$i>>2] = $F290$0$i;
           $bk313$i = ((($add$ptr$i174)) + 12|0);
           HEAP32[$bk313$i>>2] = $arrayidx289$i;
           break;
          }
          $shr318$i = $rsize$4$lcssa$i >>> 8;
          $cmp319$i = ($shr318$i|0)==(0);
          if ($cmp319$i) {
           $I316$0$i = 0;
          } else {
           $cmp323$i = ($rsize$4$lcssa$i>>>0)>(16777215);
           if ($cmp323$i) {
            $I316$0$i = 31;
           } else {
            $sub329$i = (($shr318$i) + 1048320)|0;
            $shr330$i = $sub329$i >>> 16;
            $and331$i = $shr330$i & 8;
            $shl333$i = $shr318$i << $and331$i;
            $sub334$i = (($shl333$i) + 520192)|0;
            $shr335$i = $sub334$i >>> 16;
            $and336$i = $shr335$i & 4;
            $add337$i = $and336$i | $and331$i;
            $shl338$i = $shl333$i << $and336$i;
            $sub339$i = (($shl338$i) + 245760)|0;
            $shr340$i = $sub339$i >>> 16;
            $and341$i = $shr340$i & 2;
            $add342$i = $add337$i | $and341$i;
            $sub343$i = (14 - ($add342$i))|0;
            $shl344$i = $shl338$i << $and341$i;
            $shr345$i = $shl344$i >>> 15;
            $add346$i = (($sub343$i) + ($shr345$i))|0;
            $shl347$i = $add346$i << 1;
            $add348$i = (($add346$i) + 7)|0;
            $shr349$i = $rsize$4$lcssa$i >>> $add348$i;
            $and350$i = $shr349$i & 1;
            $add351$i = $and350$i | $shl347$i;
            $I316$0$i = $add351$i;
           }
          }
          $arrayidx355$i = (2964 + ($I316$0$i<<2)|0);
          $index356$i = ((($add$ptr$i174)) + 28|0);
          HEAP32[$index356$i>>2] = $I316$0$i;
          $child357$i = ((($add$ptr$i174)) + 16|0);
          $arrayidx358$i = ((($child357$i)) + 4|0);
          HEAP32[$arrayidx358$i>>2] = 0;
          HEAP32[$child357$i>>2] = 0;
          $shl362$i = 1 << $I316$0$i;
          $and363$i = $61 & $shl362$i;
          $tobool364$i = ($and363$i|0)==(0);
          if ($tobool364$i) {
           $or368$i = $61 | $shl362$i;
           HEAP32[(2664)>>2] = $or368$i;
           HEAP32[$arrayidx355$i>>2] = $add$ptr$i174;
           $parent369$i = ((($add$ptr$i174)) + 24|0);
           HEAP32[$parent369$i>>2] = $arrayidx355$i;
           $bk370$i = ((($add$ptr$i174)) + 12|0);
           HEAP32[$bk370$i>>2] = $add$ptr$i174;
           $fd371$i = ((($add$ptr$i174)) + 8|0);
           HEAP32[$fd371$i>>2] = $add$ptr$i174;
           break;
          }
          $62 = HEAP32[$arrayidx355$i>>2]|0;
          $head38611$i = ((($62)) + 4|0);
          $63 = HEAP32[$head38611$i>>2]|0;
          $and38712$i = $63 & -8;
          $cmp38813$i = ($and38712$i|0)==($rsize$4$lcssa$i|0);
          L145: do {
           if ($cmp38813$i) {
            $T$0$lcssa$i = $62;
           } else {
            $cmp374$i = ($I316$0$i|0)==(31);
            $shr378$i = $I316$0$i >>> 1;
            $sub381$i = (25 - ($shr378$i))|0;
            $cond383$i = $cmp374$i ? 0 : $sub381$i;
            $shl384$i = $rsize$4$lcssa$i << $cond383$i;
            $K373$015$i = $shl384$i;$T$014$i = $62;
            while(1) {
             $shr392$i = $K373$015$i >>> 31;
             $arrayidx394$i = (((($T$014$i)) + 16|0) + ($shr392$i<<2)|0);
             $64 = HEAP32[$arrayidx394$i>>2]|0;
             $cmp396$i = ($64|0)==(0|0);
             if ($cmp396$i) {
              break;
             }
             $shl395$i = $K373$015$i << 1;
             $head386$i = ((($64)) + 4|0);
             $65 = HEAP32[$head386$i>>2]|0;
             $and387$i = $65 & -8;
             $cmp388$i = ($and387$i|0)==($rsize$4$lcssa$i|0);
             if ($cmp388$i) {
              $T$0$lcssa$i = $64;
              break L145;
             } else {
              $K373$015$i = $shl395$i;$T$014$i = $64;
             }
            }
            HEAP32[$arrayidx394$i>>2] = $add$ptr$i174;
            $parent406$i = ((($add$ptr$i174)) + 24|0);
            HEAP32[$parent406$i>>2] = $T$014$i;
            $bk407$i = ((($add$ptr$i174)) + 12|0);
            HEAP32[$bk407$i>>2] = $add$ptr$i174;
            $fd408$i = ((($add$ptr$i174)) + 8|0);
            HEAP32[$fd408$i>>2] = $add$ptr$i174;
            break L128;
           }
          } while(0);
          $fd416$i = ((($T$0$lcssa$i)) + 8|0);
          $66 = HEAP32[$fd416$i>>2]|0;
          $bk429$i = ((($66)) + 12|0);
          HEAP32[$bk429$i>>2] = $add$ptr$i174;
          HEAP32[$fd416$i>>2] = $add$ptr$i174;
          $fd431$i = ((($add$ptr$i174)) + 8|0);
          HEAP32[$fd431$i>>2] = $66;
          $bk432$i = ((($add$ptr$i174)) + 12|0);
          HEAP32[$bk432$i>>2] = $T$0$lcssa$i;
          $parent433$i = ((($add$ptr$i174)) + 24|0);
          HEAP32[$parent433$i>>2] = 0;
         }
        } while(0);
        $add$ptr441$i = ((($v$4$lcssa$i)) + 8|0);
        $retval$0 = $add$ptr441$i;
        STACKTOP = sp;return ($retval$0|0);
       } else {
        $nb$0 = $and145;
       }
      } else {
       $nb$0 = $and145;
      }
     }
    }
   }
  }
 } while(0);
 $67 = HEAP32[(2668)>>2]|0;
 $cmp156 = ($67>>>0)<($nb$0>>>0);
 if (!($cmp156)) {
  $sub160 = (($67) - ($nb$0))|0;
  $68 = HEAP32[(2680)>>2]|0;
  $cmp162 = ($sub160>>>0)>(15);
  if ($cmp162) {
   $add$ptr166 = (($68) + ($nb$0)|0);
   HEAP32[(2680)>>2] = $add$ptr166;
   HEAP32[(2668)>>2] = $sub160;
   $or167 = $sub160 | 1;
   $head168 = ((($add$ptr166)) + 4|0);
   HEAP32[$head168>>2] = $or167;
   $add$ptr169 = (($68) + ($67)|0);
   HEAP32[$add$ptr169>>2] = $sub160;
   $or172 = $nb$0 | 3;
   $head173 = ((($68)) + 4|0);
   HEAP32[$head173>>2] = $or172;
  } else {
   HEAP32[(2668)>>2] = 0;
   HEAP32[(2680)>>2] = 0;
   $or176 = $67 | 3;
   $head177 = ((($68)) + 4|0);
   HEAP32[$head177>>2] = $or176;
   $add$ptr178 = (($68) + ($67)|0);
   $head179 = ((($add$ptr178)) + 4|0);
   $69 = HEAP32[$head179>>2]|0;
   $or180 = $69 | 1;
   HEAP32[$head179>>2] = $or180;
  }
  $add$ptr182 = ((($68)) + 8|0);
  $retval$0 = $add$ptr182;
  STACKTOP = sp;return ($retval$0|0);
 }
 $70 = HEAP32[(2672)>>2]|0;
 $cmp186 = ($70>>>0)>($nb$0>>>0);
 if ($cmp186) {
  $sub190 = (($70) - ($nb$0))|0;
  HEAP32[(2672)>>2] = $sub190;
  $71 = HEAP32[(2684)>>2]|0;
  $add$ptr193 = (($71) + ($nb$0)|0);
  HEAP32[(2684)>>2] = $add$ptr193;
  $or194 = $sub190 | 1;
  $head195 = ((($add$ptr193)) + 4|0);
  HEAP32[$head195>>2] = $or194;
  $or197 = $nb$0 | 3;
  $head198 = ((($71)) + 4|0);
  HEAP32[$head198>>2] = $or197;
  $add$ptr199 = ((($71)) + 8|0);
  $retval$0 = $add$ptr199;
  STACKTOP = sp;return ($retval$0|0);
 }
 $72 = HEAP32[783]|0;
 $cmp$i133 = ($72|0)==(0);
 if ($cmp$i133) {
  HEAP32[(3140)>>2] = 4096;
  HEAP32[(3136)>>2] = 4096;
  HEAP32[(3144)>>2] = -1;
  HEAP32[(3148)>>2] = -1;
  HEAP32[(3152)>>2] = 0;
  HEAP32[(3104)>>2] = 0;
  $73 = $magic$i$i;
  $xor$i$i = $73 & -16;
  $and6$i$i = $xor$i$i ^ 1431655768;
  HEAP32[783] = $and6$i$i;
  $74 = 4096;
 } else {
  $$pre$i134 = HEAP32[(3140)>>2]|0;
  $74 = $$pre$i134;
 }
 $add$i135 = (($nb$0) + 48)|0;
 $sub$i136 = (($nb$0) + 47)|0;
 $add9$i = (($74) + ($sub$i136))|0;
 $neg$i137 = (0 - ($74))|0;
 $and11$i = $add9$i & $neg$i137;
 $cmp12$i = ($and11$i>>>0)>($nb$0>>>0);
 if (!($cmp12$i)) {
  $retval$0 = 0;
  STACKTOP = sp;return ($retval$0|0);
 }
 $75 = HEAP32[(3100)>>2]|0;
 $cmp15$i = ($75|0)==(0);
 if (!($cmp15$i)) {
  $76 = HEAP32[(3092)>>2]|0;
  $add17$i = (($76) + ($and11$i))|0;
  $cmp19$i = ($add17$i>>>0)<=($76>>>0);
  $cmp21$i = ($add17$i>>>0)>($75>>>0);
  $or$cond1$i = $cmp19$i | $cmp21$i;
  if ($or$cond1$i) {
   $retval$0 = 0;
   STACKTOP = sp;return ($retval$0|0);
  }
 }
 $77 = HEAP32[(3104)>>2]|0;
 $and29$i = $77 & 4;
 $tobool30$i = ($and29$i|0)==(0);
 L178: do {
  if ($tobool30$i) {
   $78 = HEAP32[(2684)>>2]|0;
   $cmp32$i138 = ($78|0)==(0|0);
   L180: do {
    if ($cmp32$i138) {
     label = 128;
    } else {
     $sp$0$i$i = (3108);
     while(1) {
      $79 = HEAP32[$sp$0$i$i>>2]|0;
      $cmp$i55$i = ($79>>>0)>($78>>>0);
      if (!($cmp$i55$i)) {
       $size$i$i = ((($sp$0$i$i)) + 4|0);
       $80 = HEAP32[$size$i$i>>2]|0;
       $add$ptr$i57$i = (($79) + ($80)|0);
       $cmp2$i$i = ($add$ptr$i57$i>>>0)>($78>>>0);
       if ($cmp2$i$i) {
        break;
       }
      }
      $next$i$i = ((($sp$0$i$i)) + 8|0);
      $81 = HEAP32[$next$i$i>>2]|0;
      $cmp3$i$i = ($81|0)==(0|0);
      if ($cmp3$i$i) {
       label = 128;
       break L180;
      } else {
       $sp$0$i$i = $81;
      }
     }
     $add77$i = (($add9$i) - ($70))|0;
     $and80$i = $add77$i & $neg$i137;
     $cmp81$i = ($and80$i>>>0)<(2147483647);
     if ($cmp81$i) {
      $size$i$i$le = ((($sp$0$i$i)) + 4|0);
      $call83$i = (_sbrk(($and80$i|0))|0);
      $86 = HEAP32[$sp$0$i$i>>2]|0;
      $87 = HEAP32[$size$i$i$le>>2]|0;
      $add$ptr$i141 = (($86) + ($87)|0);
      $cmp85$i = ($call83$i|0)==($add$ptr$i141|0);
      if ($cmp85$i) {
       $cmp89$i = ($call83$i|0)==((-1)|0);
       if ($cmp89$i) {
        $tsize$2647482$i = $and80$i;
       } else {
        $tbase$795$i = $call83$i;$tsize$794$i = $and80$i;
        label = 145;
        break L178;
       }
      } else {
       $br$2$ph$i = $call83$i;$ssize$2$ph$i = $and80$i;
       label = 136;
      }
     } else {
      $tsize$2647482$i = 0;
     }
    }
   } while(0);
   do {
    if ((label|0) == 128) {
     $call37$i = (_sbrk(0)|0);
     $cmp38$i = ($call37$i|0)==((-1)|0);
     if ($cmp38$i) {
      $tsize$2647482$i = 0;
     } else {
      $82 = $call37$i;
      $83 = HEAP32[(3136)>>2]|0;
      $sub41$i = (($83) + -1)|0;
      $and42$i = $sub41$i & $82;
      $cmp43$i = ($and42$i|0)==(0);
      $add46$i = (($sub41$i) + ($82))|0;
      $neg48$i = (0 - ($83))|0;
      $and49$i = $add46$i & $neg48$i;
      $sub50$i = (($and49$i) - ($82))|0;
      $add51$i = $cmp43$i ? 0 : $sub50$i;
      $spec$select96$i = (($add51$i) + ($and11$i))|0;
      $84 = HEAP32[(3092)>>2]|0;
      $add54$i = (($spec$select96$i) + ($84))|0;
      $cmp55$i = ($spec$select96$i>>>0)>($nb$0>>>0);
      $cmp57$i = ($spec$select96$i>>>0)<(2147483647);
      $or$cond$i = $cmp55$i & $cmp57$i;
      if ($or$cond$i) {
       $85 = HEAP32[(3100)>>2]|0;
       $cmp60$i = ($85|0)==(0);
       if (!($cmp60$i)) {
        $cmp63$i = ($add54$i>>>0)<=($84>>>0);
        $cmp66$i140 = ($add54$i>>>0)>($85>>>0);
        $or$cond2$i = $cmp63$i | $cmp66$i140;
        if ($or$cond2$i) {
         $tsize$2647482$i = 0;
         break;
        }
       }
       $call68$i = (_sbrk(($spec$select96$i|0))|0);
       $cmp69$i = ($call68$i|0)==($call37$i|0);
       if ($cmp69$i) {
        $tbase$795$i = $call37$i;$tsize$794$i = $spec$select96$i;
        label = 145;
        break L178;
       } else {
        $br$2$ph$i = $call68$i;$ssize$2$ph$i = $spec$select96$i;
        label = 136;
       }
      } else {
       $tsize$2647482$i = 0;
      }
     }
    }
   } while(0);
   do {
    if ((label|0) == 136) {
     $sub112$i = (0 - ($ssize$2$ph$i))|0;
     $cmp91$i = ($br$2$ph$i|0)!=((-1)|0);
     $cmp93$i = ($ssize$2$ph$i>>>0)<(2147483647);
     $or$cond5$i = $cmp93$i & $cmp91$i;
     $cmp96$i = ($add$i135>>>0)>($ssize$2$ph$i>>>0);
     $or$cond7$i = $cmp96$i & $or$cond5$i;
     if (!($or$cond7$i)) {
      $cmp118$i = ($br$2$ph$i|0)==((-1)|0);
      if ($cmp118$i) {
       $tsize$2647482$i = 0;
       break;
      } else {
       $tbase$795$i = $br$2$ph$i;$tsize$794$i = $ssize$2$ph$i;
       label = 145;
       break L178;
      }
     }
     $88 = HEAP32[(3140)>>2]|0;
     $sub99$i = (($sub$i136) - ($ssize$2$ph$i))|0;
     $add101$i = (($sub99$i) + ($88))|0;
     $neg103$i = (0 - ($88))|0;
     $and104$i = $add101$i & $neg103$i;
     $cmp105$i = ($and104$i>>>0)<(2147483647);
     if (!($cmp105$i)) {
      $tbase$795$i = $br$2$ph$i;$tsize$794$i = $ssize$2$ph$i;
      label = 145;
      break L178;
     }
     $call107$i = (_sbrk(($and104$i|0))|0);
     $cmp108$i = ($call107$i|0)==((-1)|0);
     if ($cmp108$i) {
      (_sbrk(($sub112$i|0))|0);
      $tsize$2647482$i = 0;
      break;
     } else {
      $add110$i = (($and104$i) + ($ssize$2$ph$i))|0;
      $tbase$795$i = $br$2$ph$i;$tsize$794$i = $add110$i;
      label = 145;
      break L178;
     }
    }
   } while(0);
   $89 = HEAP32[(3104)>>2]|0;
   $or$i = $89 | 4;
   HEAP32[(3104)>>2] = $or$i;
   $tsize$4$i = $tsize$2647482$i;
   label = 143;
  } else {
   $tsize$4$i = 0;
   label = 143;
  }
 } while(0);
 if ((label|0) == 143) {
  $cmp127$i = ($and11$i>>>0)<(2147483647);
  if ($cmp127$i) {
   $call131$i = (_sbrk(($and11$i|0))|0);
   $call132$i = (_sbrk(0)|0);
   $cmp133$i = ($call131$i|0)!=((-1)|0);
   $cmp135$i = ($call132$i|0)!=((-1)|0);
   $or$cond4$i = $cmp133$i & $cmp135$i;
   $cmp137$i = ($call131$i>>>0)<($call132$i>>>0);
   $or$cond8$i = $cmp137$i & $or$cond4$i;
   $sub$ptr$lhs$cast$i = $call132$i;
   $sub$ptr$rhs$cast$i = $call131$i;
   $sub$ptr$sub$i = (($sub$ptr$lhs$cast$i) - ($sub$ptr$rhs$cast$i))|0;
   $add140$i = (($nb$0) + 40)|0;
   $cmp141$i = ($sub$ptr$sub$i>>>0)>($add140$i>>>0);
   $spec$select9$i = $cmp141$i ? $sub$ptr$sub$i : $tsize$4$i;
   $or$cond8$not$i = $or$cond8$i ^ 1;
   $cmp14799$i = ($call131$i|0)==((-1)|0);
   $not$cmp141$i = $cmp141$i ^ 1;
   $cmp147$i = $cmp14799$i | $not$cmp141$i;
   $or$cond97$i = $cmp147$i | $or$cond8$not$i;
   if (!($or$cond97$i)) {
    $tbase$795$i = $call131$i;$tsize$794$i = $spec$select9$i;
    label = 145;
   }
  }
 }
 if ((label|0) == 145) {
  $90 = HEAP32[(3092)>>2]|0;
  $add150$i = (($90) + ($tsize$794$i))|0;
  HEAP32[(3092)>>2] = $add150$i;
  $91 = HEAP32[(3096)>>2]|0;
  $cmp151$i = ($add150$i>>>0)>($91>>>0);
  if ($cmp151$i) {
   HEAP32[(3096)>>2] = $add150$i;
  }
  $92 = HEAP32[(2684)>>2]|0;
  $cmp157$i = ($92|0)==(0|0);
  L215: do {
   if ($cmp157$i) {
    $93 = HEAP32[(2676)>>2]|0;
    $cmp159$i = ($93|0)==(0|0);
    $cmp162$i = ($tbase$795$i>>>0)<($93>>>0);
    $or$cond11$i = $cmp159$i | $cmp162$i;
    if ($or$cond11$i) {
     HEAP32[(2676)>>2] = $tbase$795$i;
    }
    HEAP32[(3108)>>2] = $tbase$795$i;
    HEAP32[(3112)>>2] = $tsize$794$i;
    HEAP32[(3120)>>2] = 0;
    $94 = HEAP32[783]|0;
    HEAP32[(2696)>>2] = $94;
    HEAP32[(2692)>>2] = -1;
    HEAP32[(2712)>>2] = (2700);
    HEAP32[(2708)>>2] = (2700);
    HEAP32[(2720)>>2] = (2708);
    HEAP32[(2716)>>2] = (2708);
    HEAP32[(2728)>>2] = (2716);
    HEAP32[(2724)>>2] = (2716);
    HEAP32[(2736)>>2] = (2724);
    HEAP32[(2732)>>2] = (2724);
    HEAP32[(2744)>>2] = (2732);
    HEAP32[(2740)>>2] = (2732);
    HEAP32[(2752)>>2] = (2740);
    HEAP32[(2748)>>2] = (2740);
    HEAP32[(2760)>>2] = (2748);
    HEAP32[(2756)>>2] = (2748);
    HEAP32[(2768)>>2] = (2756);
    HEAP32[(2764)>>2] = (2756);
    HEAP32[(2776)>>2] = (2764);
    HEAP32[(2772)>>2] = (2764);
    HEAP32[(2784)>>2] = (2772);
    HEAP32[(2780)>>2] = (2772);
    HEAP32[(2792)>>2] = (2780);
    HEAP32[(2788)>>2] = (2780);
    HEAP32[(2800)>>2] = (2788);
    HEAP32[(2796)>>2] = (2788);
    HEAP32[(2808)>>2] = (2796);
    HEAP32[(2804)>>2] = (2796);
    HEAP32[(2816)>>2] = (2804);
    HEAP32[(2812)>>2] = (2804);
    HEAP32[(2824)>>2] = (2812);
    HEAP32[(2820)>>2] = (2812);
    HEAP32[(2832)>>2] = (2820);
    HEAP32[(2828)>>2] = (2820);
    HEAP32[(2840)>>2] = (2828);
    HEAP32[(2836)>>2] = (2828);
    HEAP32[(2848)>>2] = (2836);
    HEAP32[(2844)>>2] = (2836);
    HEAP32[(2856)>>2] = (2844);
    HEAP32[(2852)>>2] = (2844);
    HEAP32[(2864)>>2] = (2852);
    HEAP32[(2860)>>2] = (2852);
    HEAP32[(2872)>>2] = (2860);
    HEAP32[(2868)>>2] = (2860);
    HEAP32[(2880)>>2] = (2868);
    HEAP32[(2876)>>2] = (2868);
    HEAP32[(2888)>>2] = (2876);
    HEAP32[(2884)>>2] = (2876);
    HEAP32[(2896)>>2] = (2884);
    HEAP32[(2892)>>2] = (2884);
    HEAP32[(2904)>>2] = (2892);
    HEAP32[(2900)>>2] = (2892);
    HEAP32[(2912)>>2] = (2900);
    HEAP32[(2908)>>2] = (2900);
    HEAP32[(2920)>>2] = (2908);
    HEAP32[(2916)>>2] = (2908);
    HEAP32[(2928)>>2] = (2916);
    HEAP32[(2924)>>2] = (2916);
    HEAP32[(2936)>>2] = (2924);
    HEAP32[(2932)>>2] = (2924);
    HEAP32[(2944)>>2] = (2932);
    HEAP32[(2940)>>2] = (2932);
    HEAP32[(2952)>>2] = (2940);
    HEAP32[(2948)>>2] = (2940);
    HEAP32[(2960)>>2] = (2948);
    HEAP32[(2956)>>2] = (2948);
    $sub172$i = (($tsize$794$i) + -40)|0;
    $add$ptr$i43$i = ((($tbase$795$i)) + 8|0);
    $95 = $add$ptr$i43$i;
    $and$i44$i = $95 & 7;
    $cmp$i45$i = ($and$i44$i|0)==(0);
    $sub$i46$i = (0 - ($95))|0;
    $and3$i47$i = $sub$i46$i & 7;
    $cond$i48$i = $cmp$i45$i ? 0 : $and3$i47$i;
    $add$ptr4$i49$i = (($tbase$795$i) + ($cond$i48$i)|0);
    $sub5$i50$i = (($sub172$i) - ($cond$i48$i))|0;
    HEAP32[(2684)>>2] = $add$ptr4$i49$i;
    HEAP32[(2672)>>2] = $sub5$i50$i;
    $or$i51$i = $sub5$i50$i | 1;
    $head$i52$i = ((($add$ptr4$i49$i)) + 4|0);
    HEAP32[$head$i52$i>>2] = $or$i51$i;
    $add$ptr6$i53$i = (($tbase$795$i) + ($sub172$i)|0);
    $head7$i54$i = ((($add$ptr6$i53$i)) + 4|0);
    HEAP32[$head7$i54$i>>2] = 40;
    $96 = HEAP32[(3148)>>2]|0;
    HEAP32[(2688)>>2] = $96;
   } else {
    $sp$0112$i = (3108);
    while(1) {
     $97 = HEAP32[$sp$0112$i>>2]|0;
     $size188$i = ((($sp$0112$i)) + 4|0);
     $98 = HEAP32[$size188$i>>2]|0;
     $add$ptr189$i = (($97) + ($98)|0);
     $cmp190$i = ($tbase$795$i|0)==($add$ptr189$i|0);
     if ($cmp190$i) {
      label = 154;
      break;
     }
     $next$i = ((($sp$0112$i)) + 8|0);
     $99 = HEAP32[$next$i>>2]|0;
     $cmp186$i = ($99|0)==(0|0);
     if ($cmp186$i) {
      break;
     } else {
      $sp$0112$i = $99;
     }
    }
    if ((label|0) == 154) {
     $size188$i$le = ((($sp$0112$i)) + 4|0);
     $sflags193$i = ((($sp$0112$i)) + 12|0);
     $100 = HEAP32[$sflags193$i>>2]|0;
     $and194$i = $100 & 8;
     $tobool195$i = ($and194$i|0)==(0);
     if ($tobool195$i) {
      $cmp203$i = ($97>>>0)<=($92>>>0);
      $cmp209$i = ($tbase$795$i>>>0)>($92>>>0);
      $or$cond98$i = $cmp209$i & $cmp203$i;
      if ($or$cond98$i) {
       $add212$i = (($98) + ($tsize$794$i))|0;
       HEAP32[$size188$i$le>>2] = $add212$i;
       $101 = HEAP32[(2672)>>2]|0;
       $add215$i = (($101) + ($tsize$794$i))|0;
       $add$ptr$i35$i = ((($92)) + 8|0);
       $102 = $add$ptr$i35$i;
       $and$i36$i = $102 & 7;
       $cmp$i37$i = ($and$i36$i|0)==(0);
       $sub$i38$i = (0 - ($102))|0;
       $and3$i39$i = $sub$i38$i & 7;
       $cond$i40$i = $cmp$i37$i ? 0 : $and3$i39$i;
       $add$ptr4$i41$i = (($92) + ($cond$i40$i)|0);
       $sub5$i$i = (($add215$i) - ($cond$i40$i))|0;
       HEAP32[(2684)>>2] = $add$ptr4$i41$i;
       HEAP32[(2672)>>2] = $sub5$i$i;
       $or$i$i = $sub5$i$i | 1;
       $head$i42$i = ((($add$ptr4$i41$i)) + 4|0);
       HEAP32[$head$i42$i>>2] = $or$i$i;
       $add$ptr6$i$i = (($92) + ($add215$i)|0);
       $head7$i$i = ((($add$ptr6$i$i)) + 4|0);
       HEAP32[$head7$i$i>>2] = 40;
       $103 = HEAP32[(3148)>>2]|0;
       HEAP32[(2688)>>2] = $103;
       break;
      }
     }
    }
    $104 = HEAP32[(2676)>>2]|0;
    $cmp218$i = ($tbase$795$i>>>0)<($104>>>0);
    if ($cmp218$i) {
     HEAP32[(2676)>>2] = $tbase$795$i;
    }
    $add$ptr227$i = (($tbase$795$i) + ($tsize$794$i)|0);
    $sp$1111$i = (3108);
    while(1) {
     $105 = HEAP32[$sp$1111$i>>2]|0;
     $cmp228$i = ($105|0)==($add$ptr227$i|0);
     if ($cmp228$i) {
      label = 162;
      break;
     }
     $next231$i = ((($sp$1111$i)) + 8|0);
     $106 = HEAP32[$next231$i>>2]|0;
     $cmp224$i = ($106|0)==(0|0);
     if ($cmp224$i) {
      break;
     } else {
      $sp$1111$i = $106;
     }
    }
    if ((label|0) == 162) {
     $sflags235$i = ((($sp$1111$i)) + 12|0);
     $107 = HEAP32[$sflags235$i>>2]|0;
     $and236$i = $107 & 8;
     $tobool237$i = ($and236$i|0)==(0);
     if ($tobool237$i) {
      HEAP32[$sp$1111$i>>2] = $tbase$795$i;
      $size245$i = ((($sp$1111$i)) + 4|0);
      $108 = HEAP32[$size245$i>>2]|0;
      $add246$i = (($108) + ($tsize$794$i))|0;
      HEAP32[$size245$i>>2] = $add246$i;
      $add$ptr$i$i = ((($tbase$795$i)) + 8|0);
      $109 = $add$ptr$i$i;
      $and$i14$i = $109 & 7;
      $cmp$i15$i = ($and$i14$i|0)==(0);
      $sub$i16$i = (0 - ($109))|0;
      $and3$i$i = $sub$i16$i & 7;
      $cond$i17$i = $cmp$i15$i ? 0 : $and3$i$i;
      $add$ptr4$i$i = (($tbase$795$i) + ($cond$i17$i)|0);
      $add$ptr5$i$i = ((($add$ptr227$i)) + 8|0);
      $110 = $add$ptr5$i$i;
      $and6$i18$i = $110 & 7;
      $cmp7$i$i = ($and6$i18$i|0)==(0);
      $sub12$i$i = (0 - ($110))|0;
      $and13$i$i = $sub12$i$i & 7;
      $cond15$i$i = $cmp7$i$i ? 0 : $and13$i$i;
      $add$ptr16$i$i = (($add$ptr227$i) + ($cond15$i$i)|0);
      $sub$ptr$lhs$cast$i19$i = $add$ptr16$i$i;
      $sub$ptr$rhs$cast$i20$i = $add$ptr4$i$i;
      $sub$ptr$sub$i21$i = (($sub$ptr$lhs$cast$i19$i) - ($sub$ptr$rhs$cast$i20$i))|0;
      $add$ptr17$i$i = (($add$ptr4$i$i) + ($nb$0)|0);
      $sub18$i$i = (($sub$ptr$sub$i21$i) - ($nb$0))|0;
      $or19$i$i = $nb$0 | 3;
      $head$i22$i = ((($add$ptr4$i$i)) + 4|0);
      HEAP32[$head$i22$i>>2] = $or19$i$i;
      $cmp20$i$i = ($92|0)==($add$ptr16$i$i|0);
      L238: do {
       if ($cmp20$i$i) {
        $111 = HEAP32[(2672)>>2]|0;
        $add$i$i = (($111) + ($sub18$i$i))|0;
        HEAP32[(2672)>>2] = $add$i$i;
        HEAP32[(2684)>>2] = $add$ptr17$i$i;
        $or22$i$i = $add$i$i | 1;
        $head23$i$i = ((($add$ptr17$i$i)) + 4|0);
        HEAP32[$head23$i$i>>2] = $or22$i$i;
       } else {
        $112 = HEAP32[(2680)>>2]|0;
        $cmp24$i$i = ($112|0)==($add$ptr16$i$i|0);
        if ($cmp24$i$i) {
         $113 = HEAP32[(2668)>>2]|0;
         $add26$i$i = (($113) + ($sub18$i$i))|0;
         HEAP32[(2668)>>2] = $add26$i$i;
         HEAP32[(2680)>>2] = $add$ptr17$i$i;
         $or28$i$i = $add26$i$i | 1;
         $head29$i$i = ((($add$ptr17$i$i)) + 4|0);
         HEAP32[$head29$i$i>>2] = $or28$i$i;
         $add$ptr30$i$i = (($add$ptr17$i$i) + ($add26$i$i)|0);
         HEAP32[$add$ptr30$i$i>>2] = $add26$i$i;
         break;
        }
        $head32$i$i = ((($add$ptr16$i$i)) + 4|0);
        $114 = HEAP32[$head32$i$i>>2]|0;
        $and33$i$i = $114 & 3;
        $cmp34$i$i = ($and33$i$i|0)==(1);
        if ($cmp34$i$i) {
         $and37$i$i = $114 & -8;
         $shr$i25$i = $114 >>> 3;
         $cmp38$i$i = ($114>>>0)<(256);
         L246: do {
          if ($cmp38$i$i) {
           $fd$i$i = ((($add$ptr16$i$i)) + 8|0);
           $115 = HEAP32[$fd$i$i>>2]|0;
           $bk$i26$i = ((($add$ptr16$i$i)) + 12|0);
           $116 = HEAP32[$bk$i26$i>>2]|0;
           $cmp46$i$i = ($116|0)==($115|0);
           if ($cmp46$i$i) {
            $shl48$i$i = 1 << $shr$i25$i;
            $neg$i$i = $shl48$i$i ^ -1;
            $117 = HEAP32[665]|0;
            $and49$i$i = $117 & $neg$i$i;
            HEAP32[665] = $and49$i$i;
            break;
           } else {
            $bk67$i$i = ((($115)) + 12|0);
            HEAP32[$bk67$i$i>>2] = $116;
            $fd68$i$i = ((($116)) + 8|0);
            HEAP32[$fd68$i$i>>2] = $115;
            break;
           }
          } else {
           $parent$i27$i = ((($add$ptr16$i$i)) + 24|0);
           $118 = HEAP32[$parent$i27$i>>2]|0;
           $bk74$i$i = ((($add$ptr16$i$i)) + 12|0);
           $119 = HEAP32[$bk74$i$i>>2]|0;
           $cmp75$i$i = ($119|0)==($add$ptr16$i$i|0);
           do {
            if ($cmp75$i$i) {
             $child$i$i = ((($add$ptr16$i$i)) + 16|0);
             $arrayidx96$i$i = ((($child$i$i)) + 4|0);
             $121 = HEAP32[$arrayidx96$i$i>>2]|0;
             $cmp97$i$i = ($121|0)==(0|0);
             if ($cmp97$i$i) {
              $122 = HEAP32[$child$i$i>>2]|0;
              $cmp100$i$i = ($122|0)==(0|0);
              if ($cmp100$i$i) {
               $R$3$i$i = 0;
               break;
              } else {
               $R$1$i$i$ph = $122;$RP$1$i$i$ph = $child$i$i;
              }
             } else {
              $R$1$i$i$ph = $121;$RP$1$i$i$ph = $arrayidx96$i$i;
             }
             $R$1$i$i = $R$1$i$i$ph;$RP$1$i$i = $RP$1$i$i$ph;
             while(1) {
              $arrayidx103$i$i = ((($R$1$i$i)) + 20|0);
              $123 = HEAP32[$arrayidx103$i$i>>2]|0;
              $cmp104$i$i = ($123|0)==(0|0);
              if ($cmp104$i$i) {
               $arrayidx107$i$i = ((($R$1$i$i)) + 16|0);
               $124 = HEAP32[$arrayidx107$i$i>>2]|0;
               $cmp108$i$i = ($124|0)==(0|0);
               if ($cmp108$i$i) {
                break;
               } else {
                $R$1$i$i$be = $124;$RP$1$i$i$be = $arrayidx107$i$i;
               }
              } else {
               $R$1$i$i$be = $123;$RP$1$i$i$be = $arrayidx103$i$i;
              }
              $R$1$i$i = $R$1$i$i$be;$RP$1$i$i = $RP$1$i$i$be;
             }
             HEAP32[$RP$1$i$i>>2] = 0;
             $R$3$i$i = $R$1$i$i;
            } else {
             $fd78$i$i = ((($add$ptr16$i$i)) + 8|0);
             $120 = HEAP32[$fd78$i$i>>2]|0;
             $bk91$i$i = ((($120)) + 12|0);
             HEAP32[$bk91$i$i>>2] = $119;
             $fd92$i$i = ((($119)) + 8|0);
             HEAP32[$fd92$i$i>>2] = $120;
             $R$3$i$i = $119;
            }
           } while(0);
           $cmp120$i28$i = ($118|0)==(0|0);
           if ($cmp120$i28$i) {
            break;
           }
           $index$i29$i = ((($add$ptr16$i$i)) + 28|0);
           $125 = HEAP32[$index$i29$i>>2]|0;
           $arrayidx123$i$i = (2964 + ($125<<2)|0);
           $126 = HEAP32[$arrayidx123$i$i>>2]|0;
           $cmp124$i$i = ($126|0)==($add$ptr16$i$i|0);
           do {
            if ($cmp124$i$i) {
             HEAP32[$arrayidx123$i$i>>2] = $R$3$i$i;
             $cond1$i$i = ($R$3$i$i|0)==(0|0);
             if (!($cond1$i$i)) {
              break;
             }
             $shl131$i$i = 1 << $125;
             $neg132$i$i = $shl131$i$i ^ -1;
             $127 = HEAP32[(2664)>>2]|0;
             $and133$i$i = $127 & $neg132$i$i;
             HEAP32[(2664)>>2] = $and133$i$i;
             break L246;
            } else {
             $arrayidx143$i$i = ((($118)) + 16|0);
             $128 = HEAP32[$arrayidx143$i$i>>2]|0;
             $cmp144$i$i = ($128|0)==($add$ptr16$i$i|0);
             $arrayidx151$i$i = ((($118)) + 20|0);
             $arrayidx151$i$i$sink = $cmp144$i$i ? $arrayidx143$i$i : $arrayidx151$i$i;
             HEAP32[$arrayidx151$i$i$sink>>2] = $R$3$i$i;
             $cmp156$i$i = ($R$3$i$i|0)==(0|0);
             if ($cmp156$i$i) {
              break L246;
             }
            }
           } while(0);
           $parent165$i$i = ((($R$3$i$i)) + 24|0);
           HEAP32[$parent165$i$i>>2] = $118;
           $child166$i$i = ((($add$ptr16$i$i)) + 16|0);
           $129 = HEAP32[$child166$i$i>>2]|0;
           $cmp168$i$i = ($129|0)==(0|0);
           if (!($cmp168$i$i)) {
            $arrayidx178$i$i = ((($R$3$i$i)) + 16|0);
            HEAP32[$arrayidx178$i$i>>2] = $129;
            $parent179$i$i = ((($129)) + 24|0);
            HEAP32[$parent179$i$i>>2] = $R$3$i$i;
           }
           $arrayidx184$i$i = ((($child166$i$i)) + 4|0);
           $130 = HEAP32[$arrayidx184$i$i>>2]|0;
           $cmp185$i$i = ($130|0)==(0|0);
           if ($cmp185$i$i) {
            break;
           }
           $arrayidx195$i$i = ((($R$3$i$i)) + 20|0);
           HEAP32[$arrayidx195$i$i>>2] = $130;
           $parent196$i$i = ((($130)) + 24|0);
           HEAP32[$parent196$i$i>>2] = $R$3$i$i;
          }
         } while(0);
         $add$ptr205$i$i = (($add$ptr16$i$i) + ($and37$i$i)|0);
         $add206$i$i = (($and37$i$i) + ($sub18$i$i))|0;
         $oldfirst$0$i$i = $add$ptr205$i$i;$qsize$0$i$i = $add206$i$i;
        } else {
         $oldfirst$0$i$i = $add$ptr16$i$i;$qsize$0$i$i = $sub18$i$i;
        }
        $head208$i$i = ((($oldfirst$0$i$i)) + 4|0);
        $131 = HEAP32[$head208$i$i>>2]|0;
        $and209$i$i = $131 & -2;
        HEAP32[$head208$i$i>>2] = $and209$i$i;
        $or210$i$i = $qsize$0$i$i | 1;
        $head211$i$i = ((($add$ptr17$i$i)) + 4|0);
        HEAP32[$head211$i$i>>2] = $or210$i$i;
        $add$ptr212$i$i = (($add$ptr17$i$i) + ($qsize$0$i$i)|0);
        HEAP32[$add$ptr212$i$i>>2] = $qsize$0$i$i;
        $shr214$i$i = $qsize$0$i$i >>> 3;
        $cmp215$i$i = ($qsize$0$i$i>>>0)<(256);
        if ($cmp215$i$i) {
         $shl222$i$i = $shr214$i$i << 1;
         $arrayidx223$i$i = (2700 + ($shl222$i$i<<2)|0);
         $132 = HEAP32[665]|0;
         $shl226$i$i = 1 << $shr214$i$i;
         $and227$i$i = $132 & $shl226$i$i;
         $tobool228$i$i = ($and227$i$i|0)==(0);
         if ($tobool228$i$i) {
          $or232$i$i = $132 | $shl226$i$i;
          HEAP32[665] = $or232$i$i;
          $$pre$i31$i = ((($arrayidx223$i$i)) + 8|0);
          $$pre$phi$i32$iZ2D = $$pre$i31$i;$F224$0$i$i = $arrayidx223$i$i;
         } else {
          $133 = ((($arrayidx223$i$i)) + 8|0);
          $134 = HEAP32[$133>>2]|0;
          $$pre$phi$i32$iZ2D = $133;$F224$0$i$i = $134;
         }
         HEAP32[$$pre$phi$i32$iZ2D>>2] = $add$ptr17$i$i;
         $bk246$i$i = ((($F224$0$i$i)) + 12|0);
         HEAP32[$bk246$i$i>>2] = $add$ptr17$i$i;
         $fd247$i$i = ((($add$ptr17$i$i)) + 8|0);
         HEAP32[$fd247$i$i>>2] = $F224$0$i$i;
         $bk248$i$i = ((($add$ptr17$i$i)) + 12|0);
         HEAP32[$bk248$i$i>>2] = $arrayidx223$i$i;
         break;
        }
        $shr253$i$i = $qsize$0$i$i >>> 8;
        $cmp254$i$i = ($shr253$i$i|0)==(0);
        do {
         if ($cmp254$i$i) {
          $I252$0$i$i = 0;
         } else {
          $cmp258$i$i = ($qsize$0$i$i>>>0)>(16777215);
          if ($cmp258$i$i) {
           $I252$0$i$i = 31;
           break;
          }
          $sub262$i$i = (($shr253$i$i) + 1048320)|0;
          $shr263$i$i = $sub262$i$i >>> 16;
          $and264$i$i = $shr263$i$i & 8;
          $shl265$i$i = $shr253$i$i << $and264$i$i;
          $sub266$i$i = (($shl265$i$i) + 520192)|0;
          $shr267$i$i = $sub266$i$i >>> 16;
          $and268$i$i = $shr267$i$i & 4;
          $add269$i$i = $and268$i$i | $and264$i$i;
          $shl270$i$i = $shl265$i$i << $and268$i$i;
          $sub271$i$i = (($shl270$i$i) + 245760)|0;
          $shr272$i$i = $sub271$i$i >>> 16;
          $and273$i$i = $shr272$i$i & 2;
          $add274$i$i = $add269$i$i | $and273$i$i;
          $sub275$i$i = (14 - ($add274$i$i))|0;
          $shl276$i$i = $shl270$i$i << $and273$i$i;
          $shr277$i$i = $shl276$i$i >>> 15;
          $add278$i$i = (($sub275$i$i) + ($shr277$i$i))|0;
          $shl279$i$i = $add278$i$i << 1;
          $add280$i$i = (($add278$i$i) + 7)|0;
          $shr281$i$i = $qsize$0$i$i >>> $add280$i$i;
          $and282$i$i = $shr281$i$i & 1;
          $add283$i$i = $and282$i$i | $shl279$i$i;
          $I252$0$i$i = $add283$i$i;
         }
        } while(0);
        $arrayidx287$i$i = (2964 + ($I252$0$i$i<<2)|0);
        $index288$i$i = ((($add$ptr17$i$i)) + 28|0);
        HEAP32[$index288$i$i>>2] = $I252$0$i$i;
        $child289$i$i = ((($add$ptr17$i$i)) + 16|0);
        $arrayidx290$i$i = ((($child289$i$i)) + 4|0);
        HEAP32[$arrayidx290$i$i>>2] = 0;
        HEAP32[$child289$i$i>>2] = 0;
        $135 = HEAP32[(2664)>>2]|0;
        $shl294$i$i = 1 << $I252$0$i$i;
        $and295$i$i = $135 & $shl294$i$i;
        $tobool296$i$i = ($and295$i$i|0)==(0);
        if ($tobool296$i$i) {
         $or300$i$i = $135 | $shl294$i$i;
         HEAP32[(2664)>>2] = $or300$i$i;
         HEAP32[$arrayidx287$i$i>>2] = $add$ptr17$i$i;
         $parent301$i$i = ((($add$ptr17$i$i)) + 24|0);
         HEAP32[$parent301$i$i>>2] = $arrayidx287$i$i;
         $bk302$i$i = ((($add$ptr17$i$i)) + 12|0);
         HEAP32[$bk302$i$i>>2] = $add$ptr17$i$i;
         $fd303$i$i = ((($add$ptr17$i$i)) + 8|0);
         HEAP32[$fd303$i$i>>2] = $add$ptr17$i$i;
         break;
        }
        $136 = HEAP32[$arrayidx287$i$i>>2]|0;
        $head3174$i$i = ((($136)) + 4|0);
        $137 = HEAP32[$head3174$i$i>>2]|0;
        $and3185$i$i = $137 & -8;
        $cmp3196$i$i = ($and3185$i$i|0)==($qsize$0$i$i|0);
        L291: do {
         if ($cmp3196$i$i) {
          $T$0$lcssa$i34$i = $136;
         } else {
          $cmp306$i$i = ($I252$0$i$i|0)==(31);
          $shr310$i$i = $I252$0$i$i >>> 1;
          $sub313$i$i = (25 - ($shr310$i$i))|0;
          $cond315$i$i = $cmp306$i$i ? 0 : $sub313$i$i;
          $shl316$i$i = $qsize$0$i$i << $cond315$i$i;
          $K305$08$i$i = $shl316$i$i;$T$07$i$i = $136;
          while(1) {
           $shr323$i$i = $K305$08$i$i >>> 31;
           $arrayidx325$i$i = (((($T$07$i$i)) + 16|0) + ($shr323$i$i<<2)|0);
           $138 = HEAP32[$arrayidx325$i$i>>2]|0;
           $cmp327$i$i = ($138|0)==(0|0);
           if ($cmp327$i$i) {
            break;
           }
           $shl326$i$i = $K305$08$i$i << 1;
           $head317$i$i = ((($138)) + 4|0);
           $139 = HEAP32[$head317$i$i>>2]|0;
           $and318$i$i = $139 & -8;
           $cmp319$i$i = ($and318$i$i|0)==($qsize$0$i$i|0);
           if ($cmp319$i$i) {
            $T$0$lcssa$i34$i = $138;
            break L291;
           } else {
            $K305$08$i$i = $shl326$i$i;$T$07$i$i = $138;
           }
          }
          HEAP32[$arrayidx325$i$i>>2] = $add$ptr17$i$i;
          $parent337$i$i = ((($add$ptr17$i$i)) + 24|0);
          HEAP32[$parent337$i$i>>2] = $T$07$i$i;
          $bk338$i$i = ((($add$ptr17$i$i)) + 12|0);
          HEAP32[$bk338$i$i>>2] = $add$ptr17$i$i;
          $fd339$i$i = ((($add$ptr17$i$i)) + 8|0);
          HEAP32[$fd339$i$i>>2] = $add$ptr17$i$i;
          break L238;
         }
        } while(0);
        $fd344$i$i = ((($T$0$lcssa$i34$i)) + 8|0);
        $140 = HEAP32[$fd344$i$i>>2]|0;
        $bk357$i$i = ((($140)) + 12|0);
        HEAP32[$bk357$i$i>>2] = $add$ptr17$i$i;
        HEAP32[$fd344$i$i>>2] = $add$ptr17$i$i;
        $fd359$i$i = ((($add$ptr17$i$i)) + 8|0);
        HEAP32[$fd359$i$i>>2] = $140;
        $bk360$i$i = ((($add$ptr17$i$i)) + 12|0);
        HEAP32[$bk360$i$i>>2] = $T$0$lcssa$i34$i;
        $parent361$i$i = ((($add$ptr17$i$i)) + 24|0);
        HEAP32[$parent361$i$i>>2] = 0;
       }
      } while(0);
      $add$ptr369$i$i = ((($add$ptr4$i$i)) + 8|0);
      $retval$0 = $add$ptr369$i$i;
      STACKTOP = sp;return ($retval$0|0);
     }
    }
    $sp$0$i$i$i = (3108);
    while(1) {
     $141 = HEAP32[$sp$0$i$i$i>>2]|0;
     $cmp$i$i$i = ($141>>>0)>($92>>>0);
     if (!($cmp$i$i$i)) {
      $size$i$i$i = ((($sp$0$i$i$i)) + 4|0);
      $142 = HEAP32[$size$i$i$i>>2]|0;
      $add$ptr$i$i$i = (($141) + ($142)|0);
      $cmp2$i$i$i = ($add$ptr$i$i$i>>>0)>($92>>>0);
      if ($cmp2$i$i$i) {
       break;
      }
     }
     $next$i$i$i = ((($sp$0$i$i$i)) + 8|0);
     $143 = HEAP32[$next$i$i$i>>2]|0;
     $sp$0$i$i$i = $143;
    }
    $add$ptr2$i$i = ((($add$ptr$i$i$i)) + -47|0);
    $add$ptr3$i$i = ((($add$ptr2$i$i)) + 8|0);
    $144 = $add$ptr3$i$i;
    $and$i$i = $144 & 7;
    $cmp$i12$i = ($and$i$i|0)==(0);
    $sub$i$i = (0 - ($144))|0;
    $and6$i13$i = $sub$i$i & 7;
    $cond$i$i = $cmp$i12$i ? 0 : $and6$i13$i;
    $add$ptr7$i$i = (($add$ptr2$i$i) + ($cond$i$i)|0);
    $add$ptr81$i$i = ((($92)) + 16|0);
    $cmp9$i$i = ($add$ptr7$i$i>>>0)<($add$ptr81$i$i>>>0);
    $cond13$i$i = $cmp9$i$i ? $92 : $add$ptr7$i$i;
    $add$ptr14$i$i = ((($cond13$i$i)) + 8|0);
    $add$ptr15$i$i = ((($cond13$i$i)) + 24|0);
    $sub16$i$i = (($tsize$794$i) + -40)|0;
    $add$ptr$i2$i$i = ((($tbase$795$i)) + 8|0);
    $145 = $add$ptr$i2$i$i;
    $and$i$i$i = $145 & 7;
    $cmp$i3$i$i = ($and$i$i$i|0)==(0);
    $sub$i$i$i = (0 - ($145))|0;
    $and3$i$i$i = $sub$i$i$i & 7;
    $cond$i$i$i = $cmp$i3$i$i ? 0 : $and3$i$i$i;
    $add$ptr4$i$i$i = (($tbase$795$i) + ($cond$i$i$i)|0);
    $sub5$i$i$i = (($sub16$i$i) - ($cond$i$i$i))|0;
    HEAP32[(2684)>>2] = $add$ptr4$i$i$i;
    HEAP32[(2672)>>2] = $sub5$i$i$i;
    $or$i$i$i = $sub5$i$i$i | 1;
    $head$i$i$i = ((($add$ptr4$i$i$i)) + 4|0);
    HEAP32[$head$i$i$i>>2] = $or$i$i$i;
    $add$ptr6$i$i$i = (($tbase$795$i) + ($sub16$i$i)|0);
    $head7$i$i$i = ((($add$ptr6$i$i$i)) + 4|0);
    HEAP32[$head7$i$i$i>>2] = 40;
    $146 = HEAP32[(3148)>>2]|0;
    HEAP32[(2688)>>2] = $146;
    $head$i$i = ((($cond13$i$i)) + 4|0);
    HEAP32[$head$i$i>>2] = 27;
    ;HEAP32[$add$ptr14$i$i>>2]=HEAP32[(3108)>>2]|0;HEAP32[$add$ptr14$i$i+4>>2]=HEAP32[(3108)+4>>2]|0;HEAP32[$add$ptr14$i$i+8>>2]=HEAP32[(3108)+8>>2]|0;HEAP32[$add$ptr14$i$i+12>>2]=HEAP32[(3108)+12>>2]|0;
    HEAP32[(3108)>>2] = $tbase$795$i;
    HEAP32[(3112)>>2] = $tsize$794$i;
    HEAP32[(3120)>>2] = 0;
    HEAP32[(3116)>>2] = $add$ptr14$i$i;
    $147 = $add$ptr15$i$i;
    while(1) {
     $add$ptr24$i$i = ((($147)) + 4|0);
     HEAP32[$add$ptr24$i$i>>2] = 7;
     $head26$i$i = ((($147)) + 8|0);
     $cmp27$i$i = ($head26$i$i>>>0)<($add$ptr$i$i$i>>>0);
     if ($cmp27$i$i) {
      $147 = $add$ptr24$i$i;
     } else {
      break;
     }
    }
    $cmp28$i$i = ($cond13$i$i|0)==($92|0);
    if (!($cmp28$i$i)) {
     $sub$ptr$lhs$cast$i$i = $cond13$i$i;
     $sub$ptr$rhs$cast$i$i = $92;
     $sub$ptr$sub$i$i = (($sub$ptr$lhs$cast$i$i) - ($sub$ptr$rhs$cast$i$i))|0;
     $148 = HEAP32[$head$i$i>>2]|0;
     $and32$i$i = $148 & -2;
     HEAP32[$head$i$i>>2] = $and32$i$i;
     $or33$i$i = $sub$ptr$sub$i$i | 1;
     $head34$i$i = ((($92)) + 4|0);
     HEAP32[$head34$i$i>>2] = $or33$i$i;
     HEAP32[$cond13$i$i>>2] = $sub$ptr$sub$i$i;
     $shr$i$i = $sub$ptr$sub$i$i >>> 3;
     $cmp36$i$i = ($sub$ptr$sub$i$i>>>0)<(256);
     if ($cmp36$i$i) {
      $shl$i$i = $shr$i$i << 1;
      $arrayidx$i$i = (2700 + ($shl$i$i<<2)|0);
      $149 = HEAP32[665]|0;
      $shl39$i$i = 1 << $shr$i$i;
      $and40$i$i = $149 & $shl39$i$i;
      $tobool$i$i = ($and40$i$i|0)==(0);
      if ($tobool$i$i) {
       $or44$i$i = $149 | $shl39$i$i;
       HEAP32[665] = $or44$i$i;
       $$pre$i$i = ((($arrayidx$i$i)) + 8|0);
       $$pre$phi$i$iZ2D = $$pre$i$i;$F$0$i$i = $arrayidx$i$i;
      } else {
       $150 = ((($arrayidx$i$i)) + 8|0);
       $151 = HEAP32[$150>>2]|0;
       $$pre$phi$i$iZ2D = $150;$F$0$i$i = $151;
      }
      HEAP32[$$pre$phi$i$iZ2D>>2] = $92;
      $bk$i$i = ((($F$0$i$i)) + 12|0);
      HEAP32[$bk$i$i>>2] = $92;
      $fd54$i$i = ((($92)) + 8|0);
      HEAP32[$fd54$i$i>>2] = $F$0$i$i;
      $bk55$i$i = ((($92)) + 12|0);
      HEAP32[$bk55$i$i>>2] = $arrayidx$i$i;
      break;
     }
     $shr58$i$i = $sub$ptr$sub$i$i >>> 8;
     $cmp59$i$i = ($shr58$i$i|0)==(0);
     if ($cmp59$i$i) {
      $I57$0$i$i = 0;
     } else {
      $cmp63$i$i = ($sub$ptr$sub$i$i>>>0)>(16777215);
      if ($cmp63$i$i) {
       $I57$0$i$i = 31;
      } else {
       $sub67$i$i = (($shr58$i$i) + 1048320)|0;
       $shr68$i$i = $sub67$i$i >>> 16;
       $and69$i$i = $shr68$i$i & 8;
       $shl70$i$i = $shr58$i$i << $and69$i$i;
       $sub71$i$i = (($shl70$i$i) + 520192)|0;
       $shr72$i$i = $sub71$i$i >>> 16;
       $and73$i$i = $shr72$i$i & 4;
       $add74$i$i = $and73$i$i | $and69$i$i;
       $shl75$i$i = $shl70$i$i << $and73$i$i;
       $sub76$i$i = (($shl75$i$i) + 245760)|0;
       $shr77$i$i = $sub76$i$i >>> 16;
       $and78$i$i = $shr77$i$i & 2;
       $add79$i$i = $add74$i$i | $and78$i$i;
       $sub80$i$i = (14 - ($add79$i$i))|0;
       $shl81$i$i = $shl75$i$i << $and78$i$i;
       $shr82$i$i = $shl81$i$i >>> 15;
       $add83$i$i = (($sub80$i$i) + ($shr82$i$i))|0;
       $shl84$i$i = $add83$i$i << 1;
       $add85$i$i = (($add83$i$i) + 7)|0;
       $shr86$i$i = $sub$ptr$sub$i$i >>> $add85$i$i;
       $and87$i$i = $shr86$i$i & 1;
       $add88$i$i = $and87$i$i | $shl84$i$i;
       $I57$0$i$i = $add88$i$i;
      }
     }
     $arrayidx91$i$i = (2964 + ($I57$0$i$i<<2)|0);
     $index$i$i = ((($92)) + 28|0);
     HEAP32[$index$i$i>>2] = $I57$0$i$i;
     $arrayidx92$i$i = ((($92)) + 20|0);
     HEAP32[$arrayidx92$i$i>>2] = 0;
     HEAP32[$add$ptr81$i$i>>2] = 0;
     $152 = HEAP32[(2664)>>2]|0;
     $shl95$i$i = 1 << $I57$0$i$i;
     $and96$i$i = $152 & $shl95$i$i;
     $tobool97$i$i = ($and96$i$i|0)==(0);
     if ($tobool97$i$i) {
      $or101$i$i = $152 | $shl95$i$i;
      HEAP32[(2664)>>2] = $or101$i$i;
      HEAP32[$arrayidx91$i$i>>2] = $92;
      $parent$i$i = ((($92)) + 24|0);
      HEAP32[$parent$i$i>>2] = $arrayidx91$i$i;
      $bk102$i$i = ((($92)) + 12|0);
      HEAP32[$bk102$i$i>>2] = $92;
      $fd103$i$i = ((($92)) + 8|0);
      HEAP32[$fd103$i$i>>2] = $92;
      break;
     }
     $153 = HEAP32[$arrayidx91$i$i>>2]|0;
     $head1186$i$i = ((($153)) + 4|0);
     $154 = HEAP32[$head1186$i$i>>2]|0;
     $and1197$i$i = $154 & -8;
     $cmp1208$i$i = ($and1197$i$i|0)==($sub$ptr$sub$i$i|0);
     L325: do {
      if ($cmp1208$i$i) {
       $T$0$lcssa$i$i = $153;
      } else {
       $cmp106$i$i = ($I57$0$i$i|0)==(31);
       $shr110$i$i = $I57$0$i$i >>> 1;
       $sub113$i$i = (25 - ($shr110$i$i))|0;
       $cond115$i$i = $cmp106$i$i ? 0 : $sub113$i$i;
       $shl116$i$i = $sub$ptr$sub$i$i << $cond115$i$i;
       $K105$010$i$i = $shl116$i$i;$T$09$i$i = $153;
       while(1) {
        $shr124$i$i = $K105$010$i$i >>> 31;
        $arrayidx126$i$i = (((($T$09$i$i)) + 16|0) + ($shr124$i$i<<2)|0);
        $155 = HEAP32[$arrayidx126$i$i>>2]|0;
        $cmp128$i$i = ($155|0)==(0|0);
        if ($cmp128$i$i) {
         break;
        }
        $shl127$i$i = $K105$010$i$i << 1;
        $head118$i$i = ((($155)) + 4|0);
        $156 = HEAP32[$head118$i$i>>2]|0;
        $and119$i$i = $156 & -8;
        $cmp120$i$i = ($and119$i$i|0)==($sub$ptr$sub$i$i|0);
        if ($cmp120$i$i) {
         $T$0$lcssa$i$i = $155;
         break L325;
        } else {
         $K105$010$i$i = $shl127$i$i;$T$09$i$i = $155;
        }
       }
       HEAP32[$arrayidx126$i$i>>2] = $92;
       $parent138$i$i = ((($92)) + 24|0);
       HEAP32[$parent138$i$i>>2] = $T$09$i$i;
       $bk139$i$i = ((($92)) + 12|0);
       HEAP32[$bk139$i$i>>2] = $92;
       $fd140$i$i = ((($92)) + 8|0);
       HEAP32[$fd140$i$i>>2] = $92;
       break L215;
      }
     } while(0);
     $fd148$i$i = ((($T$0$lcssa$i$i)) + 8|0);
     $157 = HEAP32[$fd148$i$i>>2]|0;
     $bk158$i$i = ((($157)) + 12|0);
     HEAP32[$bk158$i$i>>2] = $92;
     HEAP32[$fd148$i$i>>2] = $92;
     $fd160$i$i = ((($92)) + 8|0);
     HEAP32[$fd160$i$i>>2] = $157;
     $bk161$i$i = ((($92)) + 12|0);
     HEAP32[$bk161$i$i>>2] = $T$0$lcssa$i$i;
     $parent162$i$i = ((($92)) + 24|0);
     HEAP32[$parent162$i$i>>2] = 0;
    }
   }
  } while(0);
  $158 = HEAP32[(2672)>>2]|0;
  $cmp257$i = ($158>>>0)>($nb$0>>>0);
  if ($cmp257$i) {
   $sub260$i = (($158) - ($nb$0))|0;
   HEAP32[(2672)>>2] = $sub260$i;
   $159 = HEAP32[(2684)>>2]|0;
   $add$ptr262$i = (($159) + ($nb$0)|0);
   HEAP32[(2684)>>2] = $add$ptr262$i;
   $or264$i = $sub260$i | 1;
   $head265$i = ((($add$ptr262$i)) + 4|0);
   HEAP32[$head265$i>>2] = $or264$i;
   $or267$i = $nb$0 | 3;
   $head268$i = ((($159)) + 4|0);
   HEAP32[$head268$i>>2] = $or267$i;
   $add$ptr269$i = ((($159)) + 8|0);
   $retval$0 = $add$ptr269$i;
   STACKTOP = sp;return ($retval$0|0);
  }
 }
 $call275$i = (___errno_location()|0);
 HEAP32[$call275$i>>2] = 12;
 $retval$0 = 0;
 STACKTOP = sp;return ($retval$0|0);
}
function _free($mem) {
 $mem = $mem|0;
 var $$pre = 0, $$pre$phiZ2D = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0;
 var $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0;
 var $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $F510$0 = 0, $I534$0 = 0, $K583$0266 = 0;
 var $R$1 = 0, $R$1$be = 0, $R$1$ph = 0, $R$3 = 0, $R332$1 = 0, $R332$1$be = 0, $R332$1$ph = 0, $R332$3 = 0, $RP$1 = 0, $RP$1$be = 0, $RP$1$ph = 0, $RP360$1 = 0, $RP360$1$be = 0, $RP360$1$ph = 0, $T$0$lcssa = 0, $T$0265 = 0, $add$ptr = 0, $add$ptr16 = 0, $add$ptr217 = 0, $add$ptr261 = 0;
 var $add$ptr482 = 0, $add$ptr498 = 0, $add$ptr6 = 0, $add17 = 0, $add246 = 0, $add258 = 0, $add267 = 0, $add550 = 0, $add555 = 0, $add559 = 0, $add561 = 0, $add564 = 0, $and12 = 0, $and140 = 0, $and210 = 0, $and215 = 0, $and232 = 0, $and240 = 0, $and266 = 0, $and301 = 0;
 var $and410 = 0, $and46 = 0, $and495 = 0, $and5 = 0, $and512 = 0, $and545 = 0, $and549 = 0, $and554 = 0, $and563 = 0, $and574 = 0, $and592 = 0, $and592263 = 0, $and8 = 0, $arrayidx108 = 0, $arrayidx113 = 0, $arrayidx130 = 0, $arrayidx149 = 0, $arrayidx157 = 0, $arrayidx157$sink = 0, $arrayidx182 = 0;
 var $arrayidx188 = 0, $arrayidx198 = 0, $arrayidx362 = 0, $arrayidx374 = 0, $arrayidx379 = 0, $arrayidx400 = 0, $arrayidx419 = 0, $arrayidx427 = 0, $arrayidx427$sink = 0, $arrayidx454 = 0, $arrayidx460 = 0, $arrayidx470 = 0, $arrayidx509 = 0, $arrayidx567 = 0, $arrayidx570 = 0, $arrayidx599 = 0, $arrayidx99 = 0, $bk = 0, $bk275 = 0, $bk321 = 0;
 var $bk333 = 0, $bk355 = 0, $bk529 = 0, $bk531 = 0, $bk580 = 0, $bk611 = 0, $bk631 = 0, $bk634 = 0, $bk66 = 0, $bk73 = 0, $bk94 = 0, $child = 0, $child171 = 0, $child361 = 0, $child443 = 0, $child569 = 0, $cmp = 0, $cmp$i = 0, $cmp100 = 0, $cmp104 = 0;
 var $cmp109 = 0, $cmp114 = 0, $cmp127 = 0, $cmp13 = 0, $cmp131 = 0, $cmp150 = 0, $cmp162 = 0, $cmp173 = 0, $cmp18 = 0, $cmp189 = 0, $cmp211 = 0, $cmp22 = 0, $cmp228 = 0, $cmp243 = 0, $cmp249 = 0, $cmp25 = 0, $cmp255 = 0, $cmp269 = 0, $cmp296 = 0, $cmp334 = 0;
 var $cmp363 = 0, $cmp368 = 0, $cmp375 = 0, $cmp380 = 0, $cmp395 = 0, $cmp401 = 0, $cmp42 = 0, $cmp420 = 0, $cmp432 = 0, $cmp445 = 0, $cmp461 = 0, $cmp484 = 0, $cmp502 = 0, $cmp536 = 0, $cmp540 = 0, $cmp584 = 0, $cmp593 = 0, $cmp593264 = 0, $cmp601 = 0, $cmp640 = 0;
 var $cmp74 = 0, $cond = 0, $cond254 = 0, $cond255 = 0, $dec = 0, $fd = 0, $fd273 = 0, $fd322 = 0, $fd338 = 0, $fd356 = 0, $fd530 = 0, $fd581 = 0, $fd612 = 0, $fd620 = 0, $fd633 = 0, $fd67 = 0, $fd78 = 0, $fd95 = 0, $head209 = 0, $head216 = 0;
 var $head231 = 0, $head248 = 0, $head260 = 0, $head4 = 0, $head481 = 0, $head497 = 0, $head591 = 0, $head591262 = 0, $idx$neg = 0, $index = 0, $index399 = 0, $index568 = 0, $neg = 0, $neg139 = 0, $neg300 = 0, $neg409 = 0, $next4$i = 0, $or = 0, $or247 = 0, $or259 = 0;
 var $or480 = 0, $or496 = 0, $or516 = 0, $or578 = 0, $p$1 = 0, $parent = 0, $parent170 = 0, $parent183 = 0, $parent199 = 0, $parent331 = 0, $parent442 = 0, $parent455 = 0, $parent471 = 0, $parent579 = 0, $parent610 = 0, $parent635 = 0, $psize$1 = 0, $psize$2 = 0, $shl138 = 0, $shl299 = 0;
 var $shl408 = 0, $shl45 = 0, $shl508 = 0, $shl511 = 0, $shl546 = 0, $shl551 = 0, $shl557 = 0, $shl560 = 0, $shl573 = 0, $shl590 = 0, $shl600 = 0, $shr = 0, $shr268 = 0, $shr501 = 0, $shr535 = 0, $shr544 = 0, $shr548 = 0, $shr553 = 0, $shr558 = 0, $shr562 = 0;
 var $shr586 = 0, $shr597 = 0, $sp$0$i = 0, $sp$0$in$i = 0, $sub = 0, $sub547 = 0, $sub552 = 0, $sub556 = 0, $sub589 = 0, $tobool233 = 0, $tobool241 = 0, $tobool513 = 0, $tobool575 = 0, $tobool9 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $cmp = ($mem|0)==(0|0);
 if ($cmp) {
  return;
 }
 $add$ptr = ((($mem)) + -8|0);
 $0 = HEAP32[(2676)>>2]|0;
 $head4 = ((($mem)) + -4|0);
 $1 = HEAP32[$head4>>2]|0;
 $and5 = $1 & -8;
 $add$ptr6 = (($add$ptr) + ($and5)|0);
 $and8 = $1 & 1;
 $tobool9 = ($and8|0)==(0);
 do {
  if ($tobool9) {
   $2 = HEAP32[$add$ptr>>2]|0;
   $and12 = $1 & 3;
   $cmp13 = ($and12|0)==(0);
   if ($cmp13) {
    return;
   }
   $idx$neg = (0 - ($2))|0;
   $add$ptr16 = (($add$ptr) + ($idx$neg)|0);
   $add17 = (($2) + ($and5))|0;
   $cmp18 = ($add$ptr16>>>0)<($0>>>0);
   if ($cmp18) {
    return;
   }
   $3 = HEAP32[(2680)>>2]|0;
   $cmp22 = ($3|0)==($add$ptr16|0);
   if ($cmp22) {
    $head209 = ((($add$ptr6)) + 4|0);
    $20 = HEAP32[$head209>>2]|0;
    $and210 = $20 & 3;
    $cmp211 = ($and210|0)==(3);
    if (!($cmp211)) {
     $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
     break;
    }
    $add$ptr217 = (($add$ptr16) + ($add17)|0);
    $head216 = ((($add$ptr16)) + 4|0);
    $or = $add17 | 1;
    $and215 = $20 & -2;
    HEAP32[(2668)>>2] = $add17;
    HEAP32[$head209>>2] = $and215;
    HEAP32[$head216>>2] = $or;
    HEAP32[$add$ptr217>>2] = $add17;
    return;
   }
   $shr = $2 >>> 3;
   $cmp25 = ($2>>>0)<(256);
   if ($cmp25) {
    $fd = ((($add$ptr16)) + 8|0);
    $4 = HEAP32[$fd>>2]|0;
    $bk = ((($add$ptr16)) + 12|0);
    $5 = HEAP32[$bk>>2]|0;
    $cmp42 = ($5|0)==($4|0);
    if ($cmp42) {
     $shl45 = 1 << $shr;
     $neg = $shl45 ^ -1;
     $6 = HEAP32[665]|0;
     $and46 = $6 & $neg;
     HEAP32[665] = $and46;
     $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
     break;
    } else {
     $bk66 = ((($4)) + 12|0);
     HEAP32[$bk66>>2] = $5;
     $fd67 = ((($5)) + 8|0);
     HEAP32[$fd67>>2] = $4;
     $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
     break;
    }
   }
   $parent = ((($add$ptr16)) + 24|0);
   $7 = HEAP32[$parent>>2]|0;
   $bk73 = ((($add$ptr16)) + 12|0);
   $8 = HEAP32[$bk73>>2]|0;
   $cmp74 = ($8|0)==($add$ptr16|0);
   do {
    if ($cmp74) {
     $child = ((($add$ptr16)) + 16|0);
     $arrayidx99 = ((($child)) + 4|0);
     $10 = HEAP32[$arrayidx99>>2]|0;
     $cmp100 = ($10|0)==(0|0);
     if ($cmp100) {
      $11 = HEAP32[$child>>2]|0;
      $cmp104 = ($11|0)==(0|0);
      if ($cmp104) {
       $R$3 = 0;
       break;
      } else {
       $R$1$ph = $11;$RP$1$ph = $child;
      }
     } else {
      $R$1$ph = $10;$RP$1$ph = $arrayidx99;
     }
     $R$1 = $R$1$ph;$RP$1 = $RP$1$ph;
     while(1) {
      $arrayidx108 = ((($R$1)) + 20|0);
      $12 = HEAP32[$arrayidx108>>2]|0;
      $cmp109 = ($12|0)==(0|0);
      if ($cmp109) {
       $arrayidx113 = ((($R$1)) + 16|0);
       $13 = HEAP32[$arrayidx113>>2]|0;
       $cmp114 = ($13|0)==(0|0);
       if ($cmp114) {
        break;
       } else {
        $R$1$be = $13;$RP$1$be = $arrayidx113;
       }
      } else {
       $R$1$be = $12;$RP$1$be = $arrayidx108;
      }
      $R$1 = $R$1$be;$RP$1 = $RP$1$be;
     }
     HEAP32[$RP$1>>2] = 0;
     $R$3 = $R$1;
    } else {
     $fd78 = ((($add$ptr16)) + 8|0);
     $9 = HEAP32[$fd78>>2]|0;
     $bk94 = ((($9)) + 12|0);
     HEAP32[$bk94>>2] = $8;
     $fd95 = ((($8)) + 8|0);
     HEAP32[$fd95>>2] = $9;
     $R$3 = $8;
    }
   } while(0);
   $cmp127 = ($7|0)==(0|0);
   if ($cmp127) {
    $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
   } else {
    $index = ((($add$ptr16)) + 28|0);
    $14 = HEAP32[$index>>2]|0;
    $arrayidx130 = (2964 + ($14<<2)|0);
    $15 = HEAP32[$arrayidx130>>2]|0;
    $cmp131 = ($15|0)==($add$ptr16|0);
    if ($cmp131) {
     HEAP32[$arrayidx130>>2] = $R$3;
     $cond254 = ($R$3|0)==(0|0);
     if ($cond254) {
      $shl138 = 1 << $14;
      $neg139 = $shl138 ^ -1;
      $16 = HEAP32[(2664)>>2]|0;
      $and140 = $16 & $neg139;
      HEAP32[(2664)>>2] = $and140;
      $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
      break;
     }
    } else {
     $arrayidx149 = ((($7)) + 16|0);
     $17 = HEAP32[$arrayidx149>>2]|0;
     $cmp150 = ($17|0)==($add$ptr16|0);
     $arrayidx157 = ((($7)) + 20|0);
     $arrayidx157$sink = $cmp150 ? $arrayidx149 : $arrayidx157;
     HEAP32[$arrayidx157$sink>>2] = $R$3;
     $cmp162 = ($R$3|0)==(0|0);
     if ($cmp162) {
      $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
      break;
     }
    }
    $parent170 = ((($R$3)) + 24|0);
    HEAP32[$parent170>>2] = $7;
    $child171 = ((($add$ptr16)) + 16|0);
    $18 = HEAP32[$child171>>2]|0;
    $cmp173 = ($18|0)==(0|0);
    if (!($cmp173)) {
     $arrayidx182 = ((($R$3)) + 16|0);
     HEAP32[$arrayidx182>>2] = $18;
     $parent183 = ((($18)) + 24|0);
     HEAP32[$parent183>>2] = $R$3;
    }
    $arrayidx188 = ((($child171)) + 4|0);
    $19 = HEAP32[$arrayidx188>>2]|0;
    $cmp189 = ($19|0)==(0|0);
    if ($cmp189) {
     $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
    } else {
     $arrayidx198 = ((($R$3)) + 20|0);
     HEAP32[$arrayidx198>>2] = $19;
     $parent199 = ((($19)) + 24|0);
     HEAP32[$parent199>>2] = $R$3;
     $21 = $add$ptr16;$p$1 = $add$ptr16;$psize$1 = $add17;
    }
   }
  } else {
   $21 = $add$ptr;$p$1 = $add$ptr;$psize$1 = $and5;
  }
 } while(0);
 $cmp228 = ($21>>>0)<($add$ptr6>>>0);
 if (!($cmp228)) {
  return;
 }
 $head231 = ((($add$ptr6)) + 4|0);
 $22 = HEAP32[$head231>>2]|0;
 $and232 = $22 & 1;
 $tobool233 = ($and232|0)==(0);
 if ($tobool233) {
  return;
 }
 $and240 = $22 & 2;
 $tobool241 = ($and240|0)==(0);
 if ($tobool241) {
  $23 = HEAP32[(2684)>>2]|0;
  $cmp243 = ($23|0)==($add$ptr6|0);
  if ($cmp243) {
   $24 = HEAP32[(2672)>>2]|0;
   $add246 = (($24) + ($psize$1))|0;
   HEAP32[(2672)>>2] = $add246;
   HEAP32[(2684)>>2] = $p$1;
   $or247 = $add246 | 1;
   $head248 = ((($p$1)) + 4|0);
   HEAP32[$head248>>2] = $or247;
   $25 = HEAP32[(2680)>>2]|0;
   $cmp249 = ($p$1|0)==($25|0);
   if (!($cmp249)) {
    return;
   }
   HEAP32[(2680)>>2] = 0;
   HEAP32[(2668)>>2] = 0;
   return;
  }
  $26 = HEAP32[(2680)>>2]|0;
  $cmp255 = ($26|0)==($add$ptr6|0);
  if ($cmp255) {
   $27 = HEAP32[(2668)>>2]|0;
   $add258 = (($27) + ($psize$1))|0;
   HEAP32[(2668)>>2] = $add258;
   HEAP32[(2680)>>2] = $21;
   $or259 = $add258 | 1;
   $head260 = ((($p$1)) + 4|0);
   HEAP32[$head260>>2] = $or259;
   $add$ptr261 = (($21) + ($add258)|0);
   HEAP32[$add$ptr261>>2] = $add258;
   return;
  }
  $and266 = $22 & -8;
  $add267 = (($and266) + ($psize$1))|0;
  $shr268 = $22 >>> 3;
  $cmp269 = ($22>>>0)<(256);
  do {
   if ($cmp269) {
    $fd273 = ((($add$ptr6)) + 8|0);
    $28 = HEAP32[$fd273>>2]|0;
    $bk275 = ((($add$ptr6)) + 12|0);
    $29 = HEAP32[$bk275>>2]|0;
    $cmp296 = ($29|0)==($28|0);
    if ($cmp296) {
     $shl299 = 1 << $shr268;
     $neg300 = $shl299 ^ -1;
     $30 = HEAP32[665]|0;
     $and301 = $30 & $neg300;
     HEAP32[665] = $and301;
     break;
    } else {
     $bk321 = ((($28)) + 12|0);
     HEAP32[$bk321>>2] = $29;
     $fd322 = ((($29)) + 8|0);
     HEAP32[$fd322>>2] = $28;
     break;
    }
   } else {
    $parent331 = ((($add$ptr6)) + 24|0);
    $31 = HEAP32[$parent331>>2]|0;
    $bk333 = ((($add$ptr6)) + 12|0);
    $32 = HEAP32[$bk333>>2]|0;
    $cmp334 = ($32|0)==($add$ptr6|0);
    do {
     if ($cmp334) {
      $child361 = ((($add$ptr6)) + 16|0);
      $arrayidx362 = ((($child361)) + 4|0);
      $34 = HEAP32[$arrayidx362>>2]|0;
      $cmp363 = ($34|0)==(0|0);
      if ($cmp363) {
       $35 = HEAP32[$child361>>2]|0;
       $cmp368 = ($35|0)==(0|0);
       if ($cmp368) {
        $R332$3 = 0;
        break;
       } else {
        $R332$1$ph = $35;$RP360$1$ph = $child361;
       }
      } else {
       $R332$1$ph = $34;$RP360$1$ph = $arrayidx362;
      }
      $R332$1 = $R332$1$ph;$RP360$1 = $RP360$1$ph;
      while(1) {
       $arrayidx374 = ((($R332$1)) + 20|0);
       $36 = HEAP32[$arrayidx374>>2]|0;
       $cmp375 = ($36|0)==(0|0);
       if ($cmp375) {
        $arrayidx379 = ((($R332$1)) + 16|0);
        $37 = HEAP32[$arrayidx379>>2]|0;
        $cmp380 = ($37|0)==(0|0);
        if ($cmp380) {
         break;
        } else {
         $R332$1$be = $37;$RP360$1$be = $arrayidx379;
        }
       } else {
        $R332$1$be = $36;$RP360$1$be = $arrayidx374;
       }
       $R332$1 = $R332$1$be;$RP360$1 = $RP360$1$be;
      }
      HEAP32[$RP360$1>>2] = 0;
      $R332$3 = $R332$1;
     } else {
      $fd338 = ((($add$ptr6)) + 8|0);
      $33 = HEAP32[$fd338>>2]|0;
      $bk355 = ((($33)) + 12|0);
      HEAP32[$bk355>>2] = $32;
      $fd356 = ((($32)) + 8|0);
      HEAP32[$fd356>>2] = $33;
      $R332$3 = $32;
     }
    } while(0);
    $cmp395 = ($31|0)==(0|0);
    if (!($cmp395)) {
     $index399 = ((($add$ptr6)) + 28|0);
     $38 = HEAP32[$index399>>2]|0;
     $arrayidx400 = (2964 + ($38<<2)|0);
     $39 = HEAP32[$arrayidx400>>2]|0;
     $cmp401 = ($39|0)==($add$ptr6|0);
     if ($cmp401) {
      HEAP32[$arrayidx400>>2] = $R332$3;
      $cond255 = ($R332$3|0)==(0|0);
      if ($cond255) {
       $shl408 = 1 << $38;
       $neg409 = $shl408 ^ -1;
       $40 = HEAP32[(2664)>>2]|0;
       $and410 = $40 & $neg409;
       HEAP32[(2664)>>2] = $and410;
       break;
      }
     } else {
      $arrayidx419 = ((($31)) + 16|0);
      $41 = HEAP32[$arrayidx419>>2]|0;
      $cmp420 = ($41|0)==($add$ptr6|0);
      $arrayidx427 = ((($31)) + 20|0);
      $arrayidx427$sink = $cmp420 ? $arrayidx419 : $arrayidx427;
      HEAP32[$arrayidx427$sink>>2] = $R332$3;
      $cmp432 = ($R332$3|0)==(0|0);
      if ($cmp432) {
       break;
      }
     }
     $parent442 = ((($R332$3)) + 24|0);
     HEAP32[$parent442>>2] = $31;
     $child443 = ((($add$ptr6)) + 16|0);
     $42 = HEAP32[$child443>>2]|0;
     $cmp445 = ($42|0)==(0|0);
     if (!($cmp445)) {
      $arrayidx454 = ((($R332$3)) + 16|0);
      HEAP32[$arrayidx454>>2] = $42;
      $parent455 = ((($42)) + 24|0);
      HEAP32[$parent455>>2] = $R332$3;
     }
     $arrayidx460 = ((($child443)) + 4|0);
     $43 = HEAP32[$arrayidx460>>2]|0;
     $cmp461 = ($43|0)==(0|0);
     if (!($cmp461)) {
      $arrayidx470 = ((($R332$3)) + 20|0);
      HEAP32[$arrayidx470>>2] = $43;
      $parent471 = ((($43)) + 24|0);
      HEAP32[$parent471>>2] = $R332$3;
     }
    }
   }
  } while(0);
  $or480 = $add267 | 1;
  $head481 = ((($p$1)) + 4|0);
  HEAP32[$head481>>2] = $or480;
  $add$ptr482 = (($21) + ($add267)|0);
  HEAP32[$add$ptr482>>2] = $add267;
  $44 = HEAP32[(2680)>>2]|0;
  $cmp484 = ($p$1|0)==($44|0);
  if ($cmp484) {
   HEAP32[(2668)>>2] = $add267;
   return;
  } else {
   $psize$2 = $add267;
  }
 } else {
  $and495 = $22 & -2;
  HEAP32[$head231>>2] = $and495;
  $or496 = $psize$1 | 1;
  $head497 = ((($p$1)) + 4|0);
  HEAP32[$head497>>2] = $or496;
  $add$ptr498 = (($21) + ($psize$1)|0);
  HEAP32[$add$ptr498>>2] = $psize$1;
  $psize$2 = $psize$1;
 }
 $shr501 = $psize$2 >>> 3;
 $cmp502 = ($psize$2>>>0)<(256);
 if ($cmp502) {
  $shl508 = $shr501 << 1;
  $arrayidx509 = (2700 + ($shl508<<2)|0);
  $45 = HEAP32[665]|0;
  $shl511 = 1 << $shr501;
  $and512 = $45 & $shl511;
  $tobool513 = ($and512|0)==(0);
  if ($tobool513) {
   $or516 = $45 | $shl511;
   HEAP32[665] = $or516;
   $$pre = ((($arrayidx509)) + 8|0);
   $$pre$phiZ2D = $$pre;$F510$0 = $arrayidx509;
  } else {
   $46 = ((($arrayidx509)) + 8|0);
   $47 = HEAP32[$46>>2]|0;
   $$pre$phiZ2D = $46;$F510$0 = $47;
  }
  HEAP32[$$pre$phiZ2D>>2] = $p$1;
  $bk529 = ((($F510$0)) + 12|0);
  HEAP32[$bk529>>2] = $p$1;
  $fd530 = ((($p$1)) + 8|0);
  HEAP32[$fd530>>2] = $F510$0;
  $bk531 = ((($p$1)) + 12|0);
  HEAP32[$bk531>>2] = $arrayidx509;
  return;
 }
 $shr535 = $psize$2 >>> 8;
 $cmp536 = ($shr535|0)==(0);
 if ($cmp536) {
  $I534$0 = 0;
 } else {
  $cmp540 = ($psize$2>>>0)>(16777215);
  if ($cmp540) {
   $I534$0 = 31;
  } else {
   $sub = (($shr535) + 1048320)|0;
   $shr544 = $sub >>> 16;
   $and545 = $shr544 & 8;
   $shl546 = $shr535 << $and545;
   $sub547 = (($shl546) + 520192)|0;
   $shr548 = $sub547 >>> 16;
   $and549 = $shr548 & 4;
   $add550 = $and549 | $and545;
   $shl551 = $shl546 << $and549;
   $sub552 = (($shl551) + 245760)|0;
   $shr553 = $sub552 >>> 16;
   $and554 = $shr553 & 2;
   $add555 = $add550 | $and554;
   $sub556 = (14 - ($add555))|0;
   $shl557 = $shl551 << $and554;
   $shr558 = $shl557 >>> 15;
   $add559 = (($sub556) + ($shr558))|0;
   $shl560 = $add559 << 1;
   $add561 = (($add559) + 7)|0;
   $shr562 = $psize$2 >>> $add561;
   $and563 = $shr562 & 1;
   $add564 = $and563 | $shl560;
   $I534$0 = $add564;
  }
 }
 $arrayidx567 = (2964 + ($I534$0<<2)|0);
 $index568 = ((($p$1)) + 28|0);
 HEAP32[$index568>>2] = $I534$0;
 $child569 = ((($p$1)) + 16|0);
 $arrayidx570 = ((($p$1)) + 20|0);
 HEAP32[$arrayidx570>>2] = 0;
 HEAP32[$child569>>2] = 0;
 $48 = HEAP32[(2664)>>2]|0;
 $shl573 = 1 << $I534$0;
 $and574 = $48 & $shl573;
 $tobool575 = ($and574|0)==(0);
 L112: do {
  if ($tobool575) {
   $or578 = $48 | $shl573;
   HEAP32[(2664)>>2] = $or578;
   HEAP32[$arrayidx567>>2] = $p$1;
   $parent579 = ((($p$1)) + 24|0);
   HEAP32[$parent579>>2] = $arrayidx567;
   $bk580 = ((($p$1)) + 12|0);
   HEAP32[$bk580>>2] = $p$1;
   $fd581 = ((($p$1)) + 8|0);
   HEAP32[$fd581>>2] = $p$1;
  } else {
   $49 = HEAP32[$arrayidx567>>2]|0;
   $head591262 = ((($49)) + 4|0);
   $50 = HEAP32[$head591262>>2]|0;
   $and592263 = $50 & -8;
   $cmp593264 = ($and592263|0)==($psize$2|0);
   L115: do {
    if ($cmp593264) {
     $T$0$lcssa = $49;
    } else {
     $cmp584 = ($I534$0|0)==(31);
     $shr586 = $I534$0 >>> 1;
     $sub589 = (25 - ($shr586))|0;
     $cond = $cmp584 ? 0 : $sub589;
     $shl590 = $psize$2 << $cond;
     $K583$0266 = $shl590;$T$0265 = $49;
     while(1) {
      $shr597 = $K583$0266 >>> 31;
      $arrayidx599 = (((($T$0265)) + 16|0) + ($shr597<<2)|0);
      $51 = HEAP32[$arrayidx599>>2]|0;
      $cmp601 = ($51|0)==(0|0);
      if ($cmp601) {
       break;
      }
      $shl600 = $K583$0266 << 1;
      $head591 = ((($51)) + 4|0);
      $52 = HEAP32[$head591>>2]|0;
      $and592 = $52 & -8;
      $cmp593 = ($and592|0)==($psize$2|0);
      if ($cmp593) {
       $T$0$lcssa = $51;
       break L115;
      } else {
       $K583$0266 = $shl600;$T$0265 = $51;
      }
     }
     HEAP32[$arrayidx599>>2] = $p$1;
     $parent610 = ((($p$1)) + 24|0);
     HEAP32[$parent610>>2] = $T$0265;
     $bk611 = ((($p$1)) + 12|0);
     HEAP32[$bk611>>2] = $p$1;
     $fd612 = ((($p$1)) + 8|0);
     HEAP32[$fd612>>2] = $p$1;
     break L112;
    }
   } while(0);
   $fd620 = ((($T$0$lcssa)) + 8|0);
   $53 = HEAP32[$fd620>>2]|0;
   $bk631 = ((($53)) + 12|0);
   HEAP32[$bk631>>2] = $p$1;
   HEAP32[$fd620>>2] = $p$1;
   $fd633 = ((($p$1)) + 8|0);
   HEAP32[$fd633>>2] = $53;
   $bk634 = ((($p$1)) + 12|0);
   HEAP32[$bk634>>2] = $T$0$lcssa;
   $parent635 = ((($p$1)) + 24|0);
   HEAP32[$parent635>>2] = 0;
  }
 } while(0);
 $54 = HEAP32[(2692)>>2]|0;
 $dec = (($54) + -1)|0;
 HEAP32[(2692)>>2] = $dec;
 $cmp640 = ($dec|0)==(0);
 if (!($cmp640)) {
  return;
 }
 $sp$0$in$i = (3116);
 while(1) {
  $sp$0$i = HEAP32[$sp$0$in$i>>2]|0;
  $cmp$i = ($sp$0$i|0)==(0|0);
  $next4$i = ((($sp$0$i)) + 8|0);
  if ($cmp$i) {
   break;
  } else {
   $sp$0$in$i = $next4$i;
  }
 }
 HEAP32[(2692)>>2] = -1;
 return;
}
function __Znwm($size) {
 $size = $size|0;
 var $call = 0, $call$lcssa = 0, $call2 = 0, $cmp = 0, $cmp1 = 0, $spec$store$select = 0, $tobool = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $cmp = ($size|0)==(0);
 $spec$store$select = $cmp ? 1 : $size;
 while(1) {
  $call = (_malloc($spec$store$select)|0);
  $cmp1 = ($call|0)==(0|0);
  if (!($cmp1)) {
   $call$lcssa = $call;
   break;
  }
  $call2 = (__ZSt15get_new_handlerv()|0);
  $tobool = ($call2|0)==(0|0);
  if ($tobool) {
   $call$lcssa = 0;
   break;
  }
  FUNCTION_TABLE_v[$call2 & 0]();
 }
 return ($call$lcssa|0);
}
function __ZdlPv($ptr) {
 $ptr = $ptr|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 _free($ptr);
 return;
}
function __ZN10__cxxabiv116__shim_type_infoD2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return;
}
function __ZN10__cxxabiv117__class_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN10__cxxabiv116__shim_type_infoD2Ev($this);
 __ZdlPv($this);
 return;
}
function __ZNK10__cxxabiv116__shim_type_info5noop1Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return;
}
function __ZNK10__cxxabiv116__shim_type_info5noop2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return;
}
function __ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv($this,$thrown_type,$adjustedPtr) {
 $this = $this|0;
 $thrown_type = $thrown_type|0;
 $adjustedPtr = $adjustedPtr|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $call = 0, $cmp = 0, $cmp4 = 0, $dst_ptr_leading_to_static_ptr = 0, $info = 0, $number_of_dst_type = 0, $path_dst_ptr_to_static_ptr = 0, $retval$0 = 0, $retval$2 = 0, $src2dst_offset = 0, $static_type = 0, $vfn = 0, $vtable = 0;
 var dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0;
 $info = sp;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$thrown_type,0)|0);
 if ($call) {
  $retval$2 = 1;
 } else {
  $0 = ($thrown_type|0)==(0|0);
  if ($0) {
   $retval$2 = 0;
  } else {
   $1 = (___dynamic_cast($thrown_type,320,304,0)|0);
   $cmp = ($1|0)==(0|0);
   if ($cmp) {
    $retval$2 = 0;
   } else {
    $2 = ((($info)) + 4|0);
    dest=$2; stop=dest+52|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
    HEAP32[$info>>2] = $1;
    $static_type = ((($info)) + 8|0);
    HEAP32[$static_type>>2] = $this;
    $src2dst_offset = ((($info)) + 12|0);
    HEAP32[$src2dst_offset>>2] = -1;
    $number_of_dst_type = ((($info)) + 48|0);
    HEAP32[$number_of_dst_type>>2] = 1;
    $vtable = HEAP32[$1>>2]|0;
    $vfn = ((($vtable)) + 28|0);
    $3 = HEAP32[$vfn>>2]|0;
    $4 = HEAP32[$adjustedPtr>>2]|0;
    FUNCTION_TABLE_viiii[$3 & 7]($1,$info,$4,1);
    $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
    $5 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
    $cmp4 = ($5|0)==(1);
    if ($cmp4) {
     $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
     $6 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
     HEAP32[$adjustedPtr>>2] = $6;
     $retval$0 = 1;
    } else {
     $retval$0 = 0;
    }
    $retval$2 = $retval$0;
   }
  }
 }
 STACKTOP = sp;return ($retval$2|0);
}
function __ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $call = 0, $static_type = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,$use_strcmp)|0);
 if ($call) {
  __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0,$info,$dst_ptr,$current_ptr,$path_below);
 }
 return;
}
function __ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this,$info,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $add = 0, $call = 0, $call3 = 0, $cmp = 0, $cmp12 = 0, $cmp13 = 0, $cmp5 = 0, $cmp7 = 0, $dst_ptr_leading_to_static_ptr = 0, $dst_ptr_not_leading_to_static_ptr = 0, $is_dst_type_derived_from_static_type = 0, $number_to_dst_ptr = 0, $number_to_static_ptr = 0;
 var $path_dst_ptr_to_static_ptr = 0, $path_dynamic_ptr_to_dst_ptr = 0, $path_dynamic_ptr_to_dst_ptr10 = 0, $search_done = 0, $static_type = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,$use_strcmp)|0);
 do {
  if ($call) {
   __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi(0,$info,$current_ptr,$path_below);
  } else {
   $1 = HEAP32[$info>>2]|0;
   $call3 = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$1,$use_strcmp)|0);
   if ($call3) {
    $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
    $2 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
    $cmp = ($2|0)==($current_ptr|0);
    if (!($cmp)) {
     $dst_ptr_not_leading_to_static_ptr = ((($info)) + 20|0);
     $3 = HEAP32[$dst_ptr_not_leading_to_static_ptr>>2]|0;
     $cmp5 = ($3|0)==($current_ptr|0);
     if (!($cmp5)) {
      $path_dynamic_ptr_to_dst_ptr10 = ((($info)) + 32|0);
      HEAP32[$path_dynamic_ptr_to_dst_ptr10>>2] = $path_below;
      HEAP32[$dst_ptr_not_leading_to_static_ptr>>2] = $current_ptr;
      $number_to_dst_ptr = ((($info)) + 40|0);
      $4 = HEAP32[$number_to_dst_ptr>>2]|0;
      $add = (($4) + 1)|0;
      HEAP32[$number_to_dst_ptr>>2] = $add;
      $number_to_static_ptr = ((($info)) + 36|0);
      $5 = HEAP32[$number_to_static_ptr>>2]|0;
      $cmp12 = ($5|0)==(1);
      if ($cmp12) {
       $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
       $6 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
       $cmp13 = ($6|0)==(2);
       if ($cmp13) {
        $search_done = ((($info)) + 54|0);
        HEAP8[$search_done>>0] = 1;
       }
      }
      $is_dst_type_derived_from_static_type = ((($info)) + 44|0);
      HEAP32[$is_dst_type_derived_from_static_type>>2] = 4;
      break;
     }
    }
    $cmp7 = ($path_below|0)==(1);
    if ($cmp7) {
     $path_dynamic_ptr_to_dst_ptr = ((($info)) + 32|0);
     HEAP32[$path_dynamic_ptr_to_dst_ptr>>2] = 1;
    }
   }
  }
 } while(0);
 return;
}
function __ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $call = 0, $static_type = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,0)|0);
 if ($call) {
  __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0,$info,$adjustedPtr,$path_below);
 }
 return;
}
function __ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($x,$y,$0) {
 $x = $x|0;
 $y = $y|0;
 $0 = $0|0;
 var $cmp = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $cmp = ($x|0)==($y|0);
 return ($cmp|0);
}
function __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, $add = 0, $cmp = 0, $cmp4 = 0, $cmp7 = 0, $dst_ptr_leading_to_static_ptr = 0, $number_to_static_ptr = 0, $number_to_static_ptr11 = 0, $path_dst_ptr_to_static_ptr = 0, $path_dst_ptr_to_static_ptr12 = 0, $path_dst_ptr_to_static_ptr6 = 0, $search_done = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
 $0 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
 $cmp = ($0|0)==(0|0);
 do {
  if ($cmp) {
   HEAP32[$dst_ptr_leading_to_static_ptr>>2] = $adjustedPtr;
   $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
   HEAP32[$path_dst_ptr_to_static_ptr>>2] = $path_below;
   $number_to_static_ptr = ((($info)) + 36|0);
   HEAP32[$number_to_static_ptr>>2] = 1;
  } else {
   $cmp4 = ($0|0)==($adjustedPtr|0);
   if (!($cmp4)) {
    $number_to_static_ptr11 = ((($info)) + 36|0);
    $2 = HEAP32[$number_to_static_ptr11>>2]|0;
    $add = (($2) + 1)|0;
    HEAP32[$number_to_static_ptr11>>2] = $add;
    $path_dst_ptr_to_static_ptr12 = ((($info)) + 24|0);
    HEAP32[$path_dst_ptr_to_static_ptr12>>2] = 2;
    $search_done = ((($info)) + 54|0);
    HEAP8[$search_done>>0] = 1;
    break;
   }
   $path_dst_ptr_to_static_ptr6 = ((($info)) + 24|0);
   $1 = HEAP32[$path_dst_ptr_to_static_ptr6>>2]|0;
   $cmp7 = ($1|0)==(2);
   if ($cmp7) {
    HEAP32[$path_dst_ptr_to_static_ptr6>>2] = $path_below;
   }
  }
 } while(0);
 return;
}
function __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi($this,$info,$current_ptr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $cmp = 0, $cmp2 = 0, $path_dynamic_ptr_to_static_ptr = 0, $static_ptr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_ptr = ((($info)) + 4|0);
 $0 = HEAP32[$static_ptr>>2]|0;
 $cmp = ($0|0)==($current_ptr|0);
 if ($cmp) {
  $path_dynamic_ptr_to_static_ptr = ((($info)) + 28|0);
  $1 = HEAP32[$path_dynamic_ptr_to_static_ptr>>2]|0;
  $cmp2 = ($1|0)==(1);
  if (!($cmp2)) {
   HEAP32[$path_dynamic_ptr_to_static_ptr>>2] = $path_below;
  }
 }
 return;
}
function __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i($this,$info,$dst_ptr,$current_ptr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $add = 0, $cmp = 0, $cmp10 = 0, $cmp13 = 0, $cmp18 = 0, $cmp2 = 0, $cmp21 = 0, $cmp5 = 0, $cmp7 = 0, $dst_ptr_leading_to_static_ptr = 0, $found_any_static_type = 0, $found_our_static_ptr = 0, $number_of_dst_type = 0;
 var $number_of_dst_type17 = 0, $number_to_static_ptr = 0, $number_to_static_ptr26 = 0, $or$cond = 0, $or$cond19 = 0, $path_dst_ptr_to_static_ptr = 0, $path_dst_ptr_to_static_ptr12 = 0, $search_done = 0, $search_done23 = 0, $search_done27 = 0, $static_ptr = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $found_any_static_type = ((($info)) + 53|0);
 HEAP8[$found_any_static_type>>0] = 1;
 $static_ptr = ((($info)) + 4|0);
 $0 = HEAP32[$static_ptr>>2]|0;
 $cmp = ($0|0)==($current_ptr|0);
 do {
  if ($cmp) {
   $found_our_static_ptr = ((($info)) + 52|0);
   HEAP8[$found_our_static_ptr>>0] = 1;
   $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
   $1 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
   $cmp2 = ($1|0)==(0|0);
   if ($cmp2) {
    HEAP32[$dst_ptr_leading_to_static_ptr>>2] = $dst_ptr;
    $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
    HEAP32[$path_dst_ptr_to_static_ptr>>2] = $path_below;
    $number_to_static_ptr = ((($info)) + 36|0);
    HEAP32[$number_to_static_ptr>>2] = 1;
    $number_of_dst_type = ((($info)) + 48|0);
    $2 = HEAP32[$number_of_dst_type>>2]|0;
    $cmp5 = ($2|0)==(1);
    $cmp7 = ($path_below|0)==(1);
    $or$cond = $cmp7 & $cmp5;
    if (!($or$cond)) {
     break;
    }
    $search_done = ((($info)) + 54|0);
    HEAP8[$search_done>>0] = 1;
    break;
   }
   $cmp10 = ($1|0)==($dst_ptr|0);
   if (!($cmp10)) {
    $number_to_static_ptr26 = ((($info)) + 36|0);
    $6 = HEAP32[$number_to_static_ptr26>>2]|0;
    $add = (($6) + 1)|0;
    HEAP32[$number_to_static_ptr26>>2] = $add;
    $search_done27 = ((($info)) + 54|0);
    HEAP8[$search_done27>>0] = 1;
    break;
   }
   $path_dst_ptr_to_static_ptr12 = ((($info)) + 24|0);
   $3 = HEAP32[$path_dst_ptr_to_static_ptr12>>2]|0;
   $cmp13 = ($3|0)==(2);
   if ($cmp13) {
    HEAP32[$path_dst_ptr_to_static_ptr12>>2] = $path_below;
    $5 = $path_below;
   } else {
    $5 = $3;
   }
   $number_of_dst_type17 = ((($info)) + 48|0);
   $4 = HEAP32[$number_of_dst_type17>>2]|0;
   $cmp18 = ($4|0)==(1);
   $cmp21 = ($5|0)==(1);
   $or$cond19 = $cmp18 & $cmp21;
   if ($or$cond19) {
    $search_done23 = ((($info)) + 54|0);
    HEAP8[$search_done23>>0] = 1;
   }
  }
 } while(0);
 return;
}
function ___dynamic_cast($static_ptr,$static_type,$dst_type,$src2dst_offset) {
 $static_ptr = $static_ptr|0;
 $static_type = $static_type|0;
 $dst_type = $dst_type|0;
 $src2dst_offset = $src2dst_offset|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $add$ptr = 0, $arrayidx = 0, $arrayidx1 = 0, $call = 0;
 var $cmp = 0, $cmp14 = 0, $cmp16 = 0, $cmp19 = 0, $cmp25 = 0, $cmp27 = 0, $cmp30 = 0, $cmp33 = 0, $dst_ptr$0 = 0, $dst_ptr_leading_to_static_ptr = 0, $dst_ptr_not_leading_to_static_ptr = 0, $info = 0, $number_of_dst_type = 0, $number_to_dst_ptr = 0, $number_to_static_ptr = 0, $or$cond = 0, $or$cond15 = 0, $or$cond16 = 0, $or$cond17 = 0, $path_dst_ptr_to_static_ptr = 0;
 var $path_dynamic_ptr_to_dst_ptr = 0, $path_dynamic_ptr_to_static_ptr = 0, $spec$select = 0, $spec$select18 = 0, $src2dst_offset5 = 0, $static_ptr3 = 0, $static_type4 = 0, $vfn = 0, $vfn11 = 0, $vtable10 = 0, $vtable7 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0;
 $info = sp;
 $0 = HEAP32[$static_ptr>>2]|0;
 $arrayidx = ((($0)) + -8|0);
 $1 = HEAP32[$arrayidx>>2]|0;
 $add$ptr = (($static_ptr) + ($1)|0);
 $arrayidx1 = ((($0)) + -4|0);
 $2 = HEAP32[$arrayidx1>>2]|0;
 HEAP32[$info>>2] = $dst_type;
 $static_ptr3 = ((($info)) + 4|0);
 HEAP32[$static_ptr3>>2] = $static_ptr;
 $static_type4 = ((($info)) + 8|0);
 HEAP32[$static_type4>>2] = $static_type;
 $src2dst_offset5 = ((($info)) + 12|0);
 HEAP32[$src2dst_offset5>>2] = $src2dst_offset;
 $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
 $dst_ptr_not_leading_to_static_ptr = ((($info)) + 20|0);
 $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
 $path_dynamic_ptr_to_static_ptr = ((($info)) + 28|0);
 $path_dynamic_ptr_to_dst_ptr = ((($info)) + 32|0);
 $number_to_dst_ptr = ((($info)) + 40|0);
 dest=$dst_ptr_leading_to_static_ptr; stop=dest+36|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));HEAP16[$dst_ptr_leading_to_static_ptr+36>>1]=0|0;HEAP8[$dst_ptr_leading_to_static_ptr+38>>0]=0|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($2,$dst_type,0)|0);
 L1: do {
  if ($call) {
   $number_of_dst_type = ((($info)) + 48|0);
   HEAP32[$number_of_dst_type>>2] = 1;
   $vtable7 = HEAP32[$2>>2]|0;
   $vfn = ((($vtable7)) + 20|0);
   $3 = HEAP32[$vfn>>2]|0;
   FUNCTION_TABLE_viiiiii[$3 & 3]($2,$info,$add$ptr,$add$ptr,1,0);
   $4 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
   $cmp = ($4|0)==(1);
   $spec$select = $cmp ? $add$ptr : 0;
   $dst_ptr$0 = $spec$select;
  } else {
   $number_to_static_ptr = ((($info)) + 36|0);
   $vtable10 = HEAP32[$2>>2]|0;
   $vfn11 = ((($vtable10)) + 24|0);
   $5 = HEAP32[$vfn11>>2]|0;
   FUNCTION_TABLE_viiiii[$5 & 3]($2,$info,$add$ptr,1,0);
   $6 = HEAP32[$number_to_static_ptr>>2]|0;
   switch ($6|0) {
   case 0:  {
    $7 = HEAP32[$number_to_dst_ptr>>2]|0;
    $cmp14 = ($7|0)==(1);
    $8 = HEAP32[$path_dynamic_ptr_to_static_ptr>>2]|0;
    $cmp16 = ($8|0)==(1);
    $or$cond = $cmp14 & $cmp16;
    $9 = HEAP32[$path_dynamic_ptr_to_dst_ptr>>2]|0;
    $cmp19 = ($9|0)==(1);
    $or$cond15 = $or$cond & $cmp19;
    $10 = HEAP32[$dst_ptr_not_leading_to_static_ptr>>2]|0;
    $spec$select18 = $or$cond15 ? $10 : 0;
    $dst_ptr$0 = $spec$select18;
    break L1;
    break;
   }
   case 1:  {
    break;
   }
   default: {
    $dst_ptr$0 = 0;
    break L1;
   }
   }
   $11 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
   $cmp25 = ($11|0)==(1);
   if (!($cmp25)) {
    $12 = HEAP32[$number_to_dst_ptr>>2]|0;
    $cmp27 = ($12|0)==(0);
    $13 = HEAP32[$path_dynamic_ptr_to_static_ptr>>2]|0;
    $cmp30 = ($13|0)==(1);
    $or$cond16 = $cmp27 & $cmp30;
    $14 = HEAP32[$path_dynamic_ptr_to_dst_ptr>>2]|0;
    $cmp33 = ($14|0)==(1);
    $or$cond17 = $or$cond16 & $cmp33;
    if (!($or$cond17)) {
     $dst_ptr$0 = 0;
     break;
    }
   }
   $15 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
   $dst_ptr$0 = $15;
  }
 } while(0);
 STACKTOP = sp;return ($dst_ptr$0|0);
}
function __ZN10__cxxabiv120__si_class_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN10__cxxabiv116__shim_type_infoD2Ev($this);
 __ZdlPv($this);
 return;
}
function __ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, $__base_type = 0, $call = 0, $static_type = 0, $vfn = 0, $vtable = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,$use_strcmp)|0);
 if ($call) {
  __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0,$info,$dst_ptr,$current_ptr,$path_below);
 } else {
  $__base_type = ((($this)) + 8|0);
  $1 = HEAP32[$__base_type>>2]|0;
  $vtable = HEAP32[$1>>2]|0;
  $vfn = ((($vtable)) + 20|0);
  $2 = HEAP32[$vfn>>2]|0;
  FUNCTION_TABLE_viiiiii[$2 & 3]($1,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp);
 }
 return;
}
function __ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this,$info,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $__base_type = 0, $__base_type40 = 0, $add = 0, $call = 0, $call3 = 0;
 var $cmp = 0, $cmp11 = 0, $cmp26 = 0, $cmp27 = 0, $cmp5 = 0, $cmp7 = 0, $dst_ptr_leading_to_static_ptr = 0, $dst_ptr_not_leading_to_static_ptr = 0, $found_any_static_type = 0, $found_our_static_ptr = 0, $is_dst_type_derived_from_static_type = 0, $is_dst_type_derived_from_static_type13$0$off032 = 0, $number_to_dst_ptr = 0, $number_to_static_ptr = 0, $path_dst_ptr_to_static_ptr = 0, $path_dynamic_ptr_to_dst_ptr = 0, $path_dynamic_ptr_to_dst_ptr10 = 0, $search_done = 0, $static_type = 0, $tobool16 = 0;
 var $tobool19 = 0, $vfn = 0, $vfn42 = 0, $vtable = 0, $vtable41 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,$use_strcmp)|0);
 do {
  if ($call) {
   __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi(0,$info,$current_ptr,$path_below);
  } else {
   $1 = HEAP32[$info>>2]|0;
   $call3 = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$1,$use_strcmp)|0);
   if (!($call3)) {
    $__base_type40 = ((($this)) + 8|0);
    $13 = HEAP32[$__base_type40>>2]|0;
    $vtable41 = HEAP32[$13>>2]|0;
    $vfn42 = ((($vtable41)) + 24|0);
    $14 = HEAP32[$vfn42>>2]|0;
    FUNCTION_TABLE_viiiii[$14 & 3]($13,$info,$current_ptr,$path_below,$use_strcmp);
    break;
   }
   $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
   $2 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
   $cmp = ($2|0)==($current_ptr|0);
   if (!($cmp)) {
    $dst_ptr_not_leading_to_static_ptr = ((($info)) + 20|0);
    $3 = HEAP32[$dst_ptr_not_leading_to_static_ptr>>2]|0;
    $cmp5 = ($3|0)==($current_ptr|0);
    if (!($cmp5)) {
     $path_dynamic_ptr_to_dst_ptr10 = ((($info)) + 32|0);
     HEAP32[$path_dynamic_ptr_to_dst_ptr10>>2] = $path_below;
     $is_dst_type_derived_from_static_type = ((($info)) + 44|0);
     $4 = HEAP32[$is_dst_type_derived_from_static_type>>2]|0;
     $cmp11 = ($4|0)==(4);
     if ($cmp11) {
      break;
     }
     $found_our_static_ptr = ((($info)) + 52|0);
     HEAP8[$found_our_static_ptr>>0] = 0;
     $found_any_static_type = ((($info)) + 53|0);
     HEAP8[$found_any_static_type>>0] = 0;
     $__base_type = ((($this)) + 8|0);
     $5 = HEAP32[$__base_type>>2]|0;
     $vtable = HEAP32[$5>>2]|0;
     $vfn = ((($vtable)) + 20|0);
     $6 = HEAP32[$vfn>>2]|0;
     FUNCTION_TABLE_viiiiii[$6 & 3]($5,$info,$current_ptr,$current_ptr,1,$use_strcmp);
     $7 = HEAP8[$found_any_static_type>>0]|0;
     $tobool16 = ($7<<24>>24)==(0);
     if ($tobool16) {
      $is_dst_type_derived_from_static_type13$0$off032 = 0;
      label = 11;
     } else {
      $8 = HEAP8[$found_our_static_ptr>>0]|0;
      $tobool19 = ($8<<24>>24)==(0);
      if ($tobool19) {
       $is_dst_type_derived_from_static_type13$0$off032 = 1;
       label = 11;
      } else {
       label = 15;
      }
     }
     do {
      if ((label|0) == 11) {
       HEAP32[$dst_ptr_not_leading_to_static_ptr>>2] = $current_ptr;
       $number_to_dst_ptr = ((($info)) + 40|0);
       $9 = HEAP32[$number_to_dst_ptr>>2]|0;
       $add = (($9) + 1)|0;
       HEAP32[$number_to_dst_ptr>>2] = $add;
       $number_to_static_ptr = ((($info)) + 36|0);
       $10 = HEAP32[$number_to_static_ptr>>2]|0;
       $cmp26 = ($10|0)==(1);
       if ($cmp26) {
        $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
        $11 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
        $cmp27 = ($11|0)==(2);
        if ($cmp27) {
         $search_done = ((($info)) + 54|0);
         HEAP8[$search_done>>0] = 1;
         if ($is_dst_type_derived_from_static_type13$0$off032) {
          label = 15;
          break;
         } else {
          $12 = 4;
          break;
         }
        }
       }
       if ($is_dst_type_derived_from_static_type13$0$off032) {
        label = 15;
       } else {
        $12 = 4;
       }
      }
     } while(0);
     if ((label|0) == 15) {
      $12 = 3;
     }
     HEAP32[$is_dst_type_derived_from_static_type>>2] = $12;
     break;
    }
   }
   $cmp7 = ($path_below|0)==(1);
   if ($cmp7) {
    $path_dynamic_ptr_to_dst_ptr = ((($info)) + 32|0);
    HEAP32[$path_dynamic_ptr_to_dst_ptr>>2] = 1;
   }
  }
 } while(0);
 return;
}
function __ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, $__base_type = 0, $call = 0, $static_type = 0, $vfn = 0, $vtable = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,0)|0);
 if ($call) {
  __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0,$info,$adjustedPtr,$path_below);
 } else {
  $__base_type = ((($this)) + 8|0);
  $1 = HEAP32[$__base_type>>2]|0;
  $vtable = HEAP32[$1>>2]|0;
  $vfn = ((($vtable)) + 28|0);
  $2 = HEAP32[$vfn>>2]|0;
  FUNCTION_TABLE_viiii[$2 & 7]($1,$info,$adjustedPtr,$path_below);
 }
 return;
}
function __ZNSt9type_infoD2Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 return;
}
function __ZN10__cxxabiv123__fundamental_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN10__cxxabiv116__shim_type_infoD2Ev($this);
 __ZdlPv($this);
 return;
}
function __ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv($this,$thrown_type,$0) {
 $this = $this|0;
 $thrown_type = $thrown_type|0;
 $0 = $0|0;
 var $call = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$thrown_type,0)|0);
 return ($call|0);
}
function __ZN10__cxxabiv119__pointer_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN10__cxxabiv116__shim_type_infoD2Ev($this);
 __ZdlPv($this);
 return;
}
function __ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv($this,$thrown_type,$adjustedPtr) {
 $this = $this|0;
 $thrown_type = $thrown_type|0;
 $adjustedPtr = $adjustedPtr|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
 var $__flags = 0, $__flags4 = 0, $__pointee = 0, $__pointee7 = 0, $and = 0, $call = 0, $call12 = 0, $call8 = 0, $cmp = 0, $cmp19 = 0, $cmp26 = 0, $cmp29 = 0, $dst_ptr_leading_to_static_ptr = 0, $info = 0, $neg = 0, $number_of_dst_type = 0, $path_dst_ptr_to_static_ptr = 0, $retval$0 = 0, $retval$4 = 0, $src2dst_offset = 0;
 var $static_type = 0, $tobool = 0, $vfn = 0, $vtable = 0, dest = 0, label = 0, sp = 0, stop = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64|0;
 $info = sp;
 $0 = HEAP32[$adjustedPtr>>2]|0;
 $1 = HEAP32[$0>>2]|0;
 HEAP32[$adjustedPtr>>2] = $1;
 $call = (__ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv($this,$thrown_type,0)|0);
 if ($call) {
  $retval$4 = 1;
 } else {
  $2 = ($thrown_type|0)==(0|0);
  if ($2) {
   $retval$4 = 0;
  } else {
   $3 = (___dynamic_cast($thrown_type,320,376,0)|0);
   $cmp = ($3|0)==(0|0);
   if ($cmp) {
    $retval$4 = 0;
   } else {
    $__flags = ((($3)) + 8|0);
    $4 = HEAP32[$__flags>>2]|0;
    $__flags4 = ((($this)) + 8|0);
    $5 = HEAP32[$__flags4>>2]|0;
    $neg = $5 ^ -1;
    $and = $4 & $neg;
    $tobool = ($and|0)==(0);
    if ($tobool) {
     $__pointee = ((($this)) + 12|0);
     $6 = HEAP32[$__pointee>>2]|0;
     $__pointee7 = ((($3)) + 12|0);
     $7 = HEAP32[$__pointee7>>2]|0;
     $call8 = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($6,$7,0)|0);
     if ($call8) {
      $retval$4 = 1;
     } else {
      $8 = HEAP32[$__pointee>>2]|0;
      $call12 = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($8,408,0)|0);
      if ($call12) {
       $retval$4 = 1;
      } else {
       $9 = HEAP32[$__pointee>>2]|0;
       $10 = ($9|0)==(0|0);
       if ($10) {
        $retval$4 = 0;
       } else {
        $11 = (___dynamic_cast($9,320,304,0)|0);
        $cmp19 = ($11|0)==(0|0);
        if ($cmp19) {
         $retval$4 = 0;
        } else {
         $12 = HEAP32[$__pointee7>>2]|0;
         $13 = ($12|0)==(0|0);
         if ($13) {
          $retval$4 = 0;
         } else {
          $14 = (___dynamic_cast($12,320,304,0)|0);
          $cmp26 = ($14|0)==(0|0);
          if ($cmp26) {
           $retval$4 = 0;
          } else {
           $15 = ((($info)) + 4|0);
           dest=$15; stop=dest+52|0; do { HEAP32[dest>>2]=0|0; dest=dest+4|0; } while ((dest|0) < (stop|0));
           HEAP32[$info>>2] = $14;
           $static_type = ((($info)) + 8|0);
           HEAP32[$static_type>>2] = $11;
           $src2dst_offset = ((($info)) + 12|0);
           HEAP32[$src2dst_offset>>2] = -1;
           $number_of_dst_type = ((($info)) + 48|0);
           HEAP32[$number_of_dst_type>>2] = 1;
           $vtable = HEAP32[$14>>2]|0;
           $vfn = ((($vtable)) + 28|0);
           $16 = HEAP32[$vfn>>2]|0;
           $17 = HEAP32[$adjustedPtr>>2]|0;
           FUNCTION_TABLE_viiii[$16 & 7]($14,$info,$17,1);
           $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
           $18 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
           $cmp29 = ($18|0)==(1);
           if ($cmp29) {
            $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
            $19 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
            HEAP32[$adjustedPtr>>2] = $19;
            $retval$0 = 1;
           } else {
            $retval$0 = 0;
           }
           $retval$4 = $retval$0;
          }
         }
        }
       }
      }
     }
    } else {
     $retval$4 = 0;
    }
   }
  }
 }
 STACKTOP = sp;return ($retval$4|0);
}
function __ZNK10__cxxabiv117__pbase_type_info9can_catchEPKNS_16__shim_type_infoERPv($this,$thrown_type,$0) {
 $this = $this|0;
 $thrown_type = $thrown_type|0;
 $0 = $0|0;
 var $call = 0, $call2 = 0, $retval$0 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$thrown_type,0)|0);
 if ($call) {
  $retval$0 = 1;
 } else {
  $call2 = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($thrown_type,416,0)|0);
  $retval$0 = $call2;
 }
 return ($retval$0|0);
}
function __ZN10__cxxabiv121__vmi_class_type_infoD0Ev($this) {
 $this = $this|0;
 var label = 0, sp = 0;
 sp = STACKTOP;
 __ZN10__cxxabiv116__shim_type_infoD2Ev($this);
 __ZdlPv($this);
 return;
}
function __ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $__base_count = 0, $__flags = 0, $add$ptr = 0, $and = 0, $and30 = 0, $arraydecay = 0, $call = 0, $cmp = 0, $cmp19 = 0, $cmp40 = 0;
 var $found_any_static_type5 = 0, $found_our_static_ptr2 = 0, $incdec$ptr = 0, $incdec$ptr39 = 0, $p$0 = 0, $path_dst_ptr_to_static_ptr = 0, $search_done = 0, $static_type = 0, $tobool14 = 0, $tobool17 = 0, $tobool22 = 0, $tobool27 = 0, $tobool31 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,$use_strcmp)|0);
 if ($call) {
  __ZNK10__cxxabiv117__class_type_info29process_static_type_above_dstEPNS_19__dynamic_cast_infoEPKvS4_i(0,$info,$dst_ptr,$current_ptr,$path_below);
 } else {
  $found_our_static_ptr2 = ((($info)) + 52|0);
  $1 = HEAP8[$found_our_static_ptr2>>0]|0;
  $found_any_static_type5 = ((($info)) + 53|0);
  $2 = HEAP8[$found_any_static_type5>>0]|0;
  $arraydecay = ((($this)) + 16|0);
  $__base_count = ((($this)) + 12|0);
  $3 = HEAP32[$__base_count>>2]|0;
  $add$ptr = (((($this)) + 16|0) + ($3<<3)|0);
  HEAP8[$found_our_static_ptr2>>0] = 0;
  HEAP8[$found_any_static_type5>>0] = 0;
  __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($arraydecay,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp);
  $cmp = ($3|0)>(1);
  L4: do {
   if ($cmp) {
    $incdec$ptr = ((($this)) + 24|0);
    $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
    $__flags = ((($this)) + 8|0);
    $search_done = ((($info)) + 54|0);
    $p$0 = $incdec$ptr;
    while(1) {
     $4 = HEAP8[$search_done>>0]|0;
     $tobool14 = ($4<<24>>24)==(0);
     if (!($tobool14)) {
      break L4;
     }
     $5 = HEAP8[$found_our_static_ptr2>>0]|0;
     $tobool17 = ($5<<24>>24)==(0);
     if ($tobool17) {
      $8 = HEAP8[$found_any_static_type5>>0]|0;
      $tobool27 = ($8<<24>>24)==(0);
      if (!($tobool27)) {
       $9 = HEAP32[$__flags>>2]|0;
       $and30 = $9 & 1;
       $tobool31 = ($and30|0)==(0);
       if ($tobool31) {
        break L4;
       }
      }
     } else {
      $6 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
      $cmp19 = ($6|0)==(1);
      if ($cmp19) {
       break L4;
      }
      $7 = HEAP32[$__flags>>2]|0;
      $and = $7 & 2;
      $tobool22 = ($and|0)==(0);
      if ($tobool22) {
       break L4;
      }
     }
     HEAP8[$found_our_static_ptr2>>0] = 0;
     HEAP8[$found_any_static_type5>>0] = 0;
     __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($p$0,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp);
     $incdec$ptr39 = ((($p$0)) + 8|0);
     $cmp40 = ($incdec$ptr39>>>0)<($add$ptr>>>0);
     if ($cmp40) {
      $p$0 = $incdec$ptr39;
     } else {
      break;
     }
    }
   }
  } while(0);
  HEAP8[$found_our_static_ptr2>>0] = $1;
  HEAP8[$found_any_static_type5>>0] = $2;
 }
 return;
}
function __ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this,$info,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0;
 var $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $__base_count = 0, $__base_count63 = 0, $__flags34 = 0, $__flags72 = 0, $add = 0, $add$ptr = 0, $add$ptr64 = 0, $and = 0, $and35 = 0, $and73 = 0, $and88 = 0, $arraydecay = 0, $arraydecay62 = 0, $call = 0, $call3 = 0;
 var $cmp = 0, $cmp100 = 0, $cmp106 = 0, $cmp11 = 0, $cmp115 = 0, $cmp121 = 0, $cmp16 = 0, $cmp27 = 0, $cmp44 = 0, $cmp46 = 0, $cmp5 = 0, $cmp7 = 0, $cmp70 = 0, $cmp77 = 0, $cmp85 = 0, $cmp97 = 0, $does_dst_type_point_to_our_static_type$0$off0 = 0, $does_dst_type_point_to_our_static_type$1$off0 = 0, $dst_ptr_leading_to_static_ptr = 0, $dst_ptr_not_leading_to_static_ptr = 0;
 var $found_any_static_type = 0, $found_our_static_ptr = 0, $incdec$ptr = 0, $incdec$ptr105 = 0, $incdec$ptr120 = 0, $incdec$ptr69 = 0, $incdec$ptr84 = 0, $is_dst_type_derived_from_static_type = 0, $is_dst_type_derived_from_static_type13$0$off0 = 0, $is_dst_type_derived_from_static_type13$1$off0 = 0, $is_dst_type_derived_from_static_type13$2$off0 = 0, $number_to_dst_ptr = 0, $number_to_static_ptr = 0, $number_to_static_ptr76 = 0, $p$0 = 0, $p65$0 = 0, $p65$1 = 0, $p65$2 = 0, $path_dst_ptr_to_static_ptr = 0, $path_dst_ptr_to_static_ptr99 = 0;
 var $path_dynamic_ptr_to_dst_ptr = 0, $path_dynamic_ptr_to_dst_ptr10 = 0, $search_done = 0, $search_done110 = 0, $search_done79 = 0, $search_done92 = 0, $static_type = 0, $tobool111 = 0, $tobool18 = 0, $tobool22 = 0, $tobool25 = 0, $tobool30 = 0, $tobool36 = 0, $tobool74 = 0, $tobool80 = 0, $tobool89 = 0, $tobool93 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,$use_strcmp)|0);
 L1: do {
  if ($call) {
   __ZNK10__cxxabiv117__class_type_info29process_static_type_below_dstEPNS_19__dynamic_cast_infoEPKvi(0,$info,$current_ptr,$path_below);
  } else {
   $1 = HEAP32[$info>>2]|0;
   $call3 = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$1,$use_strcmp)|0);
   if (!($call3)) {
    $arraydecay62 = ((($this)) + 16|0);
    $__base_count63 = ((($this)) + 12|0);
    $16 = HEAP32[$__base_count63>>2]|0;
    $add$ptr64 = (((($this)) + 16|0) + ($16<<3)|0);
    __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($arraydecay62,$info,$current_ptr,$path_below,$use_strcmp);
    $incdec$ptr69 = ((($this)) + 24|0);
    $cmp70 = ($16|0)>(1);
    if (!($cmp70)) {
     break;
    }
    $__flags72 = ((($this)) + 8|0);
    $17 = HEAP32[$__flags72>>2]|0;
    $and73 = $17 & 2;
    $tobool74 = ($and73|0)==(0);
    if ($tobool74) {
     $number_to_static_ptr76 = ((($info)) + 36|0);
     $18 = HEAP32[$number_to_static_ptr76>>2]|0;
     $cmp77 = ($18|0)==(1);
     if (!($cmp77)) {
      $and88 = $17 & 1;
      $tobool89 = ($and88|0)==(0);
      if ($tobool89) {
       $search_done110 = ((($info)) + 54|0);
       $p65$2 = $incdec$ptr69;
       while(1) {
        $23 = HEAP8[$search_done110>>0]|0;
        $tobool111 = ($23<<24>>24)==(0);
        if (!($tobool111)) {
         break L1;
        }
        $24 = HEAP32[$number_to_static_ptr76>>2]|0;
        $cmp115 = ($24|0)==(1);
        if ($cmp115) {
         break L1;
        }
        __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($p65$2,$info,$current_ptr,$path_below,$use_strcmp);
        $incdec$ptr120 = ((($p65$2)) + 8|0);
        $cmp121 = ($incdec$ptr120>>>0)<($add$ptr64>>>0);
        if ($cmp121) {
         $p65$2 = $incdec$ptr120;
        } else {
         break L1;
        }
       }
      }
      $path_dst_ptr_to_static_ptr99 = ((($info)) + 24|0);
      $search_done92 = ((($info)) + 54|0);
      $p65$1 = $incdec$ptr69;
      while(1) {
       $20 = HEAP8[$search_done92>>0]|0;
       $tobool93 = ($20<<24>>24)==(0);
       if (!($tobool93)) {
        break L1;
       }
       $21 = HEAP32[$number_to_static_ptr76>>2]|0;
       $cmp97 = ($21|0)==(1);
       if ($cmp97) {
        $22 = HEAP32[$path_dst_ptr_to_static_ptr99>>2]|0;
        $cmp100 = ($22|0)==(1);
        if ($cmp100) {
         break L1;
        }
       }
       __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($p65$1,$info,$current_ptr,$path_below,$use_strcmp);
       $incdec$ptr105 = ((($p65$1)) + 8|0);
       $cmp106 = ($incdec$ptr105>>>0)<($add$ptr64>>>0);
       if ($cmp106) {
        $p65$1 = $incdec$ptr105;
       } else {
        break L1;
       }
      }
     }
    }
    $search_done79 = ((($info)) + 54|0);
    $p65$0 = $incdec$ptr69;
    while(1) {
     $19 = HEAP8[$search_done79>>0]|0;
     $tobool80 = ($19<<24>>24)==(0);
     if (!($tobool80)) {
      break L1;
     }
     __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($p65$0,$info,$current_ptr,$path_below,$use_strcmp);
     $incdec$ptr84 = ((($p65$0)) + 8|0);
     $cmp85 = ($incdec$ptr84>>>0)<($add$ptr64>>>0);
     if ($cmp85) {
      $p65$0 = $incdec$ptr84;
     } else {
      break L1;
     }
    }
   }
   $dst_ptr_leading_to_static_ptr = ((($info)) + 16|0);
   $2 = HEAP32[$dst_ptr_leading_to_static_ptr>>2]|0;
   $cmp = ($2|0)==($current_ptr|0);
   if (!($cmp)) {
    $dst_ptr_not_leading_to_static_ptr = ((($info)) + 20|0);
    $3 = HEAP32[$dst_ptr_not_leading_to_static_ptr>>2]|0;
    $cmp5 = ($3|0)==($current_ptr|0);
    if (!($cmp5)) {
     $path_dynamic_ptr_to_dst_ptr10 = ((($info)) + 32|0);
     HEAP32[$path_dynamic_ptr_to_dst_ptr10>>2] = $path_below;
     $is_dst_type_derived_from_static_type = ((($info)) + 44|0);
     $4 = HEAP32[$is_dst_type_derived_from_static_type>>2]|0;
     $cmp11 = ($4|0)==(4);
     if ($cmp11) {
      break;
     }
     $arraydecay = ((($this)) + 16|0);
     $__base_count = ((($this)) + 12|0);
     $5 = HEAP32[$__base_count>>2]|0;
     $add$ptr = (((($this)) + 16|0) + ($5<<3)|0);
     $found_our_static_ptr = ((($info)) + 52|0);
     $found_any_static_type = ((($info)) + 53|0);
     $search_done = ((($info)) + 54|0);
     $__flags34 = ((($this)) + 8|0);
     $path_dst_ptr_to_static_ptr = ((($info)) + 24|0);
     $does_dst_type_point_to_our_static_type$0$off0 = 0;$is_dst_type_derived_from_static_type13$0$off0 = 0;$p$0 = $arraydecay;
     L32: while(1) {
      $cmp16 = ($p$0>>>0)<($add$ptr>>>0);
      if (!($cmp16)) {
       $is_dst_type_derived_from_static_type13$2$off0 = $is_dst_type_derived_from_static_type13$0$off0;
       label = 18;
       break;
      }
      HEAP8[$found_our_static_ptr>>0] = 0;
      HEAP8[$found_any_static_type>>0] = 0;
      __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($p$0,$info,$current_ptr,$current_ptr,1,$use_strcmp);
      $6 = HEAP8[$search_done>>0]|0;
      $tobool18 = ($6<<24>>24)==(0);
      if (!($tobool18)) {
       $is_dst_type_derived_from_static_type13$2$off0 = $is_dst_type_derived_from_static_type13$0$off0;
       label = 18;
       break;
      }
      $7 = HEAP8[$found_any_static_type>>0]|0;
      $tobool22 = ($7<<24>>24)==(0);
      do {
       if ($tobool22) {
        $does_dst_type_point_to_our_static_type$1$off0 = $does_dst_type_point_to_our_static_type$0$off0;$is_dst_type_derived_from_static_type13$1$off0 = $is_dst_type_derived_from_static_type13$0$off0;
       } else {
        $8 = HEAP8[$found_our_static_ptr>>0]|0;
        $tobool25 = ($8<<24>>24)==(0);
        if ($tobool25) {
         $11 = HEAP32[$__flags34>>2]|0;
         $and35 = $11 & 1;
         $tobool36 = ($and35|0)==(0);
         if ($tobool36) {
          $is_dst_type_derived_from_static_type13$2$off0 = 1;
          label = 18;
          break L32;
         } else {
          $does_dst_type_point_to_our_static_type$1$off0 = $does_dst_type_point_to_our_static_type$0$off0;$is_dst_type_derived_from_static_type13$1$off0 = 1;
          break;
         }
        }
        $9 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
        $cmp27 = ($9|0)==(1);
        if ($cmp27) {
         label = 23;
         break L32;
        }
        $10 = HEAP32[$__flags34>>2]|0;
        $and = $10 & 2;
        $tobool30 = ($and|0)==(0);
        if ($tobool30) {
         label = 23;
         break L32;
        } else {
         $does_dst_type_point_to_our_static_type$1$off0 = 1;$is_dst_type_derived_from_static_type13$1$off0 = 1;
        }
       }
      } while(0);
      $incdec$ptr = ((($p$0)) + 8|0);
      $does_dst_type_point_to_our_static_type$0$off0 = $does_dst_type_point_to_our_static_type$1$off0;$is_dst_type_derived_from_static_type13$0$off0 = $is_dst_type_derived_from_static_type13$1$off0;$p$0 = $incdec$ptr;
     }
     do {
      if ((label|0) == 18) {
       if (!($does_dst_type_point_to_our_static_type$0$off0)) {
        HEAP32[$dst_ptr_not_leading_to_static_ptr>>2] = $current_ptr;
        $number_to_dst_ptr = ((($info)) + 40|0);
        $12 = HEAP32[$number_to_dst_ptr>>2]|0;
        $add = (($12) + 1)|0;
        HEAP32[$number_to_dst_ptr>>2] = $add;
        $number_to_static_ptr = ((($info)) + 36|0);
        $13 = HEAP32[$number_to_static_ptr>>2]|0;
        $cmp44 = ($13|0)==(1);
        if ($cmp44) {
         $14 = HEAP32[$path_dst_ptr_to_static_ptr>>2]|0;
         $cmp46 = ($14|0)==(2);
         if ($cmp46) {
          HEAP8[$search_done>>0] = 1;
          if ($is_dst_type_derived_from_static_type13$2$off0) {
           label = 23;
           break;
          } else {
           $15 = 4;
           break;
          }
         }
        }
       }
       if ($is_dst_type_derived_from_static_type13$2$off0) {
        label = 23;
       } else {
        $15 = 4;
       }
      }
     } while(0);
     if ((label|0) == 23) {
      $15 = 3;
     }
     HEAP32[$is_dst_type_derived_from_static_type>>2] = $15;
     break;
    }
   }
   $cmp7 = ($path_below|0)==(1);
   if ($cmp7) {
    $path_dynamic_ptr_to_dst_ptr = ((($info)) + 32|0);
    HEAP32[$path_dynamic_ptr_to_dst_ptr>>2] = 1;
   }
  }
 } while(0);
 return;
}
function __ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, $__base_count = 0, $add$ptr = 0, $arraydecay = 0, $call = 0, $cmp = 0, $cmp7 = 0, $incdec$ptr = 0, $incdec$ptr6 = 0, $p$0 = 0, $search_done = 0, $static_type = 0, $tobool = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $static_type = ((($info)) + 8|0);
 $0 = HEAP32[$static_type>>2]|0;
 $call = (__ZN10__cxxabiv18is_equalEPKSt9type_infoS2_b($this,$0,0)|0);
 L1: do {
  if ($call) {
   __ZNK10__cxxabiv117__class_type_info24process_found_base_classEPNS_19__dynamic_cast_infoEPvi(0,$info,$adjustedPtr,$path_below);
  } else {
   $arraydecay = ((($this)) + 16|0);
   $__base_count = ((($this)) + 12|0);
   $1 = HEAP32[$__base_count>>2]|0;
   $add$ptr = (((($this)) + 16|0) + ($1<<3)|0);
   __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($arraydecay,$info,$adjustedPtr,$path_below);
   $cmp = ($1|0)>(1);
   if ($cmp) {
    $incdec$ptr = ((($this)) + 24|0);
    $search_done = ((($info)) + 54|0);
    $p$0 = $incdec$ptr;
    while(1) {
     __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($p$0,$info,$adjustedPtr,$path_below);
     $2 = HEAP8[$search_done>>0]|0;
     $tobool = ($2<<24>>24)==(0);
     if (!($tobool)) {
      break L1;
     }
     $incdec$ptr6 = ((($p$0)) + 8|0);
     $cmp7 = ($incdec$ptr6>>>0)<($add$ptr>>>0);
     if ($cmp7) {
      $p$0 = $incdec$ptr6;
     } else {
      break;
     }
    }
   }
  }
 } while(0);
 return;
}
function __ZNK10__cxxabiv122__base_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi($this,$info,$adjustedPtr,$path_below) {
 $this = $this|0;
 $info = $info|0;
 $adjustedPtr = $adjustedPtr|0;
 $path_below = $path_below|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $__offset_flags = 0, $add$ptr = 0, $add$ptr4 = 0, $and = 0, $and6 = 0, $cond = 0, $offset_to_base$0 = 0, $shr = 0, $tobool = 0, $tobool7 = 0, $vfn = 0, $vtable3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $__offset_flags = ((($this)) + 4|0);
 $0 = HEAP32[$__offset_flags>>2]|0;
 $shr = $0 >> 8;
 $and = $0 & 1;
 $tobool = ($and|0)==(0);
 if ($tobool) {
  $offset_to_base$0 = $shr;
 } else {
  $1 = HEAP32[$adjustedPtr>>2]|0;
  $add$ptr = (($1) + ($shr)|0);
  $2 = HEAP32[$add$ptr>>2]|0;
  $offset_to_base$0 = $2;
 }
 $3 = HEAP32[$this>>2]|0;
 $vtable3 = HEAP32[$3>>2]|0;
 $vfn = ((($vtable3)) + 28|0);
 $4 = HEAP32[$vfn>>2]|0;
 $add$ptr4 = (($adjustedPtr) + ($offset_to_base$0)|0);
 $and6 = $0 & 2;
 $tobool7 = ($and6|0)==(0);
 $cond = $tobool7 ? 2 : $path_below;
 FUNCTION_TABLE_viiii[$4 & 7]($3,$info,$add$ptr4,$cond);
 return;
}
function __ZNK10__cxxabiv122__base_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib($this,$info,$dst_ptr,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $dst_ptr = $dst_ptr|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $__offset_flags = 0, $add$ptr = 0, $add$ptr4 = 0, $and = 0, $and6 = 0, $cond = 0, $offset_to_base$0 = 0, $shr = 0, $tobool = 0, $tobool7 = 0, $vfn = 0, $vtable3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $__offset_flags = ((($this)) + 4|0);
 $0 = HEAP32[$__offset_flags>>2]|0;
 $shr = $0 >> 8;
 $and = $0 & 1;
 $tobool = ($and|0)==(0);
 if ($tobool) {
  $offset_to_base$0 = $shr;
 } else {
  $1 = HEAP32[$current_ptr>>2]|0;
  $add$ptr = (($1) + ($shr)|0);
  $2 = HEAP32[$add$ptr>>2]|0;
  $offset_to_base$0 = $2;
 }
 $3 = HEAP32[$this>>2]|0;
 $vtable3 = HEAP32[$3>>2]|0;
 $vfn = ((($vtable3)) + 20|0);
 $4 = HEAP32[$vfn>>2]|0;
 $add$ptr4 = (($current_ptr) + ($offset_to_base$0)|0);
 $and6 = $0 & 2;
 $tobool7 = ($and6|0)==(0);
 $cond = $tobool7 ? 2 : $path_below;
 FUNCTION_TABLE_viiiiii[$4 & 3]($3,$info,$dst_ptr,$add$ptr4,$cond,$use_strcmp);
 return;
}
function __ZNK10__cxxabiv122__base_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib($this,$info,$current_ptr,$path_below,$use_strcmp) {
 $this = $this|0;
 $info = $info|0;
 $current_ptr = $current_ptr|0;
 $path_below = $path_below|0;
 $use_strcmp = $use_strcmp|0;
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $__offset_flags = 0, $add$ptr = 0, $add$ptr4 = 0, $and = 0, $and6 = 0, $cond = 0, $offset_to_base$0 = 0, $shr = 0, $tobool = 0, $tobool7 = 0, $vfn = 0, $vtable3 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $__offset_flags = ((($this)) + 4|0);
 $0 = HEAP32[$__offset_flags>>2]|0;
 $shr = $0 >> 8;
 $and = $0 & 1;
 $tobool = ($and|0)==(0);
 if ($tobool) {
  $offset_to_base$0 = $shr;
 } else {
  $1 = HEAP32[$current_ptr>>2]|0;
  $add$ptr = (($1) + ($shr)|0);
  $2 = HEAP32[$add$ptr>>2]|0;
  $offset_to_base$0 = $2;
 }
 $3 = HEAP32[$this>>2]|0;
 $vtable3 = HEAP32[$3>>2]|0;
 $vfn = ((($vtable3)) + 24|0);
 $4 = HEAP32[$vfn>>2]|0;
 $add$ptr4 = (($current_ptr) + ($offset_to_base$0)|0);
 $and6 = $0 & 2;
 $tobool7 = ($and6|0)==(0);
 $cond = $tobool7 ? 2 : $path_below;
 FUNCTION_TABLE_viiiii[$4 & 3]($3,$info,$add$ptr4,$cond,$use_strcmp);
 return;
}
function __ZSt15get_new_handlerv() {
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 sp = STACKTOP;
 $0 = HEAP32[789]|0;
 $1 = (($0) + 0)|0;
 HEAP32[789] = $1;
 $2 = $0;
 return ($2|0);
}
function _memcpy(dest, src, num) {
    dest = dest|0; src = src|0; num = num|0;
    var ret = 0;
    var aligned_dest_end = 0;
    var block_aligned_dest_end = 0;
    var dest_end = 0;
    // Test against a benchmarked cutoff limit for when HEAPU8.set() becomes faster to use.
    if ((num|0) >= 8192) {
      _emscripten_memcpy_big(dest|0, src|0, num|0)|0;
      return dest|0;
    }

    ret = dest|0;
    dest_end = (dest + num)|0;
    if ((dest&3) == (src&3)) {
      // The initial unaligned < 4-byte front.
      while (dest & 3) {
        if ((num|0) == 0) return ret|0;
        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
        dest = (dest+1)|0;
        src = (src+1)|0;
        num = (num-1)|0;
      }
      aligned_dest_end = (dest_end & -4)|0;
      block_aligned_dest_end = (aligned_dest_end - 64)|0;
      while ((dest|0) <= (block_aligned_dest_end|0) ) {
        HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
        HEAP32[(((dest)+(4))>>2)]=((HEAP32[(((src)+(4))>>2)])|0);
        HEAP32[(((dest)+(8))>>2)]=((HEAP32[(((src)+(8))>>2)])|0);
        HEAP32[(((dest)+(12))>>2)]=((HEAP32[(((src)+(12))>>2)])|0);
        HEAP32[(((dest)+(16))>>2)]=((HEAP32[(((src)+(16))>>2)])|0);
        HEAP32[(((dest)+(20))>>2)]=((HEAP32[(((src)+(20))>>2)])|0);
        HEAP32[(((dest)+(24))>>2)]=((HEAP32[(((src)+(24))>>2)])|0);
        HEAP32[(((dest)+(28))>>2)]=((HEAP32[(((src)+(28))>>2)])|0);
        HEAP32[(((dest)+(32))>>2)]=((HEAP32[(((src)+(32))>>2)])|0);
        HEAP32[(((dest)+(36))>>2)]=((HEAP32[(((src)+(36))>>2)])|0);
        HEAP32[(((dest)+(40))>>2)]=((HEAP32[(((src)+(40))>>2)])|0);
        HEAP32[(((dest)+(44))>>2)]=((HEAP32[(((src)+(44))>>2)])|0);
        HEAP32[(((dest)+(48))>>2)]=((HEAP32[(((src)+(48))>>2)])|0);
        HEAP32[(((dest)+(52))>>2)]=((HEAP32[(((src)+(52))>>2)])|0);
        HEAP32[(((dest)+(56))>>2)]=((HEAP32[(((src)+(56))>>2)])|0);
        HEAP32[(((dest)+(60))>>2)]=((HEAP32[(((src)+(60))>>2)])|0);
        dest = (dest+64)|0;
        src = (src+64)|0;
      }
      while ((dest|0) < (aligned_dest_end|0) ) {
        HEAP32[((dest)>>2)]=((HEAP32[((src)>>2)])|0);
        dest = (dest+4)|0;
        src = (src+4)|0;
      }
    } else {
      // In the unaligned copy case, unroll a bit as well.
      aligned_dest_end = (dest_end - 4)|0;
      while ((dest|0) < (aligned_dest_end|0) ) {
        HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
        HEAP8[(((dest)+(1))>>0)]=((HEAP8[(((src)+(1))>>0)])|0);
        HEAP8[(((dest)+(2))>>0)]=((HEAP8[(((src)+(2))>>0)])|0);
        HEAP8[(((dest)+(3))>>0)]=((HEAP8[(((src)+(3))>>0)])|0);
        dest = (dest+4)|0;
        src = (src+4)|0;
      }
    }
    // The remaining unaligned < 4 byte tail.
    while ((dest|0) < (dest_end|0)) {
      HEAP8[((dest)>>0)]=((HEAP8[((src)>>0)])|0);
      dest = (dest+1)|0;
      src = (src+1)|0;
    }
    return ret|0;
}
function _memset(ptr, value, num) {
    ptr = ptr|0; value = value|0; num = num|0;
    var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;
    end = (ptr + num)|0;

    value = value & 0xff;
    if ((num|0) >= 67 /* 64 bytes for an unrolled loop + 3 bytes for unaligned head*/) {
      while ((ptr&3) != 0) {
        HEAP8[((ptr)>>0)]=value;
        ptr = (ptr+1)|0;
      }

      aligned_end = (end & -4)|0;
      value4 = value | (value << 8) | (value << 16) | (value << 24);

      block_aligned_end = (aligned_end - 64)|0;

      while((ptr|0) <= (block_aligned_end|0)) {
        HEAP32[((ptr)>>2)]=value4;
        HEAP32[(((ptr)+(4))>>2)]=value4;
        HEAP32[(((ptr)+(8))>>2)]=value4;
        HEAP32[(((ptr)+(12))>>2)]=value4;
        HEAP32[(((ptr)+(16))>>2)]=value4;
        HEAP32[(((ptr)+(20))>>2)]=value4;
        HEAP32[(((ptr)+(24))>>2)]=value4;
        HEAP32[(((ptr)+(28))>>2)]=value4;
        HEAP32[(((ptr)+(32))>>2)]=value4;
        HEAP32[(((ptr)+(36))>>2)]=value4;
        HEAP32[(((ptr)+(40))>>2)]=value4;
        HEAP32[(((ptr)+(44))>>2)]=value4;
        HEAP32[(((ptr)+(48))>>2)]=value4;
        HEAP32[(((ptr)+(52))>>2)]=value4;
        HEAP32[(((ptr)+(56))>>2)]=value4;
        HEAP32[(((ptr)+(60))>>2)]=value4;
        ptr = (ptr + 64)|0;
      }

      while ((ptr|0) < (aligned_end|0) ) {
        HEAP32[((ptr)>>2)]=value4;
        ptr = (ptr+4)|0;
      }
    }
    // The remaining bytes.
    while ((ptr|0) < (end|0)) {
      HEAP8[((ptr)>>0)]=value;
      ptr = (ptr+1)|0;
    }
    return (end-num)|0;
}
function _sbrk(increment) {
    increment = increment|0;
    var oldDynamicTop = 0;
    var oldDynamicTopOnChange = 0;
    var newDynamicTop = 0;
    var totalMemory = 0;
    totalMemory = _emscripten_get_heap_size()|0;

      oldDynamicTop = HEAP32[DYNAMICTOP_PTR>>2]|0;
      newDynamicTop = oldDynamicTop + increment | 0;

      if (((increment|0) > 0 & (newDynamicTop|0) < (oldDynamicTop|0)) // Detect and fail if we would wrap around signed 32-bit int.
        | (newDynamicTop|0) < 0) { // Also underflow, sbrk() should be able to be used to subtract.
        abortOnCannotGrowMemory(newDynamicTop|0)|0;
        ___setErrNo(12);
        return -1;
      }

      if ((newDynamicTop|0) > (totalMemory|0)) {
        if (_emscripten_resize_heap(newDynamicTop|0)|0) {
          // We resized the heap. Start another loop iteration if we need to.
        } else {
          // We failed to resize the heap.
          ___setErrNo(12);
          return -1;
        }
      }

      HEAP32[DYNAMICTOP_PTR>>2] = newDynamicTop|0;

    return oldDynamicTop|0;
}


function dynCall_i(index) {
  index = index|0;

  return FUNCTION_TABLE_i[index&1]()|0;
}


function dynCall_ii(index,a1) {
  index = index|0;
  a1=a1|0;
  return FUNCTION_TABLE_ii[index&3](a1|0)|0;
}


function dynCall_iii(index,a1,a2) {
  index = index|0;
  a1=a1|0; a2=a2|0;
  return FUNCTION_TABLE_iii[index&3](a1|0,a2|0)|0;
}


function dynCall_iiii(index,a1,a2,a3) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0;
  return FUNCTION_TABLE_iiii[index&7](a1|0,a2|0,a3|0)|0;
}


function dynCall_iiiii(index,a1,a2,a3,a4) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  return FUNCTION_TABLE_iiiii[index&3](a1|0,a2|0,a3|0,a4|0)|0;
}


function dynCall_iiiiii(index,a1,a2,a3,a4,a5) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  return FUNCTION_TABLE_iiiiii[index&1](a1|0,a2|0,a3|0,a4|0,a5|0)|0;
}


function dynCall_v(index) {
  index = index|0;

  FUNCTION_TABLE_v[index&0]();
}


function dynCall_vi(index,a1) {
  index = index|0;
  a1=a1|0;
  FUNCTION_TABLE_vi[index&15](a1|0);
}


function dynCall_vii(index,a1,a2) {
  index = index|0;
  a1=a1|0; a2=a2|0;
  FUNCTION_TABLE_vii[index&7](a1|0,a2|0);
}


function dynCall_viii(index,a1,a2,a3) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0;
  FUNCTION_TABLE_viii[index&3](a1|0,a2|0,a3|0);
}


function dynCall_viiii(index,a1,a2,a3,a4) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0;
  FUNCTION_TABLE_viiii[index&7](a1|0,a2|0,a3|0,a4|0);
}


function dynCall_viiiii(index,a1,a2,a3,a4,a5) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0;
  FUNCTION_TABLE_viiiii[index&3](a1|0,a2|0,a3|0,a4|0,a5|0);
}


function dynCall_viiiiii(index,a1,a2,a3,a4,a5,a6) {
  index = index|0;
  a1=a1|0; a2=a2|0; a3=a3|0; a4=a4|0; a5=a5|0; a6=a6|0;
  FUNCTION_TABLE_viiiiii[index&3](a1|0,a2|0,a3|0,a4|0,a5|0,a6|0);
}

function b0() {
 ; abort(0);return 0;
}
function b1(p0) {
 p0 = p0|0; abort(1);return 0;
}
function b2(p0,p1) {
 p0 = p0|0;p1 = p1|0; abort(2);return 0;
}
function b3(p0,p1,p2) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0; abort(3);return 0;
}
function b4(p0,p1,p2,p3) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0; abort(4);return 0;
}
function b5(p0,p1,p2,p3,p4) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0;p4 = p4|0; abort(5);return 0;
}
function b6() {
 ; abort(6);
}
function b7(p0) {
 p0 = p0|0; abort(7);
}
function b8(p0,p1) {
 p0 = p0|0;p1 = p1|0; abort(8);
}
function b9(p0,p1,p2) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0; abort(9);
}
function b10(p0,p1,p2,p3) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0; abort(10);
}
function b11(p0,p1,p2,p3,p4) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0;p4 = p4|0; abort(11);
}
function b12(p0,p1,p2,p3,p4,p5) {
 p0 = p0|0;p1 = p1|0;p2 = p2|0;p3 = p3|0;p4 = p4|0;p5 = p5|0; abort(12);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_i = [b0,__ZN10emscripten8internal12operator_newI6QStateJEEEPT_DpOT0_];
var FUNCTION_TABLE_ii = [b1,__ZN10emscripten8internal13getActualTypeI6QStateEEPKvPT_,__ZN10emscripten8internal7InvokerIP6QStateJEE6invokeEPFS3_vE,b1];
var FUNCTION_TABLE_iii = [b2,__Z12peek_state_rRK6QStatei,__ZN10emscripten8internal7InvokerI6QStateJRKS2_EE6invokeEPFS2_S4_EPS2_,b2];
var FUNCTION_TABLE_iiii = [b3,__ZNK10__cxxabiv117__class_type_info9can_catchEPKNS_16__shim_type_infoERPv,__ZNK10__cxxabiv123__fundamental_type_info9can_catchEPKNS_16__shim_type_infoERPv,__ZNK10__cxxabiv119__pointer_type_info9can_catchEPKNS_16__shim_type_infoERPv,__Z12peek_state_xRK6QStateii,__Z12peek_state_zRK6QStateii,__ZN10emscripten8internal7InvokerIcJRK6QStateiEE6invokeEPFcS4_iEPS2_i,b3];
var FUNCTION_TABLE_iiiii = [b4,__Z7measureR6QStatelib,__ZN10emscripten8internal7InvokerIcJRK6QStateiiEE6invokeEPFcS4_iiEPS2_ii,b4];
var FUNCTION_TABLE_iiiiii = [b5,__ZN10emscripten8internal7InvokerIiJR6QStatelibEE6invokeEPFiS3_libEPS2_lib];
var FUNCTION_TABLE_v = [b6];
var FUNCTION_TABLE_vi = [b7,__ZN10__cxxabiv116__shim_type_infoD2Ev,__ZN10__cxxabiv117__class_type_infoD0Ev,__ZNK10__cxxabiv116__shim_type_info5noop1Ev,__ZNK10__cxxabiv116__shim_type_info5noop2Ev,__ZN10__cxxabiv120__si_class_type_infoD0Ev,__ZN10__cxxabiv123__fundamental_type_infoD0Ev,__ZN10__cxxabiv119__pointer_type_infoD0Ev,__ZN10__cxxabiv121__vmi_class_type_infoD0Ev,__ZN10emscripten8internal14raw_destructorI6QStateEEvPT_,__Z10free_stateR6QState,b7,b7,b7,b7,b7];
var FUNCTION_TABLE_vii = [b8,__Z9initstae_R6QStatel,__Z8hadamardR6QStatel,__Z5phaseR6QStatel,__Z11clone_stateRK6QState,__ZN10emscripten8internal7InvokerIvJR6QStateEE6invokeEPFvS3_EPS2_,b8,b8];
var FUNCTION_TABLE_viii = [b9,__Z4cnotR6QStatell,__ZN10emscripten8internal7InvokerIvJR6QStatelEE6invokeEPFvS3_lEPS2_l,b9];
var FUNCTION_TABLE_viiii = [b10,__ZNK10__cxxabiv117__class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,__ZNK10__cxxabiv120__si_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,__ZNK10__cxxabiv121__vmi_class_type_info27has_unambiguous_public_baseEPNS_19__dynamic_cast_infoEPvi,__ZN10emscripten8internal7InvokerIvJR6QStatellEE6invokeEPFvS3_llEPS2_ll,b10,b10,b10];
var FUNCTION_TABLE_viiiii = [b11,__ZNK10__cxxabiv117__class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,__ZNK10__cxxabiv120__si_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib,__ZNK10__cxxabiv121__vmi_class_type_info16search_below_dstEPNS_19__dynamic_cast_infoEPKvib];
var FUNCTION_TABLE_viiiiii = [b12,__ZNK10__cxxabiv117__class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,__ZNK10__cxxabiv120__si_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib,__ZNK10__cxxabiv121__vmi_class_type_info16search_above_dstEPNS_19__dynamic_cast_infoEPKvS4_ib];

  return { ___errno_location: ___errno_location, ___getTypeName: ___getTypeName, _free: _free, _malloc: _malloc, _memcpy: _memcpy, _memset: _memset, _sbrk: _sbrk, dynCall_i: dynCall_i, dynCall_ii: dynCall_ii, dynCall_iii: dynCall_iii, dynCall_iiii: dynCall_iiii, dynCall_iiiii: dynCall_iiiii, dynCall_iiiiii: dynCall_iiiiii, dynCall_v: dynCall_v, dynCall_vi: dynCall_vi, dynCall_vii: dynCall_vii, dynCall_viii: dynCall_viii, dynCall_viiii: dynCall_viiii, dynCall_viiiii: dynCall_viiiii, dynCall_viiiiii: dynCall_viiiiii, establishStackSpace: establishStackSpace, globalCtors: globalCtors, stackAlloc: stackAlloc, stackRestore: stackRestore, stackSave: stackSave };
})
// EMSCRIPTEN_END_ASM
(asmGlobalArg, asmLibraryArg, buffer);

var ___errno_location = Module["___errno_location"] = asm["___errno_location"];
var ___getTypeName = Module["___getTypeName"] = asm["___getTypeName"];
var _free = Module["_free"] = asm["_free"];
var _malloc = Module["_malloc"] = asm["_malloc"];
var _memcpy = Module["_memcpy"] = asm["_memcpy"];
var _memset = Module["_memset"] = asm["_memset"];
var _sbrk = Module["_sbrk"] = asm["_sbrk"];
var establishStackSpace = Module["establishStackSpace"] = asm["establishStackSpace"];
var globalCtors = Module["globalCtors"] = asm["globalCtors"];
var stackAlloc = Module["stackAlloc"] = asm["stackAlloc"];
var stackRestore = Module["stackRestore"] = asm["stackRestore"];
var stackSave = Module["stackSave"] = asm["stackSave"];
var dynCall_i = Module["dynCall_i"] = asm["dynCall_i"];
var dynCall_ii = Module["dynCall_ii"] = asm["dynCall_ii"];
var dynCall_iii = Module["dynCall_iii"] = asm["dynCall_iii"];
var dynCall_iiii = Module["dynCall_iiii"] = asm["dynCall_iiii"];
var dynCall_iiiii = Module["dynCall_iiiii"] = asm["dynCall_iiiii"];
var dynCall_iiiiii = Module["dynCall_iiiiii"] = asm["dynCall_iiiiii"];
var dynCall_v = Module["dynCall_v"] = asm["dynCall_v"];
var dynCall_vi = Module["dynCall_vi"] = asm["dynCall_vi"];
var dynCall_vii = Module["dynCall_vii"] = asm["dynCall_vii"];
var dynCall_viii = Module["dynCall_viii"] = asm["dynCall_viii"];
var dynCall_viiii = Module["dynCall_viiii"] = asm["dynCall_viiii"];
var dynCall_viiiii = Module["dynCall_viiiii"] = asm["dynCall_viiiii"];
var dynCall_viiiiii = Module["dynCall_viiiiii"] = asm["dynCall_viiiiii"];
;



// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;











































































if (memoryInitializer) {
  if (!isDataURI(memoryInitializer)) {
    memoryInitializer = locateFile(memoryInitializer);
  }
  if (ENVIRONMENT_IS_NODE || ENVIRONMENT_IS_SHELL) {
    var data = Module['readBinary'](memoryInitializer);
    HEAPU8.set(data, GLOBAL_BASE);
  } else {
    addRunDependency('memory initializer');
    var applyMemoryInitializer = function(data) {
      if (data.byteLength) data = new Uint8Array(data);
      HEAPU8.set(data, GLOBAL_BASE);
      // Delete the typed array that contains the large blob of the memory initializer request response so that
      // we won't keep unnecessary memory lying around. However, keep the XHR object itself alive so that e.g.
      // its .status field can still be accessed later.
      if (Module['memoryInitializerRequest']) delete Module['memoryInitializerRequest'].response;
      removeRunDependency('memory initializer');
    }
    var doBrowserLoad = function() {
      Module['readAsync'](memoryInitializer, applyMemoryInitializer, function() {
        throw 'could not load memory initializer ' + memoryInitializer;
      });
    }
    var memoryInitializerBytes = tryParseAsDataURI(memoryInitializer);
    if (memoryInitializerBytes) {
      applyMemoryInitializer(memoryInitializerBytes.buffer);
    } else
    if (Module['memoryInitializerRequest']) {
      // a network request has already been created, just use that
      var useRequest = function() {
        var request = Module['memoryInitializerRequest'];
        var response = request.response;
        if (request.status !== 200 && request.status !== 0) {
          var data = tryParseAsDataURI(Module['memoryInitializerRequestURL']);
          if (data) {
            response = data.buffer;
          } else {
            // If you see this warning, the issue may be that you are using locateFile and defining it in JS. That
            // means that the HTML file doesn't know about it, and when it tries to create the mem init request early, does it to the wrong place.
            // Look in your browser's devtools network console to see what's going on.
            console.warn('a problem seems to have happened with Module.memoryInitializerRequest, status: ' + request.status + ', retrying ' + memoryInitializer);
            doBrowserLoad();
            return;
          }
        }
        applyMemoryInitializer(response);
      }
      if (Module['memoryInitializerRequest'].response) {
        setTimeout(useRequest, 0); // it's already here; but, apply it asynchronously
      } else {
        Module['memoryInitializerRequest'].addEventListener('load', useRequest); // wait for it
      }
    } else {
      // fetch it from the network ourselves
      doBrowserLoad();
    }
  }
}



/**
 * @constructor
 * @extends {Error}
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}





/** @type {function(Array=)} */
function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    return;
  }


  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    ensureInitRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();


    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
}
Module['run'] = run;


function exit(status, implicit) {

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && Module['noExitRuntime'] && status === 0) {
    return;
  }

  if (Module['noExitRuntime']) {
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  Module['quit'](status, new ExitStatus(status));
}

var abortDecorators = [];

function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  if (what !== undefined) {
    out(what);
    err(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  throw 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';
}
Module['abort'] = abort;

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


  Module["noExitRuntime"] = true;

run();





// {{MODULE_ADDITIONS}}



let QState = Module.QState;
let init_state = Module.init_state;
let free_state = Module.free_state;
let cnot = Module.cnot;
let hadamard = Module.hadamard;
let phase = Module.phase;
let measure = Module.measure;
let clone_state = Module.clone_state;
let peek_state_x = Module.peek_state_x;
let peek_state_z = Module.peek_state_z;
let peek_state_r = Module.peek_state_r;
_gen_package_export("src/sim/chp_gen.js", {QState, init_state, free_state, cnot, hadamard, phase, clone_state, measure, peek_state_x, peek_state_z, peek_state_r});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/ChpSimulator.js", function() {

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {SimulatorSpec} = _gen_package_get("src/sim/SimulatorSpec.js");;
const {BitTable} = _gen_package_get("src/sim/BitTable.js");;
const {Measurement} = _gen_package_get("src/sim/Measurement.js");;
const {
    QState,
    init_state,
    free_state,
    cnot,
    hadamard,
    phase,
    clone_state,
    measure,
    peek_state_x,
    peek_state_z,
    peek_state_r,
} = _gen_package_get("src/sim/chp_gen.js");
/**
 How to produce chp_gen.js

 0) Go to https://www.scottaaronson.com/chp/ and download "chp.c" as a starting point

 1) Rename chp.c to chp.cpp

 2) Delete unused functions and types that cause trouble.

        delete error
        delete main
        delete readprog
        delete runprog
        delete QProg struct
        delete unused gate macro defs
        delete preparestate
        delete printstate
        delete printbasisstate
        delete printket
        drop s parameter of initstae_ and delete the line that was using it

 3) Every line with a malloc needs a static_cast to the correct type.

 4) Emscripten is confused by pointer args. Use references instead of pointers.
        search-replace "struct QState *" with "struct QState &"
        search-replace "q->" with "q."

 5) Replace includes with:

        #include <cstring>
        #include <cstdlib>

 6) Append this code to the end of the file:

        void free_state(struct QState &q) {
            for (long i = 0; i < 2 * q.n + 1; i++) {
                free(q.x[i]);
                free(q.z[i]);
            }
            free(q.x);
            free(q.z);
            free(q.r);
        }

        QState clone_state(const struct QState &src) {
            QState q = {};
            q.n = src.n;
            q.over32 = src.over32;
            memcpy(q.pw, src.pw, sizeof(q.pw));

            int s = 2 * q.n + 1;
            q.r = static_cast<int *>(malloc(s * sizeof(int)));
            memcpy(q.r, src.r, s * sizeof(int));

            q.x = static_cast<unsigned long **>(malloc(s * sizeof(unsigned long *)));
            q.z = static_cast<unsigned long **>(malloc(s * sizeof(unsigned long *)));
            for (int i = 0; i < s; i++) {
                q.x[i] = static_cast<unsigned long *>(malloc(q.over32 * sizeof(unsigned long)));
                q.z[i] = static_cast<unsigned long *>(malloc(q.over32 * sizeof(unsigned long)));
                memcpy(q.x[i], src.x[i], q.over32 * sizeof(unsigned long));
                memcpy(q.z[i], src.z[i], q.over32 * sizeof(unsigned long));
            }
            return q;
        }

         char peek_state_x(const struct QState &src, int row, int col) {
            int c = col >> 5;
            int m = 1 << (col & 31);
            return src.x[row][c] & m ? 1 : 0;
        }

         char peek_state_z(const struct QState &src, int row, int col) {
            int c = col >> 5;
            int m = 1 << (col & 31);
            return src.x[row][c] & m ? 1 : 0;
        }

         char peek_state_r(const struct QState &src, int row) {
            return src.r[row] ? 1 : 0;
        }

        #include <emscripten/bind.h>
        using namespace emscripten;
        EMSCRIPTEN_BINDINGS(my_module) {
            class_<QState>("QState").constructor<>();
            function("init_state", &initstae_);
            function("cnot", &cnot);
            function("hadamard", &hadamard);
            function("phase", &phase);
            function("measure", &measure);
            function("free_state", &free_state);
            function("clone_state", &clone_state);
            function("peek_state_x", &peek_state_x);
            function("peek_state_z", &peek_state_z);
            function("peek_state_r", &peek_state_r);
        }

    7) Add bool random_result parameter to measure

        search-replace "rand()%2" with "random_result ? 1 : 0"

    8) Compile with Emscripten

        emcc -O1 --bind chp.cpp -std=c++11 -o chp_gen.js -s WASM=0

        Note: using -O2 causes a "could not load memory initializer" error when running. Not sure why.

    9) Append export lines to generated code

         let QState = Module.QState;
         let init_state = Module.init_state;
         let free_state = Module.free_state;
         let cnot = Module.cnot;
         let hadamard = Module.hadamard;
         let phase = Module.phase;
         let measure = Module.measure;
         let clone_state = Module.clone_state;
         let peek_state_x = Module.peek_state_x;
         let peek_state_z = Module.peek_state_z;
         let peek_state_r = Module.peek_state_r;
         _gen_package_export("src/sim/ChpSimulator.js", {QState, init_state, free_state, cnot, hadamard, phase, clone_state, measure, peek_state_x, peek_state_z, peek_state_r});
*/


class ChpSimulator extends SimulatorSpec {
    /**
     * @param {!int} maxQubitCount
     * @param {!number} defaultBias
     */
    constructor(maxQubitCount=10, defaultBias=0.5) {
        super();
        this._state = new QState();
        init_state(this._state, maxQubitCount);
        this._maxQubitCount = maxQubitCount;
        this._nextQubitId = 0;
        this._qubitToSlotMap = new Map();
        this._qubitSlots = [];
        this._defaultBias = defaultBias;
    }

    /**
     * @returns {!ChpSimulator}
     */
    clone() {
        let result = new ChpSimulator(this._maxQubitCount);
        result.destruct();
        result._state = clone_state(this._state);
        result._nextQubitId = this._nextQubitId;
        for (let [k, v] of this._qubitToSlotMap.entries()) {
            result._qubitToSlotMap.set(k, v);
        }
        result._qubitSlots = this._qubitSlots.slice();
        return result;
    }

    qalloc() {
        if (this._qubitSlots.length >= this._maxQubitCount) {
            throw new Error("Too many qubits");
        }
        let id = this._nextQubitId;
        this._nextQubitId += 1;
        this._qubitToSlotMap.set(id, this._qubitSlots.length);
        this._qubitSlots.push(id);
        return id;
    }

    /**
     * Measures a qubit.
     * @param {!int} q The handle of the qubit to measure.
     * @param {!number|undefined=} bias When a measurement result is non-deterministic, this determines the probability of True.
     * @returns {!Measurement} The measurement result.
     */
    measure(q, bias=undefined) {
        if (bias === undefined) {
            bias = this._defaultBias;
        }
        let randomResult = Math.random() < bias;
        let a = this._slotFor(q);
        let m = measure(this._state, a, 0, randomResult);
        return new Measurement((m & 1) !== 0, (m & 2) !== 0);
    }

    free(q) {
        // Decohere the qubit.
        if (this.measure(q).result) {
            this.x(q);
        }

        // Move qubit to deallocate to the end of the list, then pop it off.
        let k = this._slotFor(q);
        let q2 = this._qubitSlots[this._qubitSlots.length - 1];
        this.swap(q, q2);
        this._qubitToSlotMap.set(q2, k);
        this._qubitSlots[k] = q2;
        this._qubitSlots.pop();
        this._qubitToSlotMap.delete(q);
    }

    cnot(control, target) {
        let a = this._slotFor(control);
        let b = this._slotFor(target);
        if (a === b) {
            throw new DetailedError('target and control are the same.', {target, control})
        }
        cnot(this._state, a, b);
    }

    hadamard(target) {
        let a = this._slotFor(target);
        hadamard(this._state, a);
    }

    phase(target) {
        let a = this._slotFor(target);
        phase(this._state, a);
    }

    /**
     * @param {!int} q
     * @returns {!int}
     * @private
     */
    _slotFor(q) {
        if (!this._qubitToSlotMap.has(q)) {
            throw new Error(`Invalid qubit handle: ${q}`);
        }
        return this._qubitToSlotMap.get(q);
    }

    probability(target) {
        let q = clone_state(this._state);
        let a = this._slotFor(target);
        let m = measure(q, a, 0, false);
        free_state(q);
        if ((m & 2) !== 0) {
            return 0.5;
        }
        return m;
    }

    collapse(target, outcome) {
        let a = this._slotFor(target);
        let m = measure(this._state, a, 0, outcome);
        let result = (m & 1) !== 0;
        if (result !== outcome) {
            throw new DetailedError("Failed to post-select; result impossible.", {target, m, result, outcome});
        }
    }

    /**
     * @returns {!BitTable}
     */
    table() {
        let n = this._maxQubitCount;
        let out = BitTable.zeros(2*n+1, 2*n);
        for (let row = 0; row < 2*n; row++) {
            for (let col = 0; col < n; col++) {
                out.set(row, col, peek_state_x(this._state, row, col));
            }
            for (let col = 0; col < n; col++) {
                out.set(row, col + n, peek_state_z(this._state, row, col));
            }
            out.set(row, 2 * n, peek_state_r(this._state, row));
        }
        return out;
    }

    destruct() {
        free_state(this._state);
        this._state = undefined;
    }

    /**
     * @returns {!string}
     */
    toString() {
        let n = this._maxQubitCount;

        let _cell = (row, col) => {
            let k = peek_state_x(this._state, row, col) + 2 * peek_state_z(this._state, row, col);
            return ['.', 'X', 'Z', 'Y'][k]
        };

        let _row = row => {
            let result = peek_state_r(this._state, row) ? '-' : '+';
            for (let col = 0; col < n; col++) {
                result += _cell(row, col)
            }
            return result;
        };

        let out = [];
        for (let row = 0; row < n; row++) {
            out.push(_row(row));
        }
        out.push('-'.repeat(n + 1));
        for (let row = 0; row < n; row++) {
            out.push(_row(row + n));
        }
        return out.join('\n');
    }
}

_gen_package_export("src/sim/ChpSimulator.js", {ChpSimulator});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/Controls.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {Seq} = _gen_package_get("src/base/Seq.js");
const {Util} = _gen_package_get("src/base/Util.js");

/**
 * Stores a set of requirements that a state's bits must meet.
 *
 * Mostly used for specifying the controls on an operation, i.e. which wires must be ON or OFF for it to apply.
 */
class Controls {
    /**
     * @param {!int} inclusionMask.
     * @param {!int} desiredValueMask
     * @property {!int} inclusionMask.
     * @property {!int} desiredValueMask
     */
    constructor(inclusionMask, desiredValueMask) {
        if ((desiredValueMask & ~inclusionMask) !== 0) {
            throw new DetailedError("Desired un-included bits", {inclusionMask, desiredValueMask});
        }
        /** @type {!int} */
        this.inclusionMask = inclusionMask;
        /** @type {!int} */
        this.desiredValueMask = desiredValueMask;
    }

    /**
     * @param {!int} bitIndex
     * @param {!boolean} desiredValue
     * @returns {!Controls}
     */
    static bit(bitIndex, desiredValue) {
        if (bitIndex < 0) {
            throw new DetailedError("Out of range", {bitIndex})
        }
        return new Controls(1 << bitIndex, desiredValue ? (1 << bitIndex) : 0);
    }

    /**
     * @param {!Controls|*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof Controls &&
            this.inclusionMask === other.inclusionMask &&
            this.desiredValueMask === other.desiredValueMask;
    }

    /**
     * @returns {!string}
     */
    toString() {
        if (this.inclusionMask === 0) {
            return "No Controls";
        }

        return "Controls: ...__" + Seq.naturals().
            takeWhile(i => (1<<i) <= this.inclusionMask).
            map(this.desiredValueFor.bind(this)).
            map(e => e === undefined ? "_" : e ? "1" : "0").
            reverse().
            join("");
    }

    /**
     * @param {!int} stateIndex
     * @returns {!boolean}
     */
    allowsState(stateIndex) {
        return (this.inclusionMask & stateIndex) === this.desiredValueMask;
    }

    /**
     * @param {!int} bitIndex
     * @returns {undefined|!boolean}
     */
    desiredValueFor(bitIndex) {
        if ((this.inclusionMask & (1 << bitIndex)) === 0) {
            return undefined;
        }
        return (this.desiredValueMask & (1 << bitIndex)) !== 0;
    }

    /**
     * @returns {!int|Infinity}
     */
    includedBitCount() {
        if (this.inclusionMask < 0) {
            return Infinity;
        }
        return Util.numberOfSetBits(this.inclusionMask);
    }

    /**
     * @param {!Controls} other
     * @returns {!Controls}
     */
    and(other) {
        if ((other.desiredValueMask & this.inclusionMask) !== (this.desiredValueMask & other.inclusionMask)) {
            throw new DetailedError("Contradictory controls.", {"this": this, other})
        }
        return new Controls(
            this.inclusionMask | other.inclusionMask,
            this.desiredValueMask | other.desiredValueMask);
    }

    /**
     * @param {!int} offset
     * @returns {!Controls}
     */
    shift(offset) {
        return new Controls(
            this.inclusionMask << offset,
            this.desiredValueMask << offset)
    }
}

/** @type {!Controls} */
Controls.NONE = new Controls(0, 0);

_gen_package_export("src/sim/Controls.js", {Controls});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/EdgeActions.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {equate} = _gen_package_get("src/base/Equate.js");;
const {padSetTo, QuantumStatement} = _gen_package_get("src/sim/QuantumProgram.js");;
const {NODES} = _gen_package_get("src/nodes/All.js");;


class EdgeActions extends QuantumStatement {
    /**
     * @param {!GeneralMap.<!int, !string>|!Map.<!int, !string>} changes Qubit to edge action kind.
     * @param {!boolean} useRootNodeEdgeAction
     */
    constructor(changes, useRootNodeEdgeAction) {
        super();
        this.changes = changes;
        this.useRootNodeEdgeAction = useRootNodeEdgeAction;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof EdgeActions &&
            equate(this.changes, other.changes) &&
            this.useRootNodeEdgeAction === other.useRootNodeEdgeAction);
    }

    /**
     * @param {!string} kind
     * @returns {*}
     * @private
     */
    _action(kind) {
        let nodeKind = NODES.map.get(kind);
        if (this.useRootNodeEdgeAction) {
            return nodeKind.nodeRootEdgeAction;
        }
        return nodeKind.edgeAction;
    }

    writeQasm(statements) {
        for (let [qubit, kind] of this.changes.entries()) {
            let ops = this._action(kind).qasmGates;
            for (let op of ops) {
                statements.push(`${op} q[${qubit}];`);
            }
        }
    }

    writeQuirk(init, cols) {
        let col = [];
        for (let [qubit, kind] of this.changes.entries()) {
            let quirkGate = this._action(kind).quirkGate;
            padSetTo(col, 1, qubit, quirkGate);
        }
        cols.push(col);
    }

    interpret(sim, out) {
        for (let [qubit, kind] of this.changes.entries()) {
            this._action(kind).sim(sim, qubit);
        }
    }
}

_gen_package_export("src/sim/EdgeActions.js", {EdgeActions});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/Measurement.js", function() {

/**
 * Measurement result from a stabilizer simulator, with known random-vs-deterministic origin.
 */
class Measurement {
    /**
     * @param {!boolean} result
     * @param {!boolean} random
     */
    constructor(result, random) {
        this.result = result;
        this.random = random;
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `${this.result} (${this.random ? 'random' : 'determined'})`;
    }

    /**
     * @param {!Measurement|*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof Measurement && this.result === other.result && this.random === other.random;
    }
}

_gen_package_export("src/sim/Measurement.js", {Measurement});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/PauliProduct.js", function() {

const {Complex} = _gen_package_get("src/base/Complex.js");;
const {Seq} = _gen_package_get("src/base/Seq.js");;


const _PAULI_NAMES = ['.', 'X', 'Z', 'Y'];


class QubitAxis {
    /**
     * @param {!int} qubit
     * @param {!boolean} axis
     */
    constructor(qubit, axis) {
        this.qubit = qubit;
        this.axis = axis;
    }

    /**
     * @param {!int} qubit
     * @returns {!QubitAxis}
     */
    static x(qubit) {
        return new QubitAxis(qubit, false);
    }

    /**
     * @param {!int} qubit
     * @returns {!QubitAxis}
     */
    static z(qubit) {
        return new QubitAxis(qubit, true);
    }

    /**
     * @param {object|!QubitAxis} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof QubitAxis && other.axis === this.axis && other.qubit === this.qubit;
    }

    /**
     * @returns {!number}
     */
    orderVal() {
        return this.qubit + (this.axis ? 0.5 : 0);
    }
    /**
     * @returns {!string}
     */
    toString() {
        return `${this.axis ? 'Z' : 'X'}${this.qubit}`;
    }
}


class PauliProduct {
    /**
     * @param {!int} phase_exponent
     * @param {!Uint8Array} paulis
     */
    constructor(phase_exponent, paulis) {
        this.phase_exponent = phase_exponent & 3;
        this.paulis = paulis;
    }

    /**
     * @param {!int} n
     * @param {!Array.<!QubitAxis>} qubitAxes
     */
    static fromSparseQubitAxes(n, qubitAxes) {
        let result = new PauliProduct(0, new Uint8Array(n));
        for (let qa of qubitAxes) {
            result.inline_times(qa);
        }
        return result;
    }

    /**
     * @param {!int} n
     * @param {!object.<!int, !string|!int>} indexToTypeMap
     */
    static fromSparse(n, indexToTypeMap) {
        let paulis = new Uint8Array(n);
        for (let k of Object.keys(indexToTypeMap)) {
            if (k < 0 || k >= n) {
                throw new Error(`Bad index ${k}.`);
            }
            let v = indexToTypeMap[k];
            if (typeof v === 'string') {
                v = _PAULI_NAMES.indexOf(v);
                if (v === -1) {
                    throw new Error(`Bad character.`);
                }
            }
            paulis[k] = v;
        }
        return new PauliProduct(0, paulis);
    }

    /**
     * @param {!int} n
     * @param {!object.<!string, !Array.<!int>>} typeToIndexMap
     */
    static fromSparseByType(n, typeToIndexMap) {
        let paulis = new Uint8Array(n);
        for (let k of Object.keys(typeToIndexMap)) {
            let p = _PAULI_NAMES.indexOf(k);
            if (p === -1) {
                throw new Error(`Unrecognized Pauli: ${k}`);
            }
            let indices = typeToIndexMap[k];
            if (!Array.isArray(indices)) {
                indices = [indices];
            }
            for (let i of indices) {
                if (i < 0 || i >= n) {
                    throw new Error(`Bad index ${i}.`);
                }
                paulis[i] = p;
            }
        }
        return new PauliProduct(0, paulis);
    }

    /**
     * @param {!int} n
     * @param {!boolean} axis False means X, true means Z.
     * @param {!Array.<!int>} qubits
     * @param {!boolean=false} negate
     */
    static fromXzParity(n, axis, qubits, negate=false) {
        let p = axis ? 2 : 1;
        let paulis = new Uint8Array(n);
        for (let q of qubits) {
            paulis[q] ^= p;
        }
        let phase = negate ? 2 : 0;
        return new PauliProduct(phase, paulis);
    }

    /**
     * @param {!string} text
     * @returns {!PauliProduct}
     */
    static fromString(text) {
        let phase = 0;
        if (text[0] === '+') {
            text = text.slice(1);
        }
        if (text[0] === '-') {
            text = text.slice(1);
            phase += 2;
        }
        if (text[0] === 'i') {
            text = text.slice(1);
            phase += 1;
        }
        let paulis = new Uint8Array(text.length);
        for (let i = 0; i < text.length; i++) {
            let k = _PAULI_NAMES.indexOf(text[i]);
            if (k === -1) {
                throw new Error(`Bad character: ${text[i]}`);
            }
            paulis[i] = k;
        }
        return new PauliProduct(phase, paulis);
    }

    /**
     * @param {!int} start
     * @param {!int|undefined=undefined} stop
     * @returns {!PauliProduct}
     */
    slice(start, stop=undefined) {
        return new PauliProduct(this.phase_exponent, this.paulis.slice(start, stop));
    }

    /**
     * @returns {!int}
     */
    xzBitWeight() {
        let t = 0;
        for (let i = 0; i < this.paulis.length; i++) {
            if ((this.paulis[i] & 1) !== 0) {
                t++;
            }
            if ((this.paulis[i] & 2) !== 0) {
                t++;
            }
        }
        return t;
    }

    /**
     * @returns {!QubitAxis}
     */
    xzSingleton() {
        if (this.xzBitWeight() !== 1) {
            throw new Error('Not a singleton.');
        }
        return this.firstActiveQubitAxis();
    }

    /**
     * @param {!PauliProduct|!Complex|!int} other
     */
    inline_times(other) {
        if (other instanceof PauliProduct) {
            for (let i = 0; i < other.paulis.length; i++) {
                let p = other.paulis[i];
                this.phase_exponent += _pauli_product_phase(this.paulis[i], p);
                this.paulis[i] ^= p;
            }
            this.phase_exponent += other.phase_exponent;
        } else if (other instanceof QubitAxis) {
            let i = other.qubit;
            let p = other.axis ? 2 : 1;
            this.phase_exponent += _pauli_product_phase(this.paulis[i], p);
            this.paulis[i] ^= p;
        } else {
            let c = Complex.from(other);
            let p;
            if (c.isEqualTo(1)) {
                p = 0;
            } else if (c.isEqualTo(-1)) {
                p = 2;
            } else if (c.isEqualTo(Complex.I)) {
                p = 1;
            } else if (c.isEqualTo(Complex.I.neg())) {
                p = 3;
            } else {
                throw new Error(`Multiplied PauliProduct by unsupported value ${other}.`);
            }
            this.phase_exponent += p;
        }
        this.phase_exponent &= 3;
        return this;
    }

    /**
     * @param {!PauliProduct|!Complex|!int} other
     */
    times(other) {
        let n = this.paulis.length;
        if (other instanceof PauliProduct) {
            n = Math.max(n, other.paulis.length);
        } else if (other instanceof QubitAxis) {
            n = Math.max(n, other.qubit + 1);
        }
        let copy = new PauliProduct(this.phase_exponent, new Uint8Array(n));
        for (let i = 0; i < this.paulis.length; i++) {
            copy.paulis[i] = this.paulis[i];
        }
        copy.inline_times(other);
        return copy;
    }

    /**
     * @returns {!PauliProduct}
     */
    abs() {
        return new PauliProduct(0, new Uint8Array(this.paulis));
    }

    /**
     * @param {!PauliProduct} other
     */
    bitwiseAnd(other) {
        let n = Math.min(this.paulis.length, other.paulis.length);
        let paulis = new Uint8Array(n);
        let phase = this.phase_exponent & other.phase_exponent;
        for (let i = 0; i < n; i++) {
            paulis[i] = this.paulis[i] & other.paulis[i];
        }
        return new PauliProduct(phase, paulis);
    }

    /**
     * @returns {!Array.<!QubitAxis>}
     */
    activeQubitAxes() {
        let result = [];
        for (let i = 0; i < this.paulis.length; i++) {
            if ((this.paulis[i] & 1) !== 0) {
                result.push(new QubitAxis(i, false));
            }
            if ((this.paulis[i] & 2) !== 0) {
                result.push(new QubitAxis(i, true));
            }
        }
        return result;
    }

    /**
     * @param {object|!PauliProduct} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (!(other instanceof PauliProduct)) {
            return false;
        }
        if (other.phase_exponent !== this.phase_exponent) {
            return false;
        }
        if (other.paulis.length !== this.paulis.length) {
            return false;
        }
        for (let k = 0; k < this.paulis.length; k++) {
            if (other.paulis[k] !== this.paulis[k]) {
                return false;
            }
        }
        return true;
    }

    /**
     * @returns {!string}
     */
    toString() {
        let sign = ['+', '+i', '-', '-i'][this.phase_exponent];
        let paulis = [...this.paulis].map(e => _PAULI_NAMES[e]).join('');
        return sign + paulis;
    }

    /**
     * @returns {!QubitAxis|undefined}
     */
    firstActiveQubitAxis() {
        for (let i = 0; i < this.paulis.length; i++) {
            if (this.paulis[i] !== 0) {
                return new QubitAxis(i, (this.paulis[i] & 2) !== 0);
            }
        }
        return undefined;
    }

    /**
     * @param {!PauliProduct} other
     * @returns {!boolean}
     */
    commutesWith(other) {
        let n = Math.min(this.paulis.length, other.paulis.length);
        let t = 0;
        for (let k = 0; k < n; k++) {
            if (_pauli_product_phase(this.paulis[k], other.paulis[k]) !== 0) {
                t++;
            }
        }
        return (t & 1) === 0;
    }

    /**
     * @param {!int} index
     * @param {!boolean} xz
     * @returns {!boolean}
     */
    _hasPauliXZ(index, xz) {
        let p = this.paulis[index];
        p >>= xz ? 1 : 0;
        return (p & 1) !== 0;
    }

    /**
     * @param {!Array.<!PauliProduct>} table
     * @returns {!Array.<!PauliProduct>}
     */
    static gaussianEliminate(table) {
        table = [...table];
        if (table.length === 0) {
            return table;
        }

        let h = table.length;
        let w = table[0].paulis.length;
        let next_row = 0;

        for (let col = 0; col < w; col++) {
            for (let xz of [false, true]) {
                // Locate pivot.
                let row = undefined;
                for (let k = next_row; k < h; k++) {
                    if (table[k]._hasPauliXZ(col, xz)) {
                        row = k;
                        break;
                    }
                }
                if (row === undefined) {
                    continue;
                }

                // Eliminate column entry in other rows.
                for (let row2 = 0; row2 < h; row2++) {
                    if (row !== row2 && table[row2]._hasPauliXZ(col, xz)) {
                        table[row2] = table[row2].times(table[row]);
                    }
                }

                // Keep it sorted.
                if (row !== next_row) {
                    [table[next_row], table[row]] = [table[row], table[next_row]];
                }
                next_row += 1;
            }
        }
        return table;
    }
}

/**
 * Determines the power of i in the product of two Paulis.
 *
 * For example, X*Y = iZ and so this method would return +1 for X and Y.
 *
 * The input Paulis are encoded into the following form:
 *
 * x z | Pauli
 * ----+-------
 * 0 0 | 0 I
 * 1 0 | 1 X
 * 1 1 | 3 Y
 * 0 1 | 2 Z
 *
 * @param {!int} p1
 * @param {!int} p2
 * @private
 */
function _pauli_product_phase(p1, p2) {
    // Analyze by case over first gate.
    let x1 = p1 & 1;
    let z1 = p1 >> 1;
    let x2 = p2 & 1;
    let z2 = p2  >> 1;

    if (x1 && z1) { // Y gate.
        // No phase for YI = Y
        // -1 phase for YX = -iZ
        // No phase for YY = I
        // +1 phase for YZ = +iX
        return z2 - x2;
    }

    if (x1) { // X gate.
        // No phase for XI = X
        // No phase for XX = I
        // +1 phase for XY = iZ
        // -1 phase for XZ = -iY
        return z2 && (2 * x2 - 1);
    }

    if (z1) { // Z gate.
        // No phase for ZI = Z
        // +1 phase for ZX = -iY
        // -1 phase for ZY = iX
        // No phase for ZZ = I
        return x2 && (1 - 2 * z2);
    }

    // Identity gate.
    return 0;
}

_gen_package_export("src/sim/PauliProduct.js", {QubitAxis, PauliProduct, _pauli_product_phase});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/QuantumProgram.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {GeneralSet} = _gen_package_get("src/base/GeneralSet.js");;
const {seq, Seq} = _gen_package_get("src/base/Seq.js");;
const {SimulatorSpec} = _gen_package_get("src/sim/SimulatorSpec.js");
const {equate} = _gen_package_get("src/base/Equate.js");
const {QubitAxis} = _gen_package_get("src/sim/PauliProduct.js");
const {PauliProduct} = _gen_package_get("src/sim/PauliProduct.js");;


/**
 * A quantum effect which can be simulated, translated into QASM, and translated into Quirk.
 */
class QuantumStatement {
    /**
     * @returns {!string}
     */
    qasm() {
        let out = [];
        this.writeQasm(out);
        return out.join('\n');
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `QuantumStatement(${this.constructor.name}) {\n    ${this.qasm().split('\n').join('\n    ')}\n}`;
    }

    /**
     * @returns {!string}
     */
    quirkUrl() {
        let init = [];
        let cols = [];
        this.writeQuirk(init, cols);
        let circuit = {cols};
        if (init.length > 0) {
            circuit.init = init;
        }
        return `https://algassert.com/quirk#circuit=${JSON.stringify(circuit)}`;
    }

    /**
     * @param {!Array.<!string>} statements The output array of statements to mutate.
     */
    writeQasm(statements) { }

    /**
     * @param {!Array.<undefined|!int|!string>} init The initial states array to mutate.
     * @param {!Array.<!Array.<!int|!string>>} cols The output columns array to mutate.
     */
    writeQuirk(init, cols) { }

    /**
     * @param {!SimulatorSpec} sim
     * @param {!{
     *     measurements: !Array.<[!int, !boolean]>,
     *     successProbability: !number,
     * }} out
     */
    interpret(sim, out) { }
}

class QuantumProgram extends QuantumStatement {
    /**
     * @param {!Array.<!QuantumStatement>} statements
     */
    constructor(statements = []) {
        super();
        this.statements = statements;
    }

    /**
     * @returns {!string}
     */
    toString() {
        let body = this.statements.map((e, i) => `// ${i+1}\n${e}\n`).join('\n');
        return `QuantumStatement(QuantumProgram) {\n    ${body.split('\n').join('\n    ')}\n}`;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof QuantumProgram && equate(this.statements, other.statements);
    }

    writeQuirk(init, cols) {
        for (let statement of this.statements) {
            statement.writeQuirk(init, cols);
        }
    }

    writeQasm(out) {
        for (let statement of this.statements) {
            statement.writeQasm(out);
        }
    }

    interpret(sim, out) {
        for (let statement of this.statements) {
            statement.interpret(sim, out);
        }
    }
}

class InitEprPairs extends QuantumStatement {
    /**
     * @param {[!int, !int]} qubitPairs
     */
    constructor(...qubitPairs) {
        super();
        this.qubitPairs = qubitPairs;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof InitEprPairs && equate(this.qubitPairs, other.qubitPairs);
    }

    writeQasm(statements) {
        for (let [q] of this.qubitPairs) {
            statements.push(`h q[${q}];`);
        }
        for (let [q1, q2] of this.qubitPairs) {
            statements.push(`cx q[${q1}], q[${q2}];`);
        }
    }

    writeQuirk(init, cols) {
        for (let [q] of this.qubitPairs) {
            while (init.length <= q) {
                init.push(0);
            }
            init[q] = '+';
        }

        for (let [q1, q2] of this.qubitPairs) {
            let col = [];
            padSetTo(col, 1, q1, '•');
            padSetTo(col, 1, q2, 'X');
            cols.push(col);
        }
    }

    interpret(sim, out) {
        for (let [q] of this.qubitPairs) {
            sim.hadamard(q);
        }

        for (let [q1, q2] of this.qubitPairs) {
            sim.cnot(q1, q2);
        }
    }
}

class MultiCnot extends QuantumStatement {
    /**
     * @param {!int} control
     * @param {!Array.<!int>} targets
     * @param {!boolean} controlAxis
     * @param {!boolean} targetAxis
     */
    constructor(control, targets, controlAxis, targetAxis) {
        super();
        this.control = control;
        this.targets = targets;
        this.controlAxis = controlAxis;
        this.targetAxis = targetAxis;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof MultiCnot &&
            this.control === other.control &&
            this.controlAxis === other.controlAxis &&
            this.targetAxis === other.targetAxis &&
            equate(this.targets, other.targets));
    }

    writeQasm(statements) {
        for (let target of this.targets) {
            if (this.controlAxis && this.targetAxis) {
                statements.push(`cz q[${this.control}], q[${target}];`);
            } else if (this.controlAxis && !this.targetAxis) {
                statements.push(`cx q[${this.control}], q[${target}];`);
            } else if (!this.controlAxis && this.targetAxis) {
                statements.push(`cx q[${target}], q[${this.control}];`);
            } else {
                statements.push(`h q[${this.control}];`);
                statements.push(`cx q[${this.control}], q[${target}];`);
                statements.push(`h q[${this.control}];`);
            }
        }
    }

    writeQuirk(init, cols) {
        if (this.targets.length === 0) {
            return;
        }

        let controlType = this.controlAxis ? '•' : '⊖';
        let targetType = this.targetAxis ? 'Z' : 'X';

        let col = [];
        padSetTo(col, 1, this.control, controlType);
        for (let target of this.targets) {
            padSetTo(col, 1, target, targetType);
        }
        cols.push(col);
    }

    interpret(sim, out) {
        for (let target of this.targets) {
            if (this.controlAxis && this.targetAxis) {
                sim.hadamard(target);
                sim.cnot(this.control, target);
                sim.hadamard(target);
            } else if (this.controlAxis && !this.targetAxis) {
                sim.cnot(this.control, target);
            } else if (!this.controlAxis && this.targetAxis) {
                sim.cnot(target, this.control);
            } else {
                sim.hadamard(this.control);
                sim.cnot(this.control, target);
                sim.hadamard(this.control);
            }
        }
    }
}

class HeaderAlloc extends QuantumStatement {
    /**
     * @param {!PortQubitMapping} portQubitMapping
     */
    constructor(portQubitMapping) {
        super();
        this.portQubitMapping = portQubitMapping;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof HeaderAlloc &&
            this.portQubitMapping.isEqualTo(other.portQubitMapping));
    }

    writeQasm(statements) {
        statements.push(
            'OPENQASM 2.0;',
            'include "qelib1.inc";',
            `qreg q[${this.portQubitMapping.numQubits}];`,
            ...Seq.range(this.portQubitMapping.numInternal).map(i => `creg m_${i}[1];`),
            ...(this.portQubitMapping.numPost === 0 ? [] : [`creg post[${this.portQubitMapping.numPost}]`]),
        );
    }

    writeQuirk(init, cols) {
    }

    interpret(sim, out) {
        for (let i = 0; i < this.portQubitMapping.numQubits; i++) {
            sim.qalloc();
        }
    }
}

class PostSelection extends QuantumStatement {
    /**
     * @param {!GeneralMap.<!int, !string>} qubitStabilizerMap
     */
    constructor(qubitStabilizerMap) {
        super();
        this.qubitStabilizerMap = qubitStabilizerMap;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof PostSelection &&
            equate(this.qubitStabilizerMap, other.qubitStabilizerMap));
    }

    writeQasm(statements) {
        statements.push('');
        statements.push('// Post-selected measurements that must return 0.');
        let i = 0;
        for (let [qubit, stabilizer] of this.qubitStabilizerMap.entries()) {
            if (stabilizer === '+X') {
                statements.push(`h q[${qubit}];`);
            } else if (stabilizer === '-X') {
                statements.push(
                    `z q[${qubit}];`,
                    `h q[${qubit}];`);
            } else if (stabilizer === '+Y') {
                statements.push(
                    `z q[${qubit}];`,
                    `s q[${qubit}];`,
                    `h q[${qubit}];`);
            } else if (stabilizer === '-Y') {
                statements.push(
                    `s q[${qubit}];`,
                    `h q[${qubit}];`);
            } else if (stabilizer === '-Z') {
                statements.push(`x q[${qubit}];`);
            } else if (stabilizer !== '+Z') {
                throw new Error(`Unrecognized post-selection stabilizer: ${stabilizer}`);
            }
            statements.push(`measure q[${qubit}] -> post[${i}];`);
            i += 1;
        }
    }

    writeQuirk(init, cols) {
        let col = [];
        let map = {
            '+Z': '|0⟩⟨0|',
            '-Z': '|1⟩⟨1|',
            '+X': '|+⟩⟨+|',
            '-X': '|-⟩⟨-|',
            '+Y': '|X⟩⟨X|',
            '-Y': '|/⟩⟨/|',
        };
        for (let [qubit, stabilizer] of this.qubitStabilizerMap.entries()) {
            let gate = map[stabilizer];
            if (gate === undefined) {
                throw new Error(`Unrecognized post-selection stabilizer: ${stabilizer}`);
            }
            padSetTo(col, 1, qubit, gate);
        }
        cols.push(col);
    }

    interpret(sim, out) {
        for (let [qubit, stabilizer] of this.qubitStabilizerMap.entries()) {
            if (stabilizer === '+X') {
                sim.hadamard(qubit);
            } else if (stabilizer === '-X') {
                sim.phase(qubit);
                sim.phase(qubit);
                sim.hadamard(qubit);
            } else if (stabilizer === '+Y') {
                sim.phase(qubit);
                sim.phase(qubit);
                sim.phase(qubit);
                sim.hadamard(qubit);
            } else if (stabilizer === '-Y') {
                sim.phase(qubit);
                sim.hadamard(qubit);
            } else if (stabilizer === '-Z') {
                sim.hadamard(qubit);
                sim.phase(qubit);
                sim.phase(qubit);
                sim.hadamard(qubit);
            } else if (stabilizer !== '+Z') {
                throw new Error(`Unrecognized post-selection stabilizer: ${stabilizer}`);
            }

            let measurement = sim.measure(qubit, 0.0);
            out.measurements.push([qubit, measurement.result]);
            if (measurement.random) {
                out.successProbability *= 0.5;
            }
            if (measurement.result) {
                out.successProbability = 0;
            }
        }
    }
}

class Comment extends QuantumStatement {
    /**
     * @param {!string} lines
     */
    constructor(...lines) {
        super();
        this.lines = lines;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof Comment && equate(this.lines, other.lines);
    }

    writeQasm(statements) {
        statements.push(...this.lines.map(line => line === '' ? '' : `// ${line}`));
    }

    writeQuirk(inits, cols) {
    }

    interpret(sim, out) {
    }
}

class MeasurementsWithPauliFeedback extends QuantumStatement {
    /**
     * @param {!GeneralMap.<!int, !Array.<!QubitAxis>>} measurementToEffectMap
     */
    constructor(measurementToEffectMap) {
        super();
        this.measurementToEffectMap = measurementToEffectMap;
        this._effectToControlsMap = /** @type {!GeneralMap.<!QubitAxis, !Array.<!int>>} */ inverseMultiMap(
            this.measurementToEffectMap);
        this._orderedEffects = [...this._effectToControlsMap.keys()];
        this._orderedEffects.sort((a, b) => a.orderVal() - b.orderVal());
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof MeasurementsWithPauliFeedback &&
            equate(this.measurementToEffectMap, other.measurementToEffectMap));
    }

    writeQasm(statements) {
        for (let q of this.measurementToEffectMap.keys()) {
            statements.push(`measure q[${q}] -> m_${q};`);
        }

        statements.push('');
        statements.push('// Adjust Pauli frame based on measurements.');
        let qubits = [...this.measurementToEffectMap.keys()];
        qubits.sort((a, b) => a - b);
        for (let qubit of qubits) {
            let effects = this.measurementToEffectMap.get(qubit);
            for (let effect of effects) {
                let op = `${effect.axis ? 'z' : 'x'} q[${effect.qubit}]`;
                statements.push(`if (m_${qubit} == 1) ${op};`);
            }
        }

        // BLOCKED TODO: use this cleaner output when QASM supports more general conditions.
        // for (let effect of this._orderedEffects) {
        //     let controls = this._effectToControlsMap.get(effect);
        //     let condition = controls.map(e => `m[${e}]`).join(' ^ ');
        //     let op = `${effect.axis ? 'z' : 'x'} q[${effect.qubit}]`;
        //     statements.push(`if (${condition}) {\n    ${op};\n}`);
        // }
    }

    writeQuirk(inits, cols) {
        let measureCol = [];
        for (let qubit of this.measurementToEffectMap.keys()) {
            padSetTo(measureCol, 1, qubit, 'Measure');
        }
        cols.push(measureCol);

        for (let effect of this._orderedEffects) {
            let controls = this._effectToControlsMap.get(effect);
            if (controls.length === 0) {
                continue;
            }
            let col = [];
            padSetTo(col, 1, effect.qubit, effect.axis ? '•' : '⊖');
            for (let control of controls) {
                padSetTo(col, 1, control, 'Z');
            }
            cols.push(col);
        }
    }

    interpret(sim, out) {
        let allEffects = new GeneralSet();

        let qubits = [...this.measurementToEffectMap.keys()];
        qubits.sort((a, b) => a - b);
        for (let qubit of qubits) {
            let effects = this.measurementToEffectMap.get(qubit);
            let measurement = sim.measure(qubit);

            out.measurements.push([qubit, measurement.result]);

            if (measurement.result) {
                for (let effect of effects) {
                    if (allEffects.has(effect)) {
                        allEffects.delete(effect);
                    } else {
                        allEffects.add(effect);
                    }
                }
            }
        }

        for (let effect of allEffects) {
            if (effect.axis) {
                sim.z(effect.qubit);
            } else {
                sim.x(effect.qubit);
            }
        }
    }
}

class AmpsDisplay extends QuantumStatement {
    /**
     * @param {!int} offset
     * @param {!int} len
     */
    constructor(offset, len) {
        super();
        this.offset = offset;
        this.len = len;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof AmpsDisplay && this.offset === other.offset && this.len === other.len;
    }

    writeQasm(statements) {
    }

    writeQuirk(inits, cols) {
        if (this.len > 0) {
            let col = [];
            padSetTo(col, 1, this.offset, `Amps${this.len}`);
            cols.push(col);
        }
    }

    interpret(sim, measurementsOut) {
    }
}

/**
 * @param {!GeneralMap.<TKey, !Array.<TVal>>} multiMap
 * @returns {!GeneralMap.<TVal, !Array.<TKey>>}
 * @template TKey, TVal
 */
function inverseMultiMap(multiMap) {
    let result = new GeneralMap();
    for (let [key, vals] of multiMap.entries()) {
        for (let val of vals) {
            if (!result.has(val)) {
                result.set(val, []);
            }
            result.get(val).push(key);
        }
    }
    return result;
}

/**
 * @param {!Array.<![!int, T]>} indexedItems
 * @param {T=undefined} defaultValue
 * @returns {!Array.<T>}
 * @template T
 */
function scatter(indexedItems, defaultValue=undefined) {
    let result = [];
    for (let [index, item] of indexedItems) {
        while (result.length <= index) {
            result.push(defaultValue);
        }
        result[index] = item;
    }
    return result;
}

/**
 * @param {!Array.<T>} items
 * @param {!int} index
 * @param {T} defaultValue
 * @param {T} item
 * @template T
 */
function padSetTo(items, defaultValue, index, item) {
    while (items.length <= index) {
        items.push(defaultValue);
    }
    items[index] = item;
}

_gen_package_export("src/sim/QuantumProgram.js", {
    QuantumStatement,
    QuantumProgram,
    InitEprPairs,
    MeasurementsWithPauliFeedback,
    Comment,
    HeaderAlloc,
    inverseMultiMap,
    scatter,
    padSetTo,
    MultiCnot,
    AmpsDisplay,
    PostSelection,
});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/SimulatorSpec.js", function() {

const {Measurement} = _gen_package_get("src/sim/Measurement.js");

class SimulatorSpec {
    /**
     * Adds a new qubit to the system and returns a handle used to refer to it.
     * @returns {!int}
     */
    qalloc() {
        throw new Error(`qalloc() not implemented in ${this}`);
    }

    /**
     * Removes a qubit from the system. Decoheres the qubit.
     * @param {!int} q The qubit handle.
     */
    free(q) {
        throw new Error(`free(${q}) not implemented in ${this}`);
    }

    /**
     * Applies an S gate to a qubit.
     * @param {!int} q The handle of the qubit to operate on.
     */
    phase(q) {
        throw new Error(`phase(${q}) not implemented in ${this}`);
    }

    /**
     * Applies a Z gate to a qubit.
     * @param {!int} q The handle of the qubit to operate on.
     */
    z(q) {
        this.phase(q);
        this.phase(q);
    }

    /**
     * Applies a NOT gate to a qubit.
     * @param {!int} q The handle of the qubit to operate on.
     */
    x(q) {
        this.hadamard(q);
        this.phase(q);
        this.phase(q);
        this.hadamard(q);
    }

    /**
     * Applies a Hadamard gate to a qubit.
     * @param {!int} q The handle of the qubit to operate on.
     */
    hadamard(q) {
        throw new Error(`hadamard(${q}) not implemented in ${this}`);
    }

    /**
     * Applies a controlled not gate to a pair of qubits.
     * @param {!int} control The handle of the operation's control qubit.
     * @param {!int} target The handle of the operation's target qubit.
     */
    cnot(control, target) {
        throw new Error(`cnot(${control}, ${target}) not implemented in ${this}`);
    }

    /**
     * Measures a qubit.
     * @param {!int} q The handle of the qubit to measure.
     * @param {!number|undefined=} bias When a measurement result is non-deterministic, this determines the probability of True.
     * @returns {!Measurement} The measurement result.
     */
    measure(q, bias=undefined) {
        let p = this.probability(q);
        if (p === 0 || p === 1) {
            return new Measurement(p === 1, false);
        }
        if (Math.abs(p - 0.5) < 0.001 && bias !== undefined) {
            p = bias;
        }
        let outcome = Math.random() < p;
        this.collapse(q, outcome);
        return new Measurement(outcome, true);
    }

    /**
     * Determines the probability of a qubit measurement returning ON, if it was performed.
     * @param {!int} q The handle of the qubit to inspect.
     * @returns {!number} The probability.
     */
    probability(q) {
        throw new Error(`probability(${q}) not implemented in ${this}`);
    }

    /**
     * Determines the probability of a qubit X-basis measurement returning |0>-|1>, if it was performed.
     * @param {!int} q The handle of the qubit to inspect.
     * @returns {!number} The probability.
     */
    probability_x(q) {
        this.hadamard(q);
        let r = this.probability(q);
        this.hadamard(q);
        return r;
    }

    /**
     * Determines the probability of a qubit Y-basis measurement returning |0>-i|1>, if it was performed.
     * @param {!int} q The handle of the qubit to inspect.
     * @returns {!number} The probability.
     */
    probability_y(q) {
        this.phase(q);
        this.phase(q);
        this.phase(q);
        this.hadamard(q);
        let r = this.probability(q);
        this.hadamard(q);
        this.phase(q);
        return r;
    }

    /**
     * Determines the mixed state of a qubit as a vector on the Bloch sphere.
     * @param {!int} q The handle of the qubit to inspect.
     * @returns {!{x: !number, y: !number, z: !number}} The x, y, and z components of the vector.
     */
    blochVector(q) {
        let z = this.probability(q);
        let y = this.probability_y(q);
        let x = this.probability_x(q);
        x = 1 - x * 2;
        y = 1 - y * 2;
        z = 1 - z * 2;
        return {x, y, z};
    }

    /**
     * Measures a qubit while forcing the result.
     * @param {!int} q The handle of the qubit to collapse.
     * @param {!boolean} outcome The outcome to force the qubit into.
     */
    collapse(q, outcome) {
        throw new Error(`collapse(${q}, ${outcome}) not implemented in ${this}`);
    }

    /**
     * Swaps the values of two qubits. It is permitted for both arguments to be the same, in which case nothing happens.
     * @param {!int} a The handle of one of the qubits.
     * @param {!int} b The handle of one of the qubits.
     */
    swap(a, b) {
        if (a === b) {
            return;
        }
        this.cnot(a, b);
        this.cnot(b, a);
        this.cnot(a, b);
    }

    /**
     * Free's any manually-managed resources used by the instance.
     */
    destruct() {
    }
}

_gen_package_export("src/sim/SimulatorSpec.js", {SimulatorSpec});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/StabilizerToWave.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {seq, Seq} = _gen_package_get("src/base/Seq.js");;
const {SimulatorSpec} = _gen_package_get("src/sim/SimulatorSpec.js");
const {ChpSimulator} = _gen_package_get("src/sim/ChpSimulator.js");
const {VectorSimulator} = _gen_package_get("src/sim/VectorSimulator.js");
const {Measurement} = _gen_package_get("src/sim/Measurement.js");
const {Complex} = _gen_package_get("src/base/Complex.js");
const {Matrix} = _gen_package_get("src/base/Matrix.js");
const {ZxPort, ZxGraph, ZxEdge, ZxNode} = _gen_package_get("src/sim/ZxGraph.js");
const {BitTable} = _gen_package_get("src/sim/BitTable.js");
const {QubitAxis,PauliProduct} = _gen_package_get("src/sim/PauliProduct.js");
const {popcnt} = _gen_package_get("src/base/Util.js");;


/**
 * Returns a wavefunction that satisfies all of the given stabilizers.
 *
 * Assumes that the given stabilizers commute and are consistent.
 *
 * @param {!Array.<!PauliProduct>} stabilizers
 * @returns {!Matrix}
 */
function stabilizerStateToWavefunction(stabilizers) {
    // If we're targeting a unique state, the number of stabilizers should match the number of qubits.
    let num_qubits = stabilizers.length;

    // Start from a random wavefunction so that we almost certainly overlap with the desired stabilizers.
    let sim = new VectorSimulator();
    for (let k = 0; k < num_qubits; k++) {
        sim.qalloc();
    }
    let initialBuf = sim._state.rawBuffer();
    for (let k = 0; k < initialBuf.length; k++) {
        initialBuf[k] = Math.random()*2-1;
    }
    _normalize(initialBuf);

    // Project onto the desired stabilizers.
    for (let stabilizer of stabilizers) {
        if (stabilizer.paulis.length !== num_qubits) {
            throw new Error('stabilizer.paulis.length !== num_qubits');
        }
        _simProjectOntoStabilizer(sim, stabilizer);
    }

    // Canonicalize the global phase.
    let finalBuf = sim._state.rawBuffer();
    _phaseCorrect(finalBuf);

    // Package into a ket.
    return new Matrix(1, finalBuf.length >> 1, finalBuf);
}

/**
 * Applies simulated operations that remove components of the wavefunction that are inconsistent with a stabilizer.
 * @param {!VectorSimulator} sim
 * @param {!PauliProduct} stabilizer
 * @private
 */
function _simProjectOntoStabilizer(sim, stabilizer) {
    if ((stabilizer.phase_exponent & 1) !== 0) {
        throw new Error('imaginary stabilizer');
    }

    // Temporarily adjust simulation basis so that the stabilizer is effectively a product of Zs.
    for (let i = 0; i < stabilizer.paulis.length; i++) {
        let p = stabilizer.paulis[i];
        if (p === 1) {
            sim.hadamard(i);
        } else if (p === 3) {
            sim.phase(i);
            sim.phase(i);
            sim.phase(i);
            sim.hadamard(i);
        }
    }

    // Determine involved qubits.
    let mask = 0;
    for (let i = 0; i < stabilizer.paulis.length; i++) {
        let p = stabilizer.paulis[i];
        if (p !== 0) {
            mask |= 1 << i;
        }
    }

    // Discard parts of the wavefunction with the wrong parity.
    let buf = sim._state.rawBuffer();
    let correctParity = stabilizer.phase_exponent >> 1;
    for (let k = 0; k < buf.length; k++) {
        if ((popcnt((k >> 1) & mask) & 1) !== correctParity) {
            buf[k] = 0;
        }
    }
    _normalize(buf);

    // Restore simulation basis.
    for (let i = 0; i < stabilizer.paulis.length; i++) {
        let c = stabilizer.paulis[i];
        if (c === 1) {
            sim.hadamard(i);
        } else if (c === 3) {
            sim.hadamard(i);
            sim.phase(i);
        }
    }
}

/**
 * Mutates a Float64Array backing a Matrix so that its 2-norm is equal to 1.
 * @param {!Float64Array} buf
 * @private
 */
function _normalize(buf) {
    let t = 0;
    for (let k = 0; k < buf.length; k++) {
        t += buf[k]*buf[k];
    }
    t = Math.sqrt(t);
    for (let k = 0; k < buf.length; k++) {
        buf[k] /= t;
    }
}

/**
 * Mutates a Float64Array backing a Matrix so that its largest encoded complex value is non-negative and real.
 * @param {!Float64Array} buf
 * @private
 */
function _phaseCorrect(buf) {
    let best = 0;
    let phase = Complex.ONE;
    for (let k = 0; k < buf.length; k += 2) {
        let r = buf[k];
        let i = buf[k+1];
        let d = r*r + i*i;
        if (d > best) {
            best = d;
            phase = new Complex(r, i).unit().conjugate();
        }
    }

    for (let k = 0; k < buf.length; k += 2) {
        let c = new Complex(buf[k], buf[k+1]).times(phase);
        buf[k] = c.real;
        buf[k+1] = c.imag;
    }
}

_gen_package_export("src/sim/StabilizerToWave.js", {stabilizerStateToWavefunction});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/VectorSimulator.js", function() {

const {DetailedError} = _gen_package_get("src/base/DetailedError.js");
const {Format, UNICODE_FRACTIONS} = _gen_package_get("src/base/Format.js");
const {Util} = _gen_package_get("src/base/Util.js");
const {Matrix} = _gen_package_get("src/base/Matrix.js");
const {Complex} = _gen_package_get("src/base/Complex.js");
const {Controls} = _gen_package_get("src/sim/Controls.js");;
const {SimulatorSpec} = _gen_package_get("src/sim/SimulatorSpec.js");;

class VectorSimulator extends SimulatorSpec {
    constructor() {
        super();
        this._state = Matrix.solo(1);
        this._nextQubitId = 0;
        this._qubitToSlotMap = new Map();
        this._qubitSlots = [];
    }

    qalloc() {
        let src = this._state.rawBuffer();
        let n = src.length;
        let state = new Float64Array(n << 1);
        for (let i = 0; i < n; i++) {
            state[i] = src[i];
        }
        let id = this._nextQubitId;
        this._nextQubitId += 1;
        this._qubitToSlotMap.set(id, this._qubitSlots.length);
        this._qubitSlots.push(id);
        this._state = new Matrix(1, n, state);
        return id;
    }

    free(q) {
        // Decohere the qubit.
        if (this.measure(q).result) {
            this.x(q);
        }

        // Move qubit to deallocate to the end of the list, then pop it off.
        let k = this._slotFor(q);
        let q2 = this._qubitSlots[this._qubitSlots.length - 1];
        this.swap(q, q2);
        this._qubitToSlotMap.set(q2, k);
        this._qubitSlots[k] = q2;
        this._qubitSlots.pop();
        this._qubitToSlotMap.delete(q);

        // Drop empty final half of state vector.
        let raw = this._state.rawBuffer();
        let n = raw.length >> 1;
        let state = new Float64Array(n);
        for (let i = 0; i < n; i++) {
            state[i] = raw[i];
        }
        this._state = new Matrix(1, n >> 1, state);
    }

    /**
     * @param {!Matrix} mat
     * @param {!int} target
     * @param {undefined|!int} control
     */
    op(mat, target, control=undefined) {
        let k = this._slotFor(target);
        let kc = control === undefined ? undefined : this._slotFor(control);
        if (k === kc) {
            throw new DetailedError('target and control are the same.', {target, control})
        }
        let controls = kc === undefined ? Controls.NONE : Controls.bit(kc, true);
        this._state = mat.applyToStateVectorAtQubitWithControls(this._state, k, controls);
    }

    phase(q) {
        this.op(Matrix.square(1, 0, 0, Complex.I), q)
    }

    hadamard(q) {
        this.op(Matrix.HADAMARD, q)
    }

    x(a) {
        this.op(Matrix.PAULI_X, a)
    }

    /**
     * @param {!int} q
     * @returns {!int}
     * @private
     */
    _slotFor(q) {
        if (!this._qubitToSlotMap.has(q)) {
            throw new Error(`Invalid qubit handle: ${q}`);
        }
        return this._qubitToSlotMap.get(q);
    }

    probability(q) {
        let k = this._slotFor(q);
        let m = 2 << k;
        let raw = this._state.rawBuffer();
        let n = raw.length;
        let t = 0;
        for (let i = 0; i < n; i++) {
            if ((i & m) !== 0) {
                t += raw[i] * raw[i];
            }
        }
        return t;
    }

    collapse(q, outcome) {
        if (outcome) {
            this.x(q);
        }
        let d = Math.sqrt(1 - this.probability(q));
        let k = this._slotFor(q);
        let m = 2 << k;
        let buf = this._state.rawBuffer();
        let n = buf.length;
        for (let i = 0; i < n; i++) {
            if ((i & m) !== 0) {
                buf[i] = 0;
            } else {
                buf[i] /= d;
            }
        }
        if (outcome) {
            this.x(q);
        }
    }

    cnot(control, target) {
        this.op(Matrix.PAULI_X, target, control)
    }

    toString() {
        return `VectorSimulator(${this._qubitSlots.length} qubits)`;
    }
}

_gen_package_export("src/sim/VectorSimulator.js", {VectorSimulator});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/ZxGraph.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {GeneralSet} = _gen_package_get("src/base/GeneralSet.js");;
const {Seq, seq} = _gen_package_get("src/base/Seq.js");;
const {NODES} = _gen_package_get("src/nodes/All.js");;


class ZxNode {
    /**
     * @param {!int} x
     * @param {!int} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }

    /**
     * @returns {!Array.<!ZxEdge>}
     */
    unitEdges() {
        return [
            this.rightUnitEdge(),
            this.upUnitEdge(),
            this.leftUnitEdge(),
            this.downUnitEdge(),
        ];
    }

    /**
     * Returns the result of rotating this node 180 degrees around the given node.
     * @param {!ZxNode} node
     * @returns {!ZxNode}
     */
    reflectedThrough(node) {
        let dx = this.x - node.x;
        let dy = this.y - node.y;
        return node.translate(-dx, -dy);
    }

    /**
     * @param {!int} dx
     * @param {!int} dy
     * @returns {!ZxNode}
     */
    translate(dx, dy) {
        return new ZxNode(this.x + dx, this.y + dy);
    }

    /**
     * @returns {!Array.<!ZxPort>}
     */
    unitPorts() {
        return this.unitEdges().map(e => new ZxPort(e, this));
    }

    /**
     * @returns {!ZxEdge}
     */
    rightUnitEdge() {
        return ZxEdge.makeHorizontalUnit(this.x, this.y);
    }

    /**
     * @returns {!ZxEdge}
     */
    downUnitEdge() {
        return ZxEdge.makeVerticalUnit(this.x, this.y);
    }

    /**
     * @returns {!ZxEdge}
     */
    leftUnitEdge() {
        return ZxEdge.makeHorizontalUnit(this.x - 1, this.y);
    }

    /**
     * @returns {!ZxPort}
     */
    rightPort() {
        return new ZxPort(this.rightUnitEdge(), this);
    }

    /**
     * @returns {!ZxPort}
     */
    leftPort() {
        return new ZxPort(this.leftUnitEdge(), this);
    }

    /**
     * @returns {!ZxPort}
     */
    downPort() {
        return new ZxPort(this.downUnitEdge(), this);
    }

    /**
     * @returns {!ZxPort}
     */
    upPort() {
        return new ZxPort(this.upUnitEdge(), this);
    }

    /**
     * @returns {!ZxEdge}
     */
    upUnitEdge() {
        return ZxEdge.makeVerticalUnit(this.x, this.y - 1);
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `(${this.x},${this.y})`;
    }

    /**
     * @returns {!number}
     */
    orderVal() {
        return this.x + this.y * 1000.1;
    }

    /**
     * @returns {!number}
     */
    orderValXThenY() {
        return this.x * 1000.1 + this.y;
    }

    /**
     * @param {object|!ZxNode} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (!(other instanceof ZxNode)) {
            return false;
        }
        return this.x === other.x && this.y === other.y;
    }
}


class ZxEdge {
    /**
     * @param {!ZxNode} n1
     * @param {!ZxNode} n2
     */
    constructor(n1, n2) {
        if (!(n1 instanceof ZxNode)) {
            throw new Error(`Not a ZxNode: ${n1}`);
        }
        if (!(n2 instanceof ZxNode)) {
            throw new Error(`Not a ZxNode: ${n2}`);
        }
        if (n1.orderVal() > n2.orderVal()) {
            [n1, n2] = [n2, n1];
        }
        this.n1 = n1;
        this.n2 = n2;
    }

    /**
     * Returns the result of rotating this edge 180 degrees around the given node.
     * @param {!ZxNode} node
     * @returns {!ZxEdge}
     */
    reflectedThrough(node) {
        return new ZxEdge(this.n1.reflectedThrough(node), this.n2.reflectedThrough(node));
    }

    /**
     * @param {!int} dx
     * @param {!int} dy
     * @returns {!ZxEdge}
     */
    translate(dx, dy) {
        return new ZxEdge(this.n1.translate(dx, dy), this.n2.translate(dx, dy));
    }

    /**
     * @param {!ZxEdge|!ZxNode} element
     * @returns {undefined|!ZxNode|!ZxEdge}
     */
    intersection(element) {
        if (element instanceof ZxNode) {
            if (this.n1.isEqualTo(element) || this.n2.isEqualTo(element)) {
                return element;
            }
            return undefined;
        }

        if (element instanceof ZxEdge) {
            if (this.isEqualTo(element)) {
                return element;
            }
            return this.intersection(element.n1) || this.intersection(element.n2);
        }

        throw new Error(`Unrecognized graph element: ${element}`);
    }

    /**
     * @param {!int} x
     * @param {!int} y
     * @param {!boolean} horizontal
     * @returns {!ZxEdge}
     */
    static makeUnit(x, y, horizontal) {
        return horizontal ? this.makeHorizontalUnit(x, y) : this.makeVerticalUnit(x, y);
    }

    /**
     * @param {!int} x
     * @param {!int} y
     * @returns {!ZxEdge}
     */
    static makeHorizontalUnit(x, y) {
        return new ZxEdge(new ZxNode(x, y), new ZxNode(x + 1, y));
    }

    /**
     * @param {!int} x
     * @param {!int} y
     * @returns {!ZxEdge}
     */
    static makeVerticalUnit(x, y) {
        return new ZxEdge(new ZxNode(x, y), new ZxNode(x, y + 1));
    }

    /**
     * @returns {!boolean}
     */
    isUnit() {
        let dx = Math.abs(this.n1.x - this.n2.x);
        let dy = Math.abs(this.n1.y - this.n2.y);
        return dx + dy === 1;
    }

    /**
     * @returns {!Array.<!ZxNode>}
     */
    nodes() {
        return [this.n1, this.n2];
    }

    /**
     * @returns {!Array.<!ZxPort>}
     */
    ports() {
        return this.nodes().map(n => new ZxPort(this, n));
    }

    /**
     * @param {!ZxNode} node
     * @returns {!ZxNode}
     */
    opposite(node) {
        let nodes = this.nodes();
        if (node.isEqualTo(nodes[0])) {
            return nodes[1];
        }
        if (node.isEqualTo(nodes[1])) {
            return nodes[0];
        }
        throw new Error(`${node} is not an endpoint of ${this}`);
    }

    /**
     * @returns {!number}
     */
    orderVal() {
        return this.n1.orderVal() * 1000000.2 + this.n2.orderVal();
    }

    /**
     * @returns {!number}
     */
    orderValXThenY() {
        return this.n1.orderValXThenY() * 1000000.2 + this.n2.orderValXThenY();
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `(${this.n1}, ${this.n2})`;
    }

    /**
     * @param {object|!ZxEdge} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (!(other instanceof ZxEdge)) {
            return false;
        }
        return this.n1.isEqualTo(other.n1) && this.n2.isEqualTo(other.n2);
    }
}


/**
 * The location where an edge is entering into a node. An adjacent edge/node combination.
 */
class ZxPort {
    /**
     * @param {!ZxEdge} edge
     * @param {!ZxNode} node
     */
    constructor(edge, node) {
        if (!(edge instanceof ZxEdge)) {
            throw new Error(`Not a ZxNode: ${edge}`);
        }
        if (!(node instanceof ZxNode)) {
            throw new Error(`Not a ZxNode: ${node}`);
        }
        this.edge = edge;
        this.node = node;
    }

    /**
     * @param {!int} dx
     * @param {!int} dy
     * @returns {!ZxPort}
     */
    translate(dx, dy) {
        return new ZxPort(this.edge.translate(dx, dy), this.node.translate(dx, dy));
    }

    /**
     * @returns {!ZxPort}
     */
    opposite() {
        return new ZxPort(this.edge, this.edge.opposite(this.node));
    }

    /**
     * @param {object|!ZxPort} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (!(other instanceof ZxPort)) {
            return false;
        }
        return other.edge.isEqualTo(this.edge) && other.node.isEqualTo(this.node);
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `${this.edge}@${this.node}`;
    }
}


class ZxGraph {
    /**
     * @param {!GeneralMap.<!ZxNode, !string>=} nodes
     * @param {!GeneralMap.<!ZxEdge, !string>=} edges
     */
    constructor(nodes=undefined, edges=undefined) {
        if (nodes === undefined) {
            nodes = new GeneralMap();
        }
        if (edges === undefined) {
            edges = new GeneralMap();
        }
        this.nodes = nodes;
        this.edges = edges;
    }

    /**
     * @param {!ZxNode} node
     */
    isExternalNodeKind(node) {
        let kind = this.kind(node);
        return ['out', 'in', 'O!', '@!'].indexOf(kind) !== -1;
    }

    /**
     * @param {!ZxNode|!ZxEdge} nodeOrEdge
     * @returns {!boolean}
     */
    has(nodeOrEdge) {
        let map = (nodeOrEdge instanceof ZxNode) ? this.nodes : this.edges;
        return map.has(nodeOrEdge);
    }

    /**
     * @param {!ZxNode|!ZxEdge} nodeOrEdge
     * @returns {undefined|!string}
     */
    kind(nodeOrEdge) {
        let map = (nodeOrEdge instanceof ZxNode) ? this.nodes : this.edges;
        return map.get(nodeOrEdge);
    }

    /**
     * @param {!ZxNode|!ZxEdge} nodeOrEdge
     * @returns {undefined|!ZxNodeKind}
     */
    nodeKind(nodeOrEdge) {
        let kind = this.kind(nodeOrEdge);
        if (kind === undefined) {
            return undefined;
        }
        return NODES.map.get(kind);
    }

    /**
     * @param {!ZxNode|!ZxEdge} element
     * @param {!string} kind
     */
    setKind(element, kind) {
        let map = (element instanceof ZxNode) ? this.nodes : this.edges;
        map.set(element, kind);
    }

    /**
     * @returns {!ZxGraph}
     */
    movedToOrigin() {
        let {x, y} = this.boundingBox();
        return this.shifted(-x, -y);
    }

    /**
     * @returns {!string}
     */
    serialize() {
        let nodes = this.sortedNodes();
        let edges = this.sortedEdges();
        let nodeText = nodes.map(n => `${n.x},${n.y},${this.kind(n)}`).join(';');
        let edgeText = edges.map(e => {
            if (!e.isUnit() || e.n1.x > e.n2.x || e.n1.y > e.n2.y) {
                throw new Error(`Non-unit edge: ${e}`);
            }
            return `${e.n1.x},${e.n1.y},${e.n2.x},${e.n2.y},${this.kind(e)}`;
        }).join(';');
        return `${nodeText}:${edgeText}`;
    }

    /**
     * @returns {!ZxGraph}
     */
    copy() {
        return ZxGraph.deserialize(this.serialize());
    }

    /**
     * @param {!string} text
     * @returns {!ZxGraph}
     */
    static deserialize(text) {
        let result = new ZxGraph();

        function parseNode(t) {
            let [x, y, k] = t.split(',');
            let n = new ZxNode(parseInt(x), parseInt(y));
            result.nodes.set(n, k);
        }

        function parseEdge(t) {
            let [x1, y1, x2, y2, k] = t.split(',');
            let e = new ZxEdge(
                new ZxNode(parseInt(x1), parseInt(y1)),
                new ZxNode(parseInt(x2), parseInt(y2)));
            result.edges.set(e, k);
        }

        if (text.length > 0) {
            let [nodeText, edgeText] = text.split(':');
            if (nodeText.length > 0) {
                nodeText.split(';').map(parseNode);
            }
            if (edgeText.length > 0) {
                edgeText.split(';').map(parseEdge);
            }
        }

        return result;
    }

    /**
     * @returns {!Array.<!ZxNode>}
     */
    inputNodes() {
        let result = [];
        for (let node of this.sortedNodes()) {
            let kind = this.nodes.get(node);
            if (kind === 'in') {
                result.push(node);
            }
        }
        return result;
    }

    /**
     * @returns {!Array.<!ZxNode>}
     */
    outputNodes() {
        let result = [];
        for (let node of this.sortedNodes()) {
            let kind = this.nodes.get(node);
            if (kind === 'out') {
                result.push(node);
            }
        }
        return result;
    }

    /**
     * @returns {!Array.<!{node: !ZxNode, axis: !boolean}>}
     */
    postselectionNodesWithAxis() {
        let result = [];
        for (let node of this.sortedNodes()) {
            let kind = this.nodes.get(node);
            if (kind === 'O!' || kind === 'w!' || kind === 'f!' || kind === 'x!') {
                result.push({node, axis: true});
            } else if (kind === '@!' || kind === 's!' || kind === 'a!' || kind === 'z!') {
                result.push({node, axis: false});
            }
        }
        return result;
    }

    /**
     * @returns {!Array.<!{node: !ZxNode, axis: !boolean}>}
     */
    spiderNodesWithAxis() {
        let result = [];
        for (let node of this.sortedNodes()) {
            let kind = this.nodes.get(node);
            if (kind === 'O' || kind === 'w' || kind === 'f' || kind === 'x') {
                result.push({node, axis: true});
            } else if (kind === '@' || kind === 's' || kind === 'a' || kind === 'z') {
                result.push({node, axis: false});
            }
        }
        return result;
    }

    /**
     * @returns {!Array.<!ZxNode>}
     */
    hadamardNodes() {
        let result = [];
        for (let node of this.sortedNodes()) {
            let kind = this.nodes.get(node);
            if (kind === 'h') {
                result.push(node);
            }
        }
        return result;
    }

    /**
     * @returns {!Array.<!ZxNode>}
     */
    crossingNodes() {
        let result = [];
        for (let node of this.sortedNodes()) {
            let kind = this.nodes.get(node);
            if (kind === '+') {
                result.push(node);
            }
        }
        return result;
    }

    /**
     * Ordered top to bottom, then left to right.
     * @returns {!Array.<!ZxNode>}
     */
    sortedNodes() {
        let nodes = [...this.nodes.keys()];
        nodes.sort((a, b) => a.orderVal() - b.orderVal());
        return nodes;
    }

    /**
     * Ordered top to bottom, then left to right.
     * @returns {!Array.<!ZxEdge>}
     */
    sortedEdges() {
        let edges = [...this.edges.keys()];
        edges.sort((a, b) => a.orderVal() - b.orderVal());
        return edges;
    }

    /**
     * Applies trivial rewrites to simplify the ZX graph.
     * @returns {!ZxGraph} this
     */
    inlineSimplify() {
        for (let {node} of this.spiderNodesWithAxis()) {
            let edges = this.activeEdgesOf(node);
            if (edges.length === 2) {
                let [e1, e2] = edges;
                if (this.kind(e1) === '-' && this.kind(e2) === '-') {
                    let n1 = e1.opposite(node);
                    let n2 = e2.opposite(node);
                    this.edges.delete(e1);
                    this.edges.delete(e2);
                    this.nodes.delete(node);
                    this.edges.set(new ZxEdge(n1, n2), '-');
                }
            }
        }
        return this;
    }

    /**
     * @param {!string} text
     * @returns {!ZxGraph}
     */
    static fromDiagram(text) {
        let lines = text.split('\n');

        // Drop blank leading and trailing lines.
        while (lines.length > 0 && lines[0].trim() === '') {
            lines.shift();
        }
        while (lines.length > 0 && lines[lines.length - 1].trim() === '') {
            lines.pop();
        }

        // Drop indentation and trailing spaces.
        let indent = Math.min(...lines.filter(e => e.trim() !== '').map(e => rtrim(e).length - e.trim().length));
        lines = lines.map(e => rtrim(e.substr(indent)));
        if (lines.length === 0) {
            return new ZxGraph();
        }

        // Consistency checks.
        if (lines.length % 4 !== 1) {
            throw new Error(
                `Misaligned diagram. Number of non-empty lines must equal 1 mod 4, but is ${lines.length}.`);
        }
        for (let line of lines) {
            if (line !== '' && line.length % 4 !== 1 && line.length % 4 !== 2) {
                throw new Error(`Misaligned diagram. Length must equal 1 or 2 mod 4: "${line}".`);
            }
        }
        for (let row = 0; row < lines.length; row++) {
            let line = lines[row];
            for (let col = 0; col < line.length; col++) {
                if (line[col] !== ' ' && row % 4 !== 0 && col % 4 !== 0) {
                    throw new Error(`Misaligned diagram. Content outside row|col=0%4 at row=${row} col=${col}.`);
                }
                if (line[col] !== '|' && line[col] !== ' ' && row % 2 === 1) {
                    throw new Error(`Must use pipe for v edge at row=${row} col=${col}.`);
                }
                if (line[col] !== '-' && line[col] !== ' ' && col % 2 === 1) {
                    if (row % 4 !== 0 && col % 4 !== 1) {  // Allow modifier characters.
                        throw new Error(`Must use dash for h edge at row=${row} col=${col}.`);
                    }
                }
            }
        }

        /**
         * @param {!ZxEdge} edge
         * @param {!boolean} shouldBePresent
         * @param {!string} desc
         */
        function assertEdge(edge, shouldBePresent, desc) {
            let col = edge.n1.x * 4;
            let row = edge.n1.y * 4;
            let dxs = [0];
            let dys = [1, 2, 3];
            if (edge.n1.y === edge.n2.y) {
                [dxs, dys] = [dys, dxs];
            }
            for (let dy of dys) {
                let line = lines[row + dy] || '';
                for (let dx of dxs) {
                    let c = line[col + dx] || ' ';
                    if ((c !== ' ') !== shouldBePresent) {
                        throw new Error(`${desc} at row=${row+dy} col=${col+dx} "${c}".`)
                    }
                }
            }
        }

        let graph = new ZxGraph();

        let edgeKindMap = {};
        for (let nodeKind of NODES.all) {
            if (nodeKind.allowedDegrees.indexOf(2) !== -1) {
                for (let rep of nodeKind.diagramReps) {
                    edgeKindMap[rep] = nodeKind.id;
                }
            }
        }
        edgeKindMap['|'] = '-';
        edgeKindMap['-'] = '-';

        let nodeKindMap = {};
        for (let nodeKind of NODES.all) {
            for (let rep of nodeKind.diagramReps) {
                nodeKindMap[rep] = nodeKind.id;
            }
        }

        // Nodes.
        for (let row = 0; row < lines.length; row += 4) {
            let line = lines[row];
            for (let col = 0; col < line.length; col += 4) {
                let c = line[col];
                let n = new ZxNode(col >> 2, row >> 2);
                if (c === ' ') {
                    for (let e of n.unitEdges()) {
                        assertEdge(e, false, 'Nodeless edge');
                    }
                    continue;
                }

                let c2 = line[col + 1];
                if (c2 !== undefined && c2 !== '-' && c2 !== ' ') {
                    c += c2;
                }
                let kind = nodeKindMap[c];
                if (kind === undefined) {
                    throw new Error(`Unrecognized node character: "${c}".`);
                }
                graph.nodes.set(n, kind);
            }
        }

        // Vertical edges.
        for (let row = 2; row < lines.length; row += 4) {
            let line = lines[row];
            for (let col = 0; col < line.length; col += 4) {
                let c = line[col];
                let e = ZxEdge.makeVerticalUnit(col >> 2, row >> 2);
                assertEdge(e, c !== ' ', 'Broken v edge');
                if (c !== ' ') {
                    let kind = edgeKindMap[c];
                    if (kind === undefined) {
                        throw new Error(`Unrecognized edge character: "${c}".`);
                    }
                    graph.edges.set(e, kind);
                }
            }
        }

        // Horizontal edges.
        for (let row = 0; row < lines.length; row += 4) {
            let line = lines[row];
            for (let col = 2; col < line.length; col += 4) {
                let c = line[col];
                let e = ZxEdge.makeHorizontalUnit(col >> 2, row >> 2);
                assertEdge(e, c !== ' ', 'Broken h edge');
                if (c !== ' ') {
                    let kind = edgeKindMap[c];
                    if (kind === undefined) {
                        throw new Error(`Unrecognized edge character: "${c}".`);
                    }
                    graph.edges.set(e, kind);
                }
            }
        }

        return graph;
    }

    /**
     * @param {!ZxPort|!ZxNode} start
     * @param {!ZxNode} endNode
     * @returns {undefined|!Array.<!ZxEdge>}
     */
    tryFindFreePath(start, endNode) {
        let prevMap = new GeneralMap();
        let queue = /** @type {!Array.<!ZxPort>} */ [];
        let startX;
        let startY;
        if (start instanceof ZxNode) {
            startX = start.x;
            startY = start.y;
            for (let port of start.unitPorts()) {
                if (!this.edges.has(port.edge)) {
                    prevMap.set(port.edge, undefined);
                    queue.push(port);
                }
            }
        } else if (start instanceof ZxPort) {
            startX = start.node.x;
            startY = start.node.y;
            prevMap.set(start.edge, undefined);
            queue.push(start);
        }

        function trace(edge) {
            let path = [];
            while (edge !== undefined) {
                path.push(edge);
                edge = prevMap.get(edge);
            }
            return path;
        }

        let tryEnqueue = (prevEdge, oppNode, nextEdge) => {
            if (!this.has(nextEdge) && !prevMap.has(nextEdge)) {
                prevMap.set(nextEdge, prevEdge);
                queue.push(new ZxPort(nextEdge, oppNode));
            }
        };

        let box = this.boundingBox();
        let minX = Math.min(box.x, endNode.x, startX) - 4;
        let maxX = Math.max(box.x + box.w - 4, endNode.x, startX) + 4;
        let minY = Math.min(box.y, endNode.y, startY) - 4;
        let maxY = Math.max(box.y + box.h - 4, endNode.y, startY) + 4;

        while (queue.length > 0) {
            let prevPort = queue.shift();
            let prevEdge = prevPort.edge;
            let prevNode = prevPort.node;
            let oppNode = prevEdge.opposite(prevNode);
            if (oppNode.x < minX || oppNode.x > maxX || oppNode.y < minY || oppNode.y > maxY) {
                continue;
            }
            if (oppNode.isEqualTo(endNode)) {
                return trace(prevEdge);
            }

            let nodeKind = this.kind(oppNode);
            if (nodeKind === undefined) {
                let neighbors = [
                    oppNode.upUnitEdge(), oppNode.downUnitEdge(), oppNode.leftUnitEdge(), oppNode.rightUnitEdge()
                ];
                for (let nextEdge of neighbors) {
                    tryEnqueue(prevEdge, oppNode, nextEdge);
                }
            } else if (nodeKind === '+') {
                let nextEdge = prevEdge.reflectedThrough(oppNode);
                tryEnqueue(prevEdge, oppNode, nextEdge);
            }
        }

        return undefined;
    }

    /**
     * @param {!Iterable.<!ZxEdge>|!GeneralSet<!ZxEdge>} edgePath
     * @param {!boolean=true} includingOrphans
     */
    deletePath(edgePath, includingOrphans=true) {
        for (let e of edgePath) {
            this.edges.delete(e);
        }

        for (let e of edgePath) {
            for (let n of e.nodes()) {
                let kind = this.kind(n);
                if (kind === undefined) {
                    continue;
                }
                let degree = this.activeUnitEdgesOf(n).length;
                let allowedDegrees = NODES.map.get(kind).allowedDegrees;
                let remove = includingOrphans || (kind === '+' && allowedDegrees.indexOf(0) === -1);
                if (remove && degree === 0) {
                    this.nodes.delete(n);
                }
            }
        }
    }

    /**
     * @param {!ZxNode} node
     * @returns {!Array.<![!ZxPort, !ZxPort]>}
     */
    activeCrossingPortPairs(node) {
        if (this.kind(node) !== '+') {
            return [];
        }
        let ports = this.activePortsOf(node);
        if (ports.length !== 2 && ports.length !== 4) {
            throw new Error('Crossing node must have even degree.');
        }
        let pairs = [];
        if (ports.length === 2) {
            pairs.push(ports);
        } else {
            pairs.push([node.leftPort(), node.rightPort()]);
            pairs.push([node.upPort(), node.downPort()]);
        }
        return pairs;
    }
    /**
     * @param {!ZxNode} n
     * @returns {!Array.<!ZxEdge>}
     */
    activeEdgesOf(n) {
        if (!this.nodes.has(n)) {
            return [];
        }
        return this.sortedEdges().filter(e => e.n1.isEqualTo(n) || e.n2.isEqualTo(n));
    }

    /**
     * @param {!ZxNode} n
     * @returns {!Array.<!ZxEdge>}
     */
    activeUnitEdgesOf(n) {
        if (!this.nodes.has(n)) {
            return [];
        }
        return n.unitEdges().filter(e => this.edges.has(e));
    }

    /**
     * @param {!ZxNode|!ZxEdge} nodeOrEdge
     * @returns {!Array.<!ZxPort>}
     */
    activePortsOf(nodeOrEdge) {
        if (nodeOrEdge instanceof ZxEdge) {
            return nodeOrEdge.ports();
        }

        if (nodeOrEdge instanceof ZxNode) {
            let n = nodeOrEdge;
            return this.activeEdgesOf(n).map(e => new ZxPort(e, n));
        }

        throw new Error(`Unrecognized: ${nodeOrEdge}`);
    }

    /**
     * @param {!ZxNode} n
     * @returns {!Array.<!ZxNode>}
     */
    activeNeighborsOf(n) {
        return this.activeEdgesOf(n).map(e => e.opposite(n));
    }

    /**
     * @param {!ZxNode} start
     * @param {!ZxNode} end
     * @returns {![!Array.<!ZxNode>, !Array.<!ZxEdge>]}
     * @private
     */
    static _line(start, end) {
        let dx = Math.sign(end.x - start.x);
        let dy = Math.sign(end.y - start.y);
        if (dx !== 0 && dy !== 0) {
            throw new Error('dx !== 0 && dy !== 0');
        }
        let horizontal = dx !== 0;
        let x = start.x;
        let y = start.y;
        let nodes = [];
        let edges = [];
        while (true) {
            nodes.push(new ZxNode(x, y));
            if (x === end.x && y === end.y) {
                break;
            }
            edges.push(ZxEdge.makeUnit(
                x + Math.min(dx, 0),
                y + Math.min(dy, 0),
                horizontal));
            x += dx;
            y += dy;
        }
        return [nodes, edges];
    }

    /**
     * @param {!ZxNode} start
     * @param {!ZxNode} end
     * @param {!Array.<!string>|undefined=undefined} node_types
     */
    add_line(start, end, node_types=undefined) {
        let [nodes, edges] = ZxGraph._line(start, end);
        if (node_types !== undefined) {
            if (nodes.length !== node_types.length) {
                throw new Error('nodes.length !== node_types.length');
            }
            for (let i = 0; i < nodes.length; i++) {
                let n = nodes[i];
                let t = node_types[i];
                if (this.nodes.get(n, t) !== t) {
                    throw new Error('this.nodes.get(n, t) !== t');
                }
                this.nodes.set(n, t);
            }
        }
        for (let e of edges) {
            if (this.edges.get(e, '-') !== '-') {
                throw new Error(`this.edges.get(e, '-') !== '-'`);
            }
            this.edges.set(e, '-');
        }
    }

    /**
     * @param {object|!ZxGraph} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return other instanceof ZxGraph && other.edges.isEqualTo(this.edges) && other.nodes.isEqualTo(this.nodes);
    }

    /**
     * @returns {!{x: !int, y: !int, w: !int, h: !int}}
     */
    boundingBox() {
        let nodes = [...this.nodes.keys()];
        if (nodes.length === 0) {
            return {x: 0, y: 0, w: 0, h: 0};
        }
        let xs = nodes.map(n => n.x);
        let ys = nodes.map(n => n.y);
        let x = Math.min(...xs);
        let y = Math.min(...ys);
        return {
            x,
            y,
            w: Math.max(...xs) - x + 1,
            h: Math.max(...ys) - y + 1
        }
    }

    /**
     * @param {!int} dx
     * @param {!int} dy
     * @returns {!ZxGraph}
     */
    shifted(dx, dy) {
        /**
         * @param {!ZxNode} n
         * @returns {!ZxNode}
         */
        function shiftedNode(n) {
            return new ZxNode(n.x + dx, n.y + dy);
        }

        return new ZxGraph(
            this.nodes.mapKeys(shiftedNode),
            this.edges.mapKeys(e => new ZxEdge(shiftedNode(e.n1), shiftedNode(e.n2))))
    }

    /**
     * Produces a text diagram of the graph.
     * @param {!boolean} topLeftAsOrigin
     * @returns {!string}
     */
    toString(topLeftAsOrigin=false) {
        if (topLeftAsOrigin) {
            let {x, y} = this.boundingBox();
            return this.shifted(-x, -y).toString();
        }

        let xs = this.sortedNodes().map(n => n.x);
        let ys = this.sortedNodes().map(n => n.y);
        let w = Math.max(...xs) + 1;
        let h = Math.max(...ys) + 1;

        let lines = [];
        let node_reps = {
            '': ' ',
        };
        for (let node of NODES.all) {
            node_reps[node.id] = node.diagramReps[0];
        }
        let horizontalEdgeReps = {};
        let verticalEdgeReps = {
            '': ' ',
            '-': '|',
        };
        for (let node of NODES.all) {
            if (node.allowedDegrees.indexOf(2) !== -1) {
                horizontalEdgeReps[node.id] = node.diagramReps[0];
                verticalEdgeReps[node.id] = node.diagramReps[0];
            }
        }

        for (let row = 0; row < h; row++) {
            if (row > 0) {
                let vertical_modifiers = [];
                let vertical_connectors = [];
                for (let col = 0; col < w; col++) {
                    if (col > 0) {
                        vertical_connectors.push('   ');
                        vertical_modifiers.push('   ');
                    }
                    let e = new ZxNode(col, row).upUnitEdge();
                    let c = this.edges.get(e) || '';
                    vertical_connectors.push(c === '' ? ' ' : '|');
                    vertical_modifiers.push(verticalEdgeReps[c] || c);
                }

                lines.push(vertical_connectors.join(''));
                lines.push(vertical_modifiers.join(''));
                lines.push(vertical_connectors.join(''));
            }
            let chars = [];
            let cut = 0;
            for (let col = 0; col < w; col++) {
                let p = new ZxNode(col, row);

                if (col > 0) {
                    let c = this.edges.get(p.leftUnitEdge());
                    if (c === undefined) {
                        chars.push('   '.slice(cut));
                    } else {
                        chars.push(`-${horizontalEdgeReps[c] || c}-`.slice(cut));
                    }

                }
                let c = this.nodes.get(p) || '';
                if (c === '+') {
                    // Specialized crossing characters.
                    if (this.activeEdgesOf(p).length === 2) {
                        if (this.has(p.upUnitEdge()) && this.has(p.downUnitEdge())) {
                            chars.push('|');
                            continue;
                        }
                        if (this.has(p.leftUnitEdge()) && this.has(p.rightUnitEdge())) {
                            chars.push('-');
                            continue;
                        }
                    }
                }
                let nodeShown = node_reps[c] || c;
                chars.push(nodeShown);
                cut = nodeShown.length - 1;
            }
            lines.push(chars.join(''));
        }
        return lines.map(rtrim).join('\n');
    }

    /**
     * @param {!ZxEdge|!ZxNode} element
     * @param {!ZxEdge|!ZxNode} pivot
     * @returns {undefined|!ZxEdge|!ZxNode}
     */
    unblockedOppositeOfAcross(element, pivot) {
        if (pivot instanceof ZxEdge) {
            if (!(element instanceof ZxNode)) {
                throw new Error(`Pivot/element not opposite types: ${element}, ${pivot}`);
            }
            return pivot.opposite(element);
        } else if (pivot instanceof ZxNode) {
            if (!(element instanceof ZxEdge)) {
                throw new Error(`Pivot/element not opposite types: ${element}, ${pivot}`);
            }

            for (let pair of this.activeCrossingPortPairs(pivot)) {
                for (let i = 0; i < 2; i++) {
                    if (element.isEqualTo(pair[i].edge)) {
                        return pair[1-i].edge;
                    }
                }
            }

            return undefined;
        } else {
            throw new Error(`Unrecognized pivot type: ${pivot}`);
        }
    }

    /**
     * @param {!ZxEdge|!ZxNode} element
     * @param {!boolean=true} skipAmbiguous
     * @returns {!GeneralSet.<!ZxEdge>}
     */
    extendedUnblockedPath(element, skipAmbiguous=true) {
        if (!this.has(element)) {
            throw new Error(`Element is not in the graph and so cannot be part of an unblocked path: ${element}`);
        }

        let result = new GeneralSet();
        let queue = [];

        if (element instanceof ZxNode) {
            if (this.kind(element) !== '+') {
                return result;
            }
            let pairs = this.activeCrossingPortPairs(element);
            if (pairs.length !== 1 && skipAmbiguous) {
                return result;
            }
            for (let pair of pairs) {
                queue.push(...pair)
            }
        } else {
            result.add(element);
            queue.push(...element.ports())
        }

        while (queue.length > 0) {
            let curPort = queue.shift();
            let nextEdge = this.unblockedOppositeOfAcross(curPort.edge, curPort.node);
            if (nextEdge === undefined || result.has(nextEdge)) {
                continue;
            }
            result.add(nextEdge);
            let nextNode = nextEdge.opposite(curPort.node);
            queue.push(new ZxPort(nextEdge, nextNode));
        }
        return result;
    }
}

function rtrim(e) {
    return e.replace(/ +$/g, '');
}

_gen_package_export("src/sim/ZxGraph.js", {ZxNode, ZxEdge, ZxPort, ZxGraph});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/ZxGraphEval.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {ChpSimulator} = _gen_package_get("src/sim/ChpSimulator.js");
const {Matrix} = _gen_package_get("src/base/Matrix.js");
const {ZxPort, ZxGraph, ZxEdge, ZxNode} = _gen_package_get("src/sim/ZxGraph.js");
const {QubitAxis,PauliProduct} = _gen_package_get("src/sim/PauliProduct.js");
const {stabilizerStateToWavefunction} = _gen_package_get("src/sim/StabilizerToWave.js");;
const {
    QuantumProgram,
    Comment,
    HeaderAlloc,
    MeasurementsWithPauliFeedback,
    InitEprPairs,
    AmpsDisplay,
    PostSelection,
} = _gen_package_get("src/sim/QuantumProgram.js");
const {NODES} = _gen_package_get("src/nodes/All.js");;
const {EdgeActions} = _gen_package_get("src/sim/EdgeActions.js");;

/**
 * Determines products of Paulis that can be applied after EPR pairs are made, but before spider measurements
 * are performed, without changing the state produced by the graph (up to global phase). This includes both products
 * that are no-ops because they are stabilizers of the EPR pairs as well as products that are no-ops because they
 * exactly match a measurement that is about to be performed.
 *
 * @param {!ZxGraph} graph
 * @param {!GeneralMap.<!ZxPort, !int>} qubitMap
 * @returns {!Array.<!PauliProduct>}
 */
function fixedPointsOfGraph(graph, qubitMap) {
    let fixedPoints = [];

    // Pauli products that are about to be measured are fixed points.
    for (let node of graph.nodes.keys()) {
        fixedPoints.push(..._nodeFixedPoints(graph, node, qubitMap));
    }

    // Stabilizers of the input state are fixed points.
    for (let edge of graph.edges.keys()) {
        fixedPoints.push(..._edgeEprFixedPoints(graph, edge, qubitMap));
    }

    return fixedPoints;
}

/**
 * @param {!PauliProduct} product
 * @param {!int} n
 * @param {!Array.<!int>} qubits
 * @private
 */
function _remapProductQubits(product, n, qubits) {
    return PauliProduct.fromSparseQubitAxes(
        n,
        product.activeQubitAxes().map(axis => new QubitAxis(qubits[axis.qubit], axis.axis)));
}

/**
 * @param {!ZxGraph} graph
 * @param {!ZxNode} node
 * @param {!GeneralMap.<!ZxPort, !int>} qubit_map
 * @private
 */
function _nodeFixedPoints(graph, node, qubit_map) {
    let ports = graph.activePortsOf(node);
    let kind = graph.kind(node);

    let nodeKind = NODES.map.get(kind);
    if (nodeKind === undefined) {
        throw new Error(`Unrecognized node kind ${kind} for fixed points.`);
    }
    let qs = ports.map(p => qubit_map.get(p));
    let products = nodeKind.fixedPoints(qs.length);
    return products.map(e => _remapProductQubits(e, qubit_map.size, qs));
}

/**
 * @param {!ZxGraph} graph
 * @param {!ZxEdge} edge
 * @param {!GeneralMap.<!ZxPort, !int>} qubit_map
 * @private
 */
function _edgeEprFixedPoints(graph, edge, qubit_map) {
    let qubits = edge.ports().map(p => qubit_map.get(p));
    let kind = graph.kind(edge);
    let nodeKind = NODES.map.get(kind === '-' ? '@' : kind);
    if (nodeKind === undefined) {
        throw new Error(`Unrecognized edge kind ${kind} for fixed points.`);
    }
    let products = nodeKind.fixedPoints(2);
    return products.map(e => _remapProductQubits(e, qubit_map.size, qubits));
}

/**
 * Rewrites the set of fixed points internal to the graph into rules for which external elements can be toggled
 * in order to have the same effect as toggling an internal element.
 *
 * In some cases an individual internal toggle will not correspond to any set of external toggles, but a pairing of
 * such internal toggles will. In this case exactly one of the involved internal toggles will be mapped to the external
 * toggle of the pairing, whereas the others are mapped to an 'undefined' rule to indicate the redundancy. This works
 * because this case occurs only when all of the paired internal toggles will be needed at the same time.
 *
 * @param {!Array.<!PauliProduct>} fixedPoints
 * @param {!int} internalWidth The columns of the fixed point table first go over the internal degrees of freedom, then
 *      the external ones. This indicates where the split is located.
 * @returns {!GeneralMap<!QubitAxis, !Array.<!QubitAxis>>}
 * @private
 */
function _internalToExternalMapFromFixedPoints(fixedPoints, internalWidth) {
    let reducedFixedPoints = PauliProduct.gaussianEliminate(fixedPoints).map(e => e.abs());

    let fixupMap = /** @type {!GeneralMap<!QubitAxis, !Array.<!QubitAxis>>} */ new GeneralMap();

    for (let fixedPoint of reducedFixedPoints) {
        let internal = fixedPoint.slice(0, internalWidth);
        if (internal.xzBitWeight() === 0) {
            continue;
        }

        let [control, ...redundantControls] = internal.activeQubitAxes();
        if (fixupMap.has(control)) {
            throw new Error('Control was used twice.')
        }
        for (let pauli of redundantControls) {
            if (fixupMap.get(pauli, undefined) !== undefined) {
                throw new Error('Inconsistent implied control.')
            }
            fixupMap.set(pauli, undefined);
        }
        let externalFlips = fixedPoint.activeQubitAxes().filter(e => e.qubit >= internalWidth);
        fixupMap.set(control, externalFlips);
    }

    return fixupMap;
}

/**
 * @param {!ZxGraph} graph
 * @param {!PortQubitMapping} portQubitMapping
 * @param {!Array.<TransformedMeasurement>} transMeasurements
 * @returns {!GeneralMap<!int, !Array.<!QubitAxis>>} Map from in/out axis to measurement qubits that flip it.
 */
function _transformedMeasurementToFeedbackMap(graph, portQubitMapping, transMeasurements) {
    let fixedPoints = fixedPointsOfGraph(graph, portQubitMapping.map);
    let externalMap = _internalToExternalMapFromFixedPoints(fixedPoints, portQubitMapping.numInternal);
    let out = new GeneralMap();
    for (let transMeasure of transMeasurements) {
        if (!externalMap.has(transMeasure.postselectionControlAxis)) {
            throw new Error('Uncontrollable measurement.');
        }
        let externalFlips = externalMap.get(transMeasure.postselectionControlAxis) || [];
        out.set(transMeasure.measurementAxis.qubit, externalFlips);
    }
    return out;
}

/**
 * @param {!ZxGraph} graph
 * @returns {!PortQubitMapping}
 */
function graphToPortQubitMapping(graph) {
    let portToQubitMap = /** @type {!GeneralMap<!ZxPort, !int>} */ new GeneralMap();

    // Sort and classify nodes.
    let inputNodes = graph.inputNodes();
    let outputNodes = graph.outputNodes();
    let postNodes = graph.postselectionNodesWithAxis();
    let measurementNodes = graph.spiderNodesWithAxis();
    let crossingNodes = graph.crossingNodes();
    let hadamardNodes = graph.hadamardNodes();
    if (inputNodes.length +
            outputNodes.length +
            measurementNodes.length +
            crossingNodes.length +
            hadamardNodes.length +
            postNodes.length !== graph.nodes.size) {
        throw new Error('Unrecognized node(s).');
    }

    // CAREFUL: The order of the nodes' qubits matters!
    // Earlier qubits are isolated by Gaussian eliminations, expressing them in terms of later qubits.
    // Therefore it is important that qubits for nodes we want to eliminate to have qubits that come first.

    // Internal nodes go first.
    for (let node of crossingNodes) {
        for (let p of graph.activePortsOf(node)) {
            portToQubitMap.set(p, portToQubitMap.size);
        }
    }
    for (let node of hadamardNodes) {
        for (let p of graph.activePortsOf(node)) {
            portToQubitMap.set(p, portToQubitMap.size);
        }
    }
    for (let {node} of measurementNodes) {
        for (let p of graph.activePortsOf(node)) {
            portToQubitMap.set(p, portToQubitMap.size);
        }
    }

    // Then input nodes.
    for (let node of inputNodes) {
        let ports = graph.activePortsOf(node);
        if (ports.length !== 1) {
            throw new Error('ports.length !== 1')
        }
        portToQubitMap.set(ports[0], portToQubitMap.size);
    }

    // Then output nodes.
    for (let node of outputNodes) {
        let ports = graph.activePortsOf(node);
        if (ports.length !== 1) {
            throw new Error('ports.length !== 1')
        }
        portToQubitMap.set(ports[0], portToQubitMap.size);
    }

    // And lastly post-selection.
    for (let {node} of postNodes) {
        let ports = graph.activePortsOf(node);
        if (ports.length !== 1) {
            throw new Error('ports.length !== 1')
        }
        portToQubitMap.set(ports[0], portToQubitMap.size);
    }

    return new PortQubitMapping(
        portToQubitMap,
        inputNodes.length,
        outputNodes.length,
        postNodes.length);
}

/**
 * @param {!ZxGraph} graph
 * @returns {!{
 *      stabilizers: !Array.<!PauliProduct>,
 *      wavefunction: !Matrix,
 *      qasm: !string,
 *      quirkUrl: !string,
 *      satisfiable: !boolean,
 *      successProbability: !number,
 * }}
 */
function evalZxGraph(graph) {
    // Prepare simulator.
    let portQubitMapping = graphToPortQubitMapping(graph);
    let outProgram = new QuantumProgram();
    outProgram.statements.push(new HeaderAlloc(portQubitMapping));

    // Perform operations congruent to the ZX graph.
    _zxEval_initEdgeEprPairs(outProgram, graph, portQubitMapping.map);
    _zxEval_performNodeMeasurements(outProgram, graph, portQubitMapping);
    outProgram.statements.push(new AmpsDisplay(
        portQubitMapping.numInternal,
        portQubitMapping.numIn + portQubitMapping.numOut));

    // Derive wavefunction and etc for caller.
    return _analyzeProgram(outProgram, portQubitMapping);
}

/**
 * @param {!QuantumProgram} outProgram
 * @param {!ZxGraph} graph
 * @param {!GeneralMap.<!ZxPort, !int>} portToQubitMap
 * @private
 */
function _zxEval_initEdgeEprPairs(outProgram, graph, portToQubitMap) {
    outProgram.statements.push(new Comment('', 'Init per-edge EPR pairs.'));

    // Identify edge qubit pairs.
    let pairs = [...graph.edges.entries()].map(ek => {
        let [e, kind] = ek;
        let qs = e.ports().map(p => portToQubitMap.get(p));
        qs.sort((a, b) => a - b);
        return {qs, kind};
    });
    pairs.sort((a, b) => (a.qs[0] - b.qs[0])*10000 + (a.qs[1] - b.qs[1]));

    // Make the EPR pairs.
    outProgram.statements.push(new InitEprPairs(...pairs.map(e => e.qs)));

    // Apply any edge-based basis changes.
    let edgeBasisChanges = new GeneralMap();
    for (let pair of pairs) {
        let nodeKind = NODES.map.get(pair.kind === '-' ? '@' : pair.kind);
        if (nodeKind.edgeAction.matrix !== 1) {
            edgeBasisChanges.set(pair.qs[0], pair.kind);
        }
    }
    if (edgeBasisChanges.size > 0) {
        outProgram.statements.push(new EdgeActions(edgeBasisChanges, false));
    }
}

class PortQubitMapping {
    /**
     * @param {!GeneralMap.<!ZxPort, !int>} map
     * @param {!int} numIn
     * @param {!int} numOut
     * @param {!int} numPost
     */
    constructor(map, numIn, numOut, numPost) {
        this.map = map;
        this.numIn = numIn;
        this.numOut = numOut;
        this.numPost = numPost;
    }

    /**
     * @param {*} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        return (other instanceof PortQubitMapping &&
            this.map.isEqualTo(other.map) &&
            this.numIn === other.numIn &&
            this.numOut === other.numOut &&
            this.numPost === other.numPost);
    }

    get numQubits() {
        return this.map.size;
    }

    get numExternal() {
        return this.numIn + this.numOut + this.numPost;
    }

    get numInternal() {
        return this.numQubits - this.numExternal;
    }
}

/**
 * @param {!QuantumProgram} outProgram
 * @param {!ZxGraph} graph
 * @param {!PortQubitMapping} portQubitMapping
 * @private
 */
function _zxEval_performNodeMeasurements(outProgram, graph, portQubitMapping) {
    // Apply single-qubit basis changes.
    let nodeBasisChanges = new GeneralMap();
    for (let node of graph.nodes.keys()) {
        let nodeKind = NODES.map.get(graph.kind(node));
        let ports = graph.activePortsOf(node);
        let mat = nodeKind.nodeRootEdgeAction.matrix;
        if (ports.length > 0 && mat !== 1 && mat !== null) {
            nodeBasisChanges.set(portQubitMapping.map.get(ports[0]), nodeKind.id);
        }
    }
    if (nodeBasisChanges.size > 0) {
        outProgram.statements.push(new Comment('', 'Apply per-node basis changes.'));
        outProgram.statements.push(new EdgeActions(nodeBasisChanges, true));
    }

    // Multi-qubit basis changes and transformed measurement collection.
    outProgram.statements.push(new Comment('', 'Perform per-node measurements.'));
    let transMeasurements = /** @type {!Array.<TransformedMeasurement>} */ [];
    for (let [node, kind] of graph.nodes.entries()) {
        if (kind !== '+') {
            let nodeKind = NODES.map.get(kind);
            let qubits = graph.activePortsOf(node).map(p => portQubitMapping.map.get(p));
            transMeasurements.push(
                ...nodeKind.nodeMeasurer(outProgram, portQubitMapping.numQubits, qubits));
        } else {
            for (let pair of graph.activeCrossingPortPairs(node)) {
                let qubits = pair.map(p => portQubitMapping.map.get(p));
                transMeasurements.push(
                    ...NODES.black.nodeMeasurer(outProgram, portQubitMapping.numQubits, qubits, false));
            }
        }
    }

    // Group transformed measurements by basis.
    let xMeasured = transMeasurements.filter(e => !e.measurementAxis.axis).map(e => e.measurementAxis.qubit);
    let allMeasured = transMeasurements.map(e => e.measurementAxis.qubit);
    allMeasured.sort((a, b) => a - b);

    // Measurements and feedback.
    outProgram.statements.push(new EdgeActions(new Map(xMeasured.map(q => [q, 'h'])), false));
    let measurementToFeedback = _transformedMeasurementToFeedbackMap(
        graph, portQubitMapping, transMeasurements);
    outProgram.statements.push(new MeasurementsWithPauliFeedback(measurementToFeedback));

    // Post-selections.
    let postSelections = new GeneralMap();
    for (let [node, kind] of graph.nodes.entries()) {
        let nodeKind = NODES.map.get(kind);
        if (nodeKind.postSelectStabilizer === undefined) {
            continue;
        }
        let ports = graph.activePortsOf(node);
        if (ports.length !== 1) {
            throw new Error('Postselection node must have degree 1.');
        }
        let qubit = portQubitMapping.map.get(ports[0]);
        postSelections.set(qubit, nodeKind.postSelectStabilizer);
    }
    if (postSelections.size > 0) {
        outProgram.statements.push(new PostSelection(postSelections));
    }
}

/**
 * @param {!QuantumProgram} outProgram
 * @param {!PortQubitMapping} portQubitMapping
 * @returns {!{
 *      stabilizers: !Array.<!PauliProduct>,
 *      wavefunction: !Matrix,
 *      qasm: !string,
 *      quirkUrl: !string,
 *      satisfiable: !boolean,
 *      successProbability: !number,
 * }}
 * @private
 */
function _analyzeProgram(outProgram, portQubitMapping) {
    let qasm = outProgram.qasm();
    let quirkUrl = outProgram.quirkUrl();

    let wantZeroSim = new ChpSimulator(portQubitMapping.numQubits, 0);
    let wantZeroOut = {
        measurements: [],
        successProbability: 1.0,
    };
    try {
        outProgram.interpret(wantZeroSim, wantZeroOut);
    } finally {
        wantZeroSim.destruct();
    }
    let satisfiable = wantZeroOut.measurements.every(e => !e[1]);

    let sim = new ChpSimulator(portQubitMapping.numQubits);
    let out = {
        measurements: [],
        successProbability: 1.0,
    };
    let stabilizers;
    try {
        outProgram.interpret(sim, out);
        stabilizers = _extractRemainingStabilizers(
            sim,
            portQubitMapping.numInternal,
            portQubitMapping.numIn + portQubitMapping.numOut);
    } finally {
        sim.destruct();
    }

    let wavefunction = undefined;
    if (portQubitMapping.numIn + portQubitMapping.numOut < 8) {
        wavefunction = stabilizerStateToWavefunction(stabilizers);
        wavefunction = new Matrix(1 << portQubitMapping.numIn,
            1 << portQubitMapping.numOut, wavefunction.rawBuffer());
    }

    return {
        stabilizers,
        wavefunction,
        qasm,
        quirkUrl,
        satisfiable,
        successProbability: out.successProbability
    };
}

/**
 * @param {!ChpSimulator} stabilizerSim
 * @param {!int} offset
 * @param {!int} len
 * @returns {!Array.<!PauliProduct>}
 * @private
 */
function _extractRemainingStabilizers(stabilizerSim, offset, len) {
    // Extract and normalize stabilizers from simulator.
    let lines = stabilizerSim.toString().split('\n');
    lines = lines.slice(1 + (lines.length >> 1));
    let paulis = PauliProduct.gaussianEliminate(lines.map(PauliProduct.fromString));

    // Only keep lower right of table (the unmeasured qubits).
    lines = paulis.map(e => e.toString());
    lines = lines.slice(offset, offset + len).map(e => e[0] + e.slice(1 + offset, 1 + offset + len));
    paulis = lines.map(PauliProduct.fromString);

    // Normalize
    return PauliProduct.gaussianEliminate(paulis);
}

_gen_package_export("src/sim/ZxGraphEval.js", {evalZxGraph, graphToPortQubitMapping, fixedPointsOfGraph});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/sim/ZxGraphGroundTruth.js", function() {

const {GeneralMap} = _gen_package_get("src/base/GeneralMap.js");;
const {seq} = _gen_package_get("src/base/Seq.js");;
const {Complex} = _gen_package_get("src/base/Complex.js");
const {Matrix} = _gen_package_get("src/base/Matrix.js");
const {ZxPort, ZxGraph, ZxEdge, ZxNode} = _gen_package_get("src/sim/ZxGraph.js");
const {Controls} = _gen_package_get("src/sim/Controls.js");;
const {zBasisEqualityMatrix, xBasisEqualityMatrix} = _gen_package_get("src/nodes/Base.js");;
const {NODES} = _gen_package_get("src/nodes/All.js");;


class Tensor {
    /**
     * @param {!Matrix} data
     * @param {!Array.<ZxPort>} ports
     */
    constructor(data, ports) {
        if (1 << ports.length !== data.height() || data.width() !== 1) {
            throw new Error('1 << ports.length !== data.height() || data.width() !== 1');
        }
        this.data = data;
        this.ports = ports;
    }

    /**
     * @param {!Matrix} unitary
     * @param {!ZxPort} port
     */
    inline_applyMatrixToPort(unitary, port) {
        this.data = unitary.applyToStateVectorAtQubitWithControls(
            this.data,
            this._indexOfPort(port),
            Controls.NONE);
    }

    /**
     * @param {ZxPort} port
     * @returns {!int}
     * @private
     */
    _indexOfPort(port) {
        for (let k = 0; k < this.ports.length; k++) {
            if (port.isEqualTo(this.ports[k])) {
                return k;
            }
        }

        throw new Error(`${this} doesn't have port ${port}.`);
    }

    /**
     * @param {!Array.<!ZxPort>} newOrder
     */
    inline_reorderPorts(newOrder) {
        for (let newIndex = 0; newIndex < this.ports.length; newIndex++) {
            let oldIndex = this._indexOfPort(newOrder[newIndex]);
            if (oldIndex === newIndex) {
                continue;
            }
            [this.ports[newIndex], this.ports[oldIndex]] = [this.ports[oldIndex], this.ports[newIndex]];
            this.data = this.data.afterQubitSwap(oldIndex, newIndex);
        }
    }

    /**
     * @param {!ZxPort} port1
     * @param {!ZxPort} port2
     * @returns {!Tensor}
     */
    _selfContract(port1, port2) {
        let p1 = this._indexOfPort(port1);
        let p2 = this._indexOfPort(port2);
        if (p1 === p2) {
            throw new Error("Contracted port with itself.");
        }
        if (p1 > p2) {
            [p1, p2] = [p2, p1];
        }

        let ports = [
            ...this.ports.slice(0, p1),
            ...this.ports.slice(p1 + 1, p2),
            ...this.ports.slice(p2 + 1),
        ];
        let data = Matrix.zero(1, this.data.height() / 4);

        let buf1 = this.data.rawBuffer();
        let buf2 = data.rawBuffer();
        let n1 = buf1.length >> 1;
        for (let k = 0; k < n1; k++) {
            // Contraction axes must agree.
            let b1 = (k & (1 << p1)) !== 0;
            let b2 = (k & (1 << p2)) !== 0;
            if (b1 !== b2) {
                continue;
            }

            // Add into output.
            let k2 = dropBit(dropBit(k, p2), p1);
            buf2[k2*2] += buf1[k*2];
            buf2[k2*2+1] += buf1[k*2+1];
        }
        return new Tensor(data, ports);
    }

    /**
     * @param {!Tensor} other
     * @returns {!Tensor}
     */
    tensorProduct(other) {
        return new Tensor(
            this.data.tensorProduct(other.data),
            [...other.ports, ...this.ports]);
    }

    /**
     * @param {!ZxPort} thisPort
     * @param {!Tensor} other
     * @param {!ZxPort} otherPort
     * @returns {!Tensor}
     */
    contracted(thisPort, other, otherPort) {
        if (this === other) {
            return this._selfContract(thisPort, otherPort);
        }

        let p1 = this._indexOfPort(thisPort);
        let p2 = other._indexOfPort(otherPort);
        let ports = [
            ...this.ports.slice(0, p1),
            ...this.ports.slice(p1 + 1),
            ...other.ports.slice(0, p2),
            ...other.ports.slice(p2 + 1),
        ];
        let data = Matrix.zero(1, this.data.height() * other.data.height() / 4);

        let buf1 = this.data.rawBuffer();
        let buf2 = other.data.rawBuffer();
        let buf3 = data.rawBuffer();
        let secondWord = this.ports.length - 1;
        let n1 = buf1.length >> 1;
        let n2 = buf2.length >> 1;
        for (let k1 = 0; k1 < n1; k1++) {
            let c1 = this.data.cell(0, k1);
            let i1 = dropBit(k1, p1);
            for (let k2 = 0; k2 < n2; k2++) {
                // Contraction axes must agree.
                let b1 = (k1 & (1 << p1)) !== 0;
                let b2 = (k2 & (1 << p2)) !== 0;
                if (b1 !== b2) {
                    continue;
                }

                // Add input product into output.
                let i2 = dropBit(k2, p2);
                let k3 = i1 | (i2 << secondWord);
                let c2 = other.data.cell(0, k2);
                let c3 = c1.times(c2);
                buf3[k3*2] += c3.real;
                buf3[k3*2+1] += c3.imag;
            }
        }
        return new Tensor(data, ports);
    }

    /**
     * @returns {!string}
     */
    toString() {
        return `Tensor(ports=[\n    ${this.ports.join(',\n    ')}\n], data=${this.data})`;
    }

    /**
     * @param {object} other
     * @returns {!boolean}
     */
    isEqualTo(other) {
        if (!(other instanceof Tensor)) {
            return false;
        }
        if (!other.data.isEqualTo(this.data)) {
            return false;
        }
        if (other.ports.length !== this.ports.length) {
            return false;
        }
        for (let k = 0; k < this.ports.length; k++) {
            if (!this.ports[k].isEqualTo(other.ports[k])) {
                return false;
            }
        }
        return true;
    }
}


/**
 * @param {!int} val
 * @param {!int} bit
 * @returns {!int}
 */
function dropBit(val, bit) {
    let low = val & ((1 << bit) - 1);
    let high = val >> (bit + 1);
    return low | (high << bit);
}

/**
 * @param {!ZxGraph} graph
 * @returns {!Matrix}
 */
function evalZxGraphGroundTruth(graph) {
    let portToTensorMap = /** @type {!GeneralMap.<ZxPort, Tensor>} */new GeneralMap();
    let globalScalar = Complex.ONE;

    let inputPorts = [];
    let outputPorts = [];
    for (let node of graph.sortedNodes()) {
        let kind = graph.nodes.get(node);

        if (kind === '+') {
            for (let pair of graph.activeCrossingPortPairs(node)) {
                let tensor = new Tensor(zBasisEqualityMatrix(0, 2), pair);
                for (let port of pair) {
                    portToTensorMap.set(port, tensor);
                }
            }
            continue;
        }

        let nodeKind = NODES.map.get(kind);
        let ports = graph.activePortsOf(node);
        let degree = ports.length;
        if (nodeKind === undefined) {
            throw new Error(`Unrecognized node kind ${kind}`);
        }
        let data = nodeKind.tensor(degree);
        if (data.width() > 1) {
            data = new Matrix(1, data.height() * data.width(), data.rawBuffer());
        }

        if (kind === 'in' || kind === 'out') {
            let outerPort = new ZxPort(ports[0].edge, new ZxNode(100000, inputPorts.length + outputPorts.length));
            (kind === 'in' ? inputPorts : outputPorts).push(outerPort);
            ports.push(outerPort);
        }

        if (ports.length === 0) {
            globalScalar = globalScalar.times(data.cell(0, 0));
        }
        let tensor = new Tensor(data, ports);
        for (let port of ports) {
            portToTensorMap.set(port, tensor);
        }
    }

    for (let edge of graph.sortedEdges()) {
        let kind = graph.edges.get(edge);
        let [p1, p2] = graph.activePortsOf(edge);
        let t1 = portToTensorMap.get(p1);
        let t2 = portToTensorMap.get(p2);

        // Perform a basis change if necessary.
        let unitary = NODES.map.get(kind === '-' ? '@' : kind).edgeAction.matrix;
        if (unitary !== 1) {
            t1.inline_applyMatrixToPort(unitary, p1);
        }

        // Contract the two tensors into one and rewrite the port to tensor map accordingly.
        let t3 = t1.contracted(p1, t2, p2);
        for (let port of t3.ports) {
            portToTensorMap.set(port, t3);
        }
        portToTensorMap.delete(p1);
        portToTensorMap.delete(p2);
        if (t3.ports.length === 0) {
            globalScalar = globalScalar.times(t3.data.cell(0, 0));
        }
    }

    let result = new Tensor(Matrix.solo(globalScalar), []);
    let tensorFactors = seq(portToTensorMap.values()).distinctBy(e => e.ports[0]).toArray();
    for (let factor of tensorFactors) {
        result = result.tensorProduct(factor);
    }
    result.inline_reorderPorts([...inputPorts, ...outputPorts]);
    return new Matrix(1 << inputPorts.length, 1 << outputPorts.length, result.data.rawBuffer());
}

_gen_package_export("src/sim/ZxGraphGroundTruth.js", {Tensor, evalZxGraphGroundTruth});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/ui/Clear.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @param {!Revision} revision
 * @param {!Observable.<boolean>} obsIsAnyOverlayShowing
 */
function initClear(revision, obsIsAnyOverlayShowing) {
    const EMPTY_STATES = ['', ':'];

    const clearButton = /** @type {!HTMLButtonElement} */ document.getElementById('clear-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing, (r, v) => ({r, v})).subscribe(({r, v}) => {
        clearButton.disabled = EMPTY_STATES.indexOf(r) !== -1 || v;
    });
    clearButton.addEventListener('click', () => revision.commit(EMPTY_STATES[1]));
}

_gen_package_export("src/ui/Clear.js", {initClear});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/ui/DisplayedZxGraph.js", function() {

const {ZxGraph, ZxNode, ZxEdge} = _gen_package_get("src/sim/ZxGraph.js");;
const {GeneralSet} = _gen_package_get("src/base/GeneralSet.js");;
const {seq} = _gen_package_get("src/base/Seq.js");;

class DisplayedZxGraph {
    constructor() {
        this.graph = new ZxGraph();
        this.interpolateStartTime = 0;
        this.interpolateEndTime = 0;
        this.interpolateStartX = 0;
        this.interpolateEndX = 0;
        this.interpolateStartY = 0;
        this.interpolateEndY = 0;
        this.offsetX = 0;
        this.offsetY = 0;
        this.pitch = 50;
    }

    /**
     * @param {!boolean} withMargin
     * @returns {!{x: !int, y: !int, w: !int, h: !int}}
     */
    boundingDrawBox(withMargin=false) {
        let box = this.graph.boundingBox();
        [box.x, box.y] = this.nodeToXy(new ZxNode(box.x, box.y));
        box.w -= 1;
        box.h -= 1;
        box.w *= this.pitch;
        box.h *= this.pitch;
        if (withMargin) {
            box.x -= this.pitch * 2.5;
            box.y -= this.pitch * 2.5;
            box.w += this.pitch * 5;
            box.h += this.pitch * 5;
        }
        return box;
    }

    startCenteringInterpolation() {
        let {x, y} = this.graph.boundingBox();
        let desiredOffsetX = (2.5 - x) * this.pitch;
        let desiredOffsetY = (2.5 - y) * this.pitch;
        this.startInterpolation(0.5, desiredOffsetX, desiredOffsetY);
    }

    /**
     * @param {!number} duration
     * @param {!number} finalOffsetX
     * @param {!number} finalOffsetY
     */
    startInterpolation(duration, finalOffsetX, finalOffsetY) {
        if (this.offsetX === finalOffsetX && this.offsetY === finalOffsetY) {
            duration = 0;
        }

        //noinspection JSUnresolvedVariable
        let t = performance.now();
        this.interpolateStartTime = t;
        this.interpolateEndTime = t + duration*1000;
        this.interpolateStartX = this.offsetX;
        this.interpolateStartY = this.offsetY;
        this.interpolateEndX = finalOffsetX;
        this.interpolateEndY = finalOffsetY;
    }

    /**
     * @param {!number} time
     */
    interpolateTick(time) {
        this.offsetX = smoothStep(
            this.interpolateStartX,
            this.interpolateEndX,
            this.interpolateStartTime,
            this.interpolateEndTime,
            time);
        this.offsetY = smoothStep(
            this.interpolateStartY,
            this.interpolateEndY,
            this.interpolateStartTime,
            this.interpolateEndTime,
            time);
    }

    /**
     * @param {!ZxNode} n
     * @returns {![!number, !number]}
     */
    nodeToXy(n) {
        return [
            n.x * this.pitch + this.offsetX,
            n.y * this.pitch + this.offsetY
        ];
    }

    /**
     * @param {!ZxNode|!ZxEdge} element
     * @returns {![!number, !number]}
     */
    graphElementToCenterXy(element) {
        if (element instanceof ZxNode) {
            return this.nodeToXy(element);
        } else {
            let [n1, n2] = element.nodes();
            let [x1, y1] = this.nodeToXy(n1);
            let [x2, y2] = this.nodeToXy(n2);
            return [(x1 + x2) / 2, (y1 + y2) / 2];
        }
    }

    /**
     * @param {!number} x
     * @param {!number} y
     * @param {!ZxNode|!ZxEdge} element
     */
    xyDistanceToGraphElement(x, y, element) {
        let [cx, cy] = this.graphElementToCenterXy(element);
        let dx = x - cx;
        let dy = y - cy;
        return Math.sqrt(dx*dx + dy*dy);
    }

    /**
     * @param {!number|undefined} x
     * @param {!number|undefined} y
     * @returns {undefined|!ZxNode|!ZxEdge}
     */
    xyToNode(x, y) {
        if (x === undefined || y === undefined) {
            return undefined;
        }

        x -= this.offsetX;
        x /= this.pitch;
        x = Math.floor(x + 0.5);

        y -= this.offsetY;
        y /= this.pitch;
        y = Math.floor(y + 0.5);

        return new ZxNode(x, y);
    }

    /**
     * @param {!number|undefined} x
     * @param {!number|undefined} y
     * @returns {undefined|!ZxNode|!ZxEdge}
     */
    xyToGraphElement(x, y) {
        if (x === undefined || y === undefined) {
            return undefined;
        }
        let nx = Math.floor((x - this.offsetX) / this.pitch + 0.25);
        let ny = Math.floor((y - this.offsetY) / this.pitch + 0.25);
        let region = seq(floodFillNodeAndUnitEdgeSpace(new ZxNode(nx, ny))).take(20);
        region = region.filter(e => e instanceof ZxEdge || this.graph.has(e));
        return region.minBy(e => this.xyDistanceToGraphElement(x, y, e));
    }
}

function smoothStep(v0, v1, t0, t1, t) {
    if (t >= t1) {
        return v1;
    }
    if (t <= t0) {
        return v0;
    }
    t = (t - t0) / (t1 - t0);
    t = 3*t*t - 2*t*t*t;
    return (1 - t) * v0 + t * v1;
}

/**
 * @param {!ZxNode|!ZxEdge} element
 * @yields {!ZxNodePos|!ZxEdgePos}
 */
function* floodFillNodeAndUnitEdgeSpace(element) {
    let queue = [element];
    let seen = new GeneralSet();
    while (queue.length > 0) {
        let next = queue.shift();
        if (seen.has(next)) {
            continue;
        }
        seen.add(next);
        yield next;
        if (next instanceof ZxNode) {
            queue.push(...next.unitEdges())
        } else {
            queue.push(...next.nodes())
        }
    }
    throw new Error('UNREACHABLE');
}

_gen_package_export("src/ui/DisplayedZxGraph.js", {DisplayedZxGraph, floodFillNodeAndUnitEdgeSpace});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/ui/Export.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {ObservableValue} = _gen_package_get("src/base/Obs.js");
const {selectAndCopyToClipboard} = _gen_package_get("src/browser/Clipboard.js");
const {ZxGraph} = _gen_package_get("src/sim/ZxGraph.js");;
const {evalZxGraph} = _gen_package_get("src/sim/ZxGraphEval.js");;

const exportsIsVisible = new ObservableValue(false);
const obsExportsIsShowing = exportsIsVisible.observable().whenDifferent();

/**
 * @param {!Revision} revision
 * @param {!Observable.<!boolean>} obsIsAnyOverlayShowing
 */
function initExports(revision, obsIsAnyOverlayShowing) {
    // Show/hide exports overlay.
    (() => {
        const exportButton = /** @type {!HTMLButtonElement} */ document.getElementById('export-button');
        const exportOverlay = /** @type {!HTMLDivElement} */ document.getElementById('export-overlay');
        const exportDiv = /** @type {HTMLDivElement} */ document.getElementById('export-div');
        exportButton.addEventListener('click', () => exportsIsVisible.set(true));
        obsIsAnyOverlayShowing.subscribe(e => { exportButton.disabled = e; });
        exportOverlay.addEventListener('click', () => exportsIsVisible.set(false));
        document.addEventListener('keydown', e => {
            const ESC_KEY = 27;
            if (e.keyCode === ESC_KEY) {
                exportsIsVisible.set(false)
            }
        });
        obsExportsIsShowing.subscribe(showing => {
            exportDiv.style.display = showing ? 'block' : 'none';
            if (showing) {
                document.getElementById('export-diagram-button').focus();
            }
        });
    })();

    /**
     * @param {!HTMLButtonElement} button
     * @param {!HTMLElement} outputElement
     * @param {!HTMLElement} outcomeElement
     * @param {undefined|!function(): !string} contentMaker
     */
    const setupButtonElementCopyToClipboard = (button, outputElement, outcomeElement, contentMaker=undefined) =>
        button.addEventListener('click', () => {
            if (contentMaker !== undefined) {
                outputElement.innerText = contentMaker();
            }

            //noinspection UnusedCatchParameterJS,EmptyCatchBlockJS
            try {
                selectAndCopyToClipboard(outputElement);
                outcomeElement.innerText = "Done!";
            } catch (ex) {
                outcomeElement.innerText = "It didn't work...";
                console.warn('Clipboard copy failed.', ex);
            }
            button.disabled = true;
            setTimeout(() => {
                outcomeElement.innerText = "";
                button.disabled = false;
            }, 1000);
        });

    const setupTextExport = (name, outputFunc) => {
        const button = /** @type {HTMLButtonElement} */ document.getElementById(`export-${name}-button`);
        const outputElement = /** @type {HTMLPreElement} */ document.getElementById(`export-${name}-output`);
        const outcomeElement = /** @type {HTMLElement} */ document.getElementById(`export-${name}-outcome`);
        obsIsAnyOverlayShowing.subscribe(() => {
            outputElement.innerText = '[not generated yet]';
        });
        setupButtonElementCopyToClipboard(
            button,
            outputElement,
            outcomeElement,
            outputFunc);
    };

    function currentGraph() {
        return ZxGraph.deserialize(revision.peekActiveCommit());
    }
    function currentEval() {
        return evalZxGraph(currentGraph());
    }

    setupTextExport('diagram', () => currentGraph().movedToOrigin().toString());
    setupTextExport('qasm', () => currentEval().qasm);
    setupTextExport('quirk', () => currentEval().quirkUrl);
}

_gen_package_export("src/ui/Export.js", {initExports, obsExportsIsShowing});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/ui/RingMenu.js", function() {

const {Painter} = _gen_package_get("src/Painter.js");;
const {Rect} = _gen_package_get("src/base/Rect.js");;
const {Point} = _gen_package_get("src/base/Point.js");;
const {NODES} = _gen_package_get("src/nodes/All.js");;
const {ZxNode, ZxGraph} = _gen_package_get("src/sim/ZxGraph.js");;
const {ZxNodeDrawArgs} = _gen_package_get("src/nodes/ZxNodeKind.js");;

class RingMenuEntry {
    /**
     * @param {!string} id
     * @param {!string} description
     * @param {!function(ctx: !CanvasRenderingContext2D, args: !ZxNodeDrawArgs)} contentDrawer
     * @param {!number} centerAngle
     * @param {!number} centerRadius
     * @param {!number} angleSpan
     * @param {!number} radiusSpan
     * @param {!Array.<!string>} hotkeys
     * @param {undefined|!boolean} shiftMask
     * @param {undefined|!string} mouseHotkey
     */
    constructor(id,
                description,
                contentDrawer,
                centerAngle,
                centerRadius,
                angleSpan,
                radiusSpan,
                hotkeys,
                shiftMask,
                mouseHotkey=undefined) {
        this.id = id;
        this.description = description;
        this.contentDrawer = contentDrawer;
        this.centerAngle = centerAngle;
        this.centerRadius = centerRadius;
        this.angleSpan = angleSpan;
        this.radiusSpan = radiusSpan;
        this.hotkeys = hotkeys;
        this.shiftMask = shiftMask;
        this.mouseHotkey = mouseHotkey;
    }

    /**
     * @param {!ZxNodeKind} nodeKind
     * @param {!number} centerAngle
     * @param {!number} centerRadius
     * @param {!number} angleSpan
     * @param {!number} radiusSpan
     * @returns {!RingMenuEntry}
     */
    static fromNodeKind(nodeKind,
                        centerAngle,
                        centerRadius,
                        angleSpan,
                        radiusSpan) {
        return new RingMenuEntry(
            nodeKind.id,
            nodeKind.description,
            nodeKind.contentDrawer,
            centerAngle,
            centerRadius,
            angleSpan,
            radiusSpan,
            nodeKind.hotkeys,
            nodeKind.hotkeyShiftMask,
            nodeKind.mouseHotkey);
    }

    /**
     * @param {!number} dx
     * @param {!number} dy
     */
    contains(dx, dy) {
        let angle = Math.atan2(dy, dx);
        let angleDif = normalizedSignedAngle(angle - this.centerAngle);
        if (Math.abs(angleDif) > this.angleSpan / 2) {
            return false;
        }
        let radius = Math.sqrt(dx * dx + dy * dy);
        return Math.abs(radius - this.centerRadius) <= this.radiusSpan / 2;
    }

    /**
     * @param {!CanvasRenderingContext2D} ctx
     * @param {!number} cx
     * @param {!number} cy
     * @param {!int} focusLevel
     */
    draw(ctx, cx, cy, focusLevel) {
        let r0 = this.centerRadius - this.radiusSpan / 2;
        let r1 = this.centerRadius + this.radiusSpan / 2;
        let a0 = this.centerAngle - this.angleSpan / 2;
        let a1 = this.centerAngle + this.angleSpan / 2;

        ctx.save();
        try {
            ctx.translate(cx, cy);
            ctx.save();
            ctx.fillStyle = 'black';
            ctx.font = '20px monospace';
            ctx.rotate(this.centerAngle);
            if (this.shiftMask !== true) {
                ctx.translate(r0 - 10, 0);
            } else {
                ctx.translate(r1 + 10, 0);
            }
            ctx.rotate(-this.centerAngle);
            ctx.rotate(normalizedQuarterAngleOffset(this.centerAngle));
            ctx.fillText(this.hotkeys[0], -this.hotkeys[0].length * 5, 6);
            ctx.restore();

            if (this.mouseHotkey !== undefined) {
                ctx.lineWidth = 1;

                ctx.save();
                ctx.fillStyle = 'black';
                ctx.font = '16px monospace';
                ctx.rotate(this.centerAngle);
                ctx.translate(r1 + 10, 0);
                ctx.rotate(-this.centerAngle);
                ctx.rotate(normalizedQuarterAngleOffset(this.centerAngle));
                ctx.strokeStyle = 'black';

                let terms = this.mouseHotkey.split('+');
                if (terms.length > 1) {
                    ctx.fillText(terms[0] + '+', -terms[0].length * 6 - 6, 6);
                    ctx.translate(terms[0].length * 6, 0);
                }
                if (this.mouseHotkey.indexOf('middle') !== -1) {
                    ctx.beginPath();
                    ctx.moveTo(-2, 4);
                    ctx.lineTo(2, 4);
                    ctx.lineTo(2, -7);
                    ctx.lineTo(-2, -7);
                    ctx.lineTo(-2, 4);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                }
                if (this.mouseHotkey.indexOf('left') !== -1) {
                    ctx.beginPath();
                    ctx.moveTo(-2, 4);
                    ctx.lineTo(-7, 4);
                    ctx.lineTo(-7, -3);
                    ctx.lineTo(-2, -7);
                    ctx.lineTo(-2, 4);
                    ctx.fillStyle = 'red';
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.arc(0, 0, 7, 0, Math.PI, true);
                ctx.lineTo(-7, 10);
                ctx.arc(0, 10, 7, Math.PI, 0, true);
                ctx.lineTo(7, 0);
                ctx.moveTo(7, 4);
                ctx.lineTo(-7, 4);
                ctx.moveTo(2, 4);
                ctx.lineTo(2, -7);
                ctx.moveTo(-2, 4);
                ctx.lineTo(-2, -7);
                ctx.stroke();
                ctx.restore();
            }

            if (focusLevel === 2) {
                r0 -= 8;
                r1 += 8;
                a0 -= 0.01;
                a1 += 0.01;
            }
            ctx.strokeStyle = 'black';
            ctx.fillStyle = focusLevel === 0 ? '#DDD' : focusLevel === 1 ? '#EED' : '#FF8';
            ctx.lineWidth = focusLevel === 2 ? 5 : 2;
            ctx.beginPath();
            ctx.arc(0, 0, r0, this.centerAngle, a1);
            ctx.lineTo(Math.cos(a1) * r1, Math.sin(a1) * r1);
            ctx.arc(0, 0, r1, a1, a0, true);
            ctx.lineTo(Math.cos(a0) * r0, Math.sin(a0) * r0);
            ctx.arc(0, 0, r0, a0, this.centerAngle);
            ctx.stroke();
            ctx.fill();
        } finally {
            ctx.restore();
        }

        let graph = new ZxGraph();
        let node = new ZxNode(0, 0);
        let args = new ZxNodeDrawArgs(graph, node);
        ctx.save();
        try {
            ctx.translate(cx, cy);
            ctx.rotate(this.centerAngle);
            ctx.translate((r0 + r1) / 2, 0);
            ctx.rotate(-this.centerAngle);
            ctx.rotate(normalizedQuarterAngleOffset(this.centerAngle));
            graph.nodes.set(node, graph);
            this.contentDrawer(ctx, args);
        } finally {
            ctx.restore();
        }
    }
}


class RingMenu {
    /**
     * @param {!Array.<!RingMenuEntry>} entries
     */
    constructor(entries = []) {
        this.entries = entries;
    }

    /**
     * @param {!int} keyCode
     * @param {!boolean} shiftKey
     * @returns {undefined|!RingMenuEntry}
     */
    entryForKey(keyCode, shiftKey) {
        let keyChar = String.fromCharCode(keyCode).toLowerCase();
        for (let entry of this.entries) {
            if (entry.shiftMask === undefined || shiftKey === entry.shiftMask) {
                for (let hotkey of entry.hotkeys) {
                    if (hotkey === keyCode || (typeof hotkey === 'string' && hotkey.toLowerCase() === keyChar)) {
                        return entry;
                    }
                }
            }
        }
        return undefined;
    }

    /**
     * @param {!number} cx
     * @param {!number} cy
     * @param {!number} x
     * @param {!number} y
     * @returns {!RingMenuEntry|!undefined}
     */
    entryAt(cx, cy, x, y) {
        if (x === undefined || y === undefined) {
            return undefined;
        }
        for (let entry of this.entries) {
            if (entry.contains(x - cx, y - cy)) {
                return entry;
            }
        }
        return undefined;
    }

    /**
     * @param {!CanvasRenderingContext2D} ctx
     * @param {!number} cx
     * @param {!number} cy
     * @param {!boolean} altPressed
     * @param {undefined|!number} mouseX
     * @param {undefined|!number} mouseY
     */
    draw(ctx, cx, cy, altPressed, mouseX, mouseY) {
        ctx.save();
        try {
            ctx.translate(cx, cy);
            ctx.fillStyle = 'black';
            ctx.font = '12px monospace';
            for (let entry of this.entries) {
                if (entry.shiftMask === true) {
                    let a1 = normalizedSignedAngle(entry.centerAngle - entry.angleSpan / 2 - Math.PI * 0.01);
                    let a2 = normalizedSignedAngle(entry.centerAngle + entry.angleSpan / 2 + Math.PI * 0.025);
                    for (let a of [a1, a2]) {
                        ctx.save();
                        ctx.rotate(a);
                        ctx.translate(entry.centerRadius + entry.radiusSpan/2 - 10, 0);
                        if (Math.abs(a) > Math.PI/2) {
                            ctx.rotate(Math.PI);
                            ctx.translate(10, 8);
                        }
                        ctx.fillText('shift', -22, 0);
                        ctx.restore();
                    }
                }
            }
        } finally {
            ctx.restore();
        }

        for (let entry of this.entries) {
            entry.draw(ctx, cx, cy, entry.shiftMask === altPressed ? 1 : 0);
        }

        let focused = this.entryAt(cx, cy, mouseX, mouseY);
        if (focused !== undefined) {
            focused.draw(ctx, cx, cy, 2);
            ctx.fillStyle = 'white';
            ctx.fillRect(cx - 40, cy - 40, 80, 80);
            new Painter(ctx).printParagraph(
                focused.description,
                new Rect(cx - 75, cy - 75, 150, 150),
                new Point(0.5, 0.5),
                'black',
                12,
                'monospace');
        }
    }
}

/**
 * @returns {!RingMenu}
 */
function makeNodeRingMenu() {
    let result = new RingMenu();

    let radiusStep = 35;
    let baseRadius = 100;
    for (let post of [false, true]) {
        for (let axis of [false, true]) {
            let angleWidth = Math.PI / 8;
            let startAngle = axis ? angleWidth * -6.5 : -angleWidth * 1.5;
            let step = Math.PI / 8 * (axis ? -1 : 1);
            let radius = baseRadius + (post ? radiusStep : 0);

            result.entries.push(RingMenuEntry.fromNodeKind(
                NODES.map.get(`${axis ? '@' : 'O'}${post ? '!' : ''}`),
                startAngle,
                radius,
                angleWidth,
                radiusStep));
            result.entries.push(RingMenuEntry.fromNodeKind(
                NODES.map.get(`${axis ? 'z' : 'x'}${post ? '!' : ''}`),
                startAngle + step,
                radius,
                angleWidth,
                radiusStep));
            result.entries.push(RingMenuEntry.fromNodeKind(
                NODES.map.get(`${axis ? 's' : 'f'}${post ? '!' : ''}`),
                startAngle + 2 * step,
                radius,
                angleWidth,
                radiusStep));
            result.entries.push(RingMenuEntry.fromNodeKind(
                NODES.map.get(`${axis ? 'a' : 'w'}${post ? '!' : ''}`),
                startAngle + 3 * step,
                radius,
                angleWidth,
                radiusStep));
        }
    }

    result.entries.push(new RingMenuEntry(
        'del',
        'Delete node',
        ctx => {
            ctx.fillStyle = 'red';
            ctx.font = '20px monospace';
            ctx.fillText('DEL', -15, +5);
        },
        Math.PI / 2 - Math.PI / 16 * 1.2,
        baseRadius + radiusStep / 2,
        Math.PI / 8,
        radiusStep,
        ['del'],
        undefined,
        'middle'));

    result.entries.push(new RingMenuEntry(
        'edge',
        'Start edge',
        ctx => {
            ctx.fillStyle = 'black';
            ctx.font = '18px monospace';
            ctx.fillText('edge', -20, +5);
        },
        Math.PI / 2 + Math.PI / 16 * 1.2,
        baseRadius + radiusStep / 2,
        Math.PI / 8,
        radiusStep,
        ['e'],
        undefined,
        'ctrl+left'));

    result.entries.push(RingMenuEntry.fromNodeKind(
        NODES.h,
        -Math.PI / 2,
        baseRadius + radiusStep / 2,
        Math.PI / 8,
        radiusStep));

    result.entries.push(RingMenuEntry.fromNodeKind(
        NODES.in,
        -Math.PI / 2 - Math.PI / 8 * 1.1,
        baseRadius + radiusStep / 2,
        Math.PI / 8,
        radiusStep));

    result.entries.push(RingMenuEntry.fromNodeKind(
        NODES.out,
        -Math.PI / 2 + Math.PI / 8 * 1.1,
        baseRadius + radiusStep / 2,
        Math.PI / 8,
        radiusStep));

    return result;
}

/**
 * @param {!number} angle
 * @returns {!number}
 */
function normalizedSignedAngle(angle) {
    angle %= 2 * Math.PI;
    angle += 2 * Math.PI;
    angle %= 2 * Math.PI;
    if (angle >= Math.PI) {
        angle -= 2 * Math.PI;
    }
    return angle;
}

/**
 * @param {!number} angle
 * @returns {!number}
 */
function normalizedQuarterAngleOffset(angle) {
    angle %= Math.PI / 2;
    while (angle >= Math.PI/4) {
        angle -= Math.PI/2;
    }
    while (angle < -Math.PI/4) {
        angle += Math.PI/2;
    }
    return angle;
}

_gen_package_export("src/ui/RingMenu.js", {RingMenu, RingMenuEntry, makeNodeRingMenu});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/ui/UndoRedo.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @param {!Revision} revision
 * @param {!ObservableValue.<boolean>} obsIsAnyOverlayShowing
 */
function initUndoRedo(revision, obsIsAnyOverlayShowing) {
    const overlayDivs = [
        document.getElementById('export-div')
    ];

    const undoButton = /** @type {!HTMLButtonElement} */ document.getElementById('undo-button');
    const redoButton = /** @type {!HTMLButtonElement} */ document.getElementById('redo-button');
    revision.latestActiveCommit().zipLatest(obsIsAnyOverlayShowing.observable(), (_, b) => b).subscribe(anyShowing => {
        undoButton.disabled = revision.isAtBeginningOfHistory() || anyShowing;
        redoButton.disabled = revision.isAtEndOfHistory() || anyShowing;
    });

    undoButton.addEventListener('click', () => revision.undo());
    redoButton.addEventListener('click', () => revision.redo());

    document.addEventListener("keydown", e => {
        // Don't capture keystrokes while menus are showing.
        if (obsIsAnyOverlayShowing.get()) {
            return;
        }

        const Y_KEY = 89;
        const Z_KEY = 90;
        let isUndo = e.keyCode === Z_KEY && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
        let isRedo1 = e.keyCode === Z_KEY && e.ctrlKey && e.shiftKey && !e.altKey && !e.metaKey;
        let isRedo2 = e.keyCode === Y_KEY && e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey;
        if (isUndo) {
            revision.undo();
            e.preventDefault();
        }
        if (isRedo1 || isRedo2) {
            revision.redo();
            e.preventDefault();
        }
    });
}

_gen_package_export("src/ui/UndoRedo.js", {initUndoRedo});


});

///////////////////////////////////////////////////////////////////////////////////////////////
_gen_packages_inits.set("src/ui/Url.js", function() {

// Copyright 2017 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

const {Config} = _gen_package_get("src/Config.js");
const {HistoryPusher} = _gen_package_get("src/browser/HistoryPusher.js");
const {ZxGraph} = _gen_package_get("src/sim/ZxGraph.js");

function hashSafeForUrl(jsonText) {
    if (jsonText.indexOf('%') !== -1 || jsonText.indexOf('&') !== -1) {
        jsonText = encodeURIComponent(jsonText);
    }
    return "#" + jsonText;
}

/**
 * @param {!Revision} revision
 */
function initUrlSync(revision) {
    const historyPusher = new HistoryPusher();
    const loadFromUrl = () => {
        historyPusher.currentStateIsMemorableButUnknown();
        let text = document.location.hash.substr(1);
        historyPusher.currentStateIsMemorableAndEqualTo(text);
        let graph =  ZxGraph.deserialize(text);
        revision.clear(text);
        if (graph.nodes.size === 0) {
            historyPusher.currentStateIsNotMemorable();
        } else {
            historyPusher.stateChange(text, hashSafeForUrl(text));
        }
    };

    window.addEventListener('popstate', loadFromUrl);
    loadFromUrl();

    revision.latestActiveCommit().whenDifferent().skip(1).subscribe(text => {
        historyPusher.stateChange(text, hashSafeForUrl(text));
    });
}

_gen_package_export("src/ui/Url.js", {initUrlSync});


});


_gen_package_get("src/main.js");


_gen_package_get("src/base/Complex.js");
_gen_package_get("src/base/Describe.js");
_gen_package_get("src/base/DetailedError.js");
_gen_package_get("src/base/Equate.js");
_gen_package_get("src/base/Format.js");
_gen_package_get("src/base/GeneralMap.js");
_gen_package_get("src/base/GeneralSet.js");
_gen_package_get("src/base/Matrix.js");
_gen_package_get("src/base/Obs.js");
_gen_package_get("src/base/Point.js");
_gen_package_get("src/base/Rect.js");
_gen_package_get("src/base/Revision.js");
_gen_package_get("src/base/Seq.js");
_gen_package_get("src/base/Serialize.js");
_gen_package_get("src/base/Util.js");
_gen_package_get("src/browser/Clipboard.js");
_gen_package_get("src/browser/HistoryPusher.js");
_gen_package_get("src/Config.js");
_gen_package_get("src/edit.js");
_gen_package_get("src/main.js");
_gen_package_get("src/MathPainter.js");
_gen_package_get("src/nodes/All.js");
_gen_package_get("src/nodes/Base.js");
_gen_package_get("src/nodes/CrossingNode.js");
_gen_package_get("src/nodes/HadamardNode.js");
_gen_package_get("src/nodes/InputOutputNodes.js");
_gen_package_get("src/nodes/PostSelectionNodes.js");
_gen_package_get("src/nodes/SpiderNodes.js");
_gen_package_get("src/nodes/ZxNodeKind.js");
_gen_package_get("src/Painter.js");
_gen_package_get("src/sim/BitTable.js");
_gen_package_get("src/sim/chp_gen.js");
_gen_package_get("src/sim/ChpSimulator.js");
_gen_package_get("src/sim/Controls.js");
_gen_package_get("src/sim/EdgeActions.js");
_gen_package_get("src/sim/Measurement.js");
_gen_package_get("src/sim/PauliProduct.js");
_gen_package_get("src/sim/QuantumProgram.js");
_gen_package_get("src/sim/SimulatorSpec.js");
_gen_package_get("src/sim/StabilizerToWave.js");
_gen_package_get("src/sim/VectorSimulator.js");
_gen_package_get("src/sim/ZxGraph.js");
_gen_package_get("src/sim/ZxGraphEval.js");
_gen_package_get("src/sim/ZxGraphGroundTruth.js");
_gen_package_get("src/ui/Clear.js");
_gen_package_get("src/ui/DisplayedZxGraph.js");
_gen_package_get("src/ui/Export.js");
_gen_package_get("src/ui/RingMenu.js");
_gen_package_get("src/ui/UndoRedo.js");
_gen_package_get("src/ui/Url.js");


        </script>
    </body>
</html>
