<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="author" content="Craig Gidney">
    <meta name="keywords" content="computer science,algorithms,quantum computing,blog">
    <meta name="description" content="Craig Gidney's computer science blog">
    <title>Using Eigendecomposition to Convert Rotations and Interpolate Operations</title>
    <link rel="shortcut icon" href="/assets/favicon.ico">
    <meta name="viewport" content="width=device-width">

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

    <!-- RSS autodiscovery -->
    <link rel="alternate" type="application/rss+xml" title="RSS" href="/feed.xml">

    <!-- Analytics -->
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-48771413-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
  </head>
  <body>
    <div class="header">
      <a href="/"><img src="/assets/banner.png" alt="Algorithmic Assertions - Craig Gidney's Computer Science Blog" id="site_banner"/></a>
    </div>
    <div class="site">

      <h1 class="post_title">Using Eigendecomposition to Convert Rotations and Interpolate Operations</h1>
<p class="meta">10 Jan 2016</p>

    <!-- MathJax latest -->
    <script async type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [['$','$']],
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        TeX: {
          Macros: {
            ket: ["\\left|{#1}\\right\\rangle", 1],
            bra: ["\\left\\langle{#1}\\right|", 1],
            parens: ["\\left({#1}\\right)", 1],
            bracket: ["\\left[{#1}\\right]", 1],
            brace: ["\\left\\{ {#1} \\right\\}", 1],
            Sum: ["\\underset{#1}{\\overset{#2}{\\Sigma}}", 2],
            bimat: ["\\begin{bmatrix} {#1} & {#2} \\\\ {#3} & {#4} \\end{bmatrix}", 4]
          }
        }
      });
    </script>
    <noscript>
      <font color=red>
        MathJax was blocked.
        Formulas like <strong>$\frac{a}{b}$</strong> won't render into <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAAYCAIAAACjjJBEAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAFnSURBVDhPY/hPCCBU/P1wamJqZFpBTnJcqLl9142fUHGYip93Znopuc55+Pv/zyv16kJ+W99DJaAq/r3bGiLA67cFJPxuo5eI8bSHf8ASQABR8e1krhSr+ZwnQOGvx9LlFPNPvnv37vs/sBxExc/rrToy8Ye+/P/7ekeKFK/H2guLsvuvQlwCdcefF1sKPX3ic8qaJkzKsTcPSKzY8PQ3RArmUtyAWioYcAOoCvyAyiq+nusIVGdl0O6+/QsqAgYoZnw5nCSlkHfqG5QLAcgqflyuVZeI3PMJyoUCJBV/Hk43YRFySSvIDHXyrNr75i9EGKHi35t1HvxKxUc+/vv/cYe/qNGEu5CIQaj4cjBBSrn03HewYUZsStWXfoDF4Sp+351gKB688yMwOb5c4cwlmngA6h64ir9P59lr5Jz89v/nrQnWsl4LH0MjH8mWvx9OdEUFJ6TEhGXPu/IFkr5AAKECO/j/HwCRTZMPA+AaqQAAAABJRU5ErkJggg==" />.
      </font>
      <br>
      Allow scripts from <strong>algorithmicassertions.com</strong> and <strong>mathjax.org</strong> to fix.
      <hr/>
    </noscript>

<div class="post">
<p>This post is an addendum to <a href="/quantum/2014/11/15/Interpolating-Qubit-Operations.html">Interpolating Qubit Operations</a> and <a href="/quantum/2014/11/24/Converting-Rotations-into-Nice-Qubit-Operations.html">Converting Rotations into &quot;Nice&quot; Qubit Operations</a>.
Both of those posts are about smoothly travelling through the space of unitary operators, but they share the same massive omission (because I didn&#39;t know about it at the time).</p>

<p>The omission?
Using the <a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix">eigendecomposition</a> to compute matrix functions like $U^t$ or $\ln(U)$ or $\exp(U)$.</p>

<h1>Eigenvalue Functions</h1>

<p>Unitary matrices have a lot of nice properties.
A <em>particularly</em> nice one is that every unitary matrix can be broken into orthogonal eigenvectors.
You can always break a unitary $U$ into a sum like $\sum_{\lambda,v} \lambda \ket{v}\bra{v}$, where each eigenvector $v$ is perpendicular to the others and each eigenvalue $\lambda$ is a phase factor like $e^{i \theta}$ on the complex unit circle.</p>

<p>Many functions on matrices ultimately amount to just transforming the eigenvalues.
You want to compute an $n$&#39;th root of $U$?
Just break $U$ apart, divide the eigenvalues&#39; phase angles by $n$, and put the matrix back together.
If $U = \sum_{\theta,v} e^{i \theta} \ket{v}\bra{v}$ then the principal $\sqrt[n]{U}$ is $\sum_{\theta,v} \sqrt[n]{e^{i \theta}} \ket{v}\bra{v} = \sum_{\theta,v} e^{i \theta / n} \ket{v}\bra{v}$.</p>

<p>Similarly, if you want the natural logarithm of $U$ (whatever <em>that</em> means), then given $U = \sum_{\theta,v} e^{i \theta} \ket{v}\bra{v}$ you&#39;ll find that the logarithm is equal to $\sum_{\theta,v} \ln(e^{i \theta}) \ket{v}\bra{v} = \sum_{\theta,v} i \theta \ket{v}\bra{v}$.</p>

<p>Basically, when in doubt, try computing $f(U)$ by hitting $U$&#39;s eigenvalues with $f$.
It will make your life easier, and give you access to matrix functions with useful properties.
Case in point, let&#39;s try using it on the two posts I linked to in the introduction.</p>

<h1>Qubit Operations from Rotations</h1>

<p>In the <a href="/quantum/2014/11/24/Converting-Rotations-into-Nice-Qubit-Operations.html">nice rotations post</a>, I talk about mapping from rotations to operations on single qubits.</p>

<p>The usual way to convert from a rotation around the $\hat{v}$ axis by $\theta$ radians into a unitary single-qubit operation $U$ is to compute $U_{\hat{v}, \theta} = I \cos \frac{\theta}{2} + i \hat{v} \vec{\sigma} \sin \frac{\theta}{2}$, where $\vec{\sigma}$ is the <a href="https://en.wikipedia.org/wiki/Pauli_matrices#Pauli_vector">Pauli vector</a>, $I$ is the 2x2 identity matrix, and $i$ is $\sqrt{-1}$.
The problem I had (and have) with this mapping is that it introduces an unwanted phase factor.
For example, when rotating around the X axis, it won&#39;t pass through the Pauli $X$ operator.
It passes through $iX$ instead of $X$.
So I added a phase-correction term, did some simplification, and came up with the alternative mapping $U^*_{\hat{v}, \theta} = \frac{1}{2} I \left( 1 + e^{i \theta} \right) - \frac{1}{2} \hat{v} \vec{\sigma} \left( 1 - e^{i \theta} \right)$.</p>

<p>What I didn&#39;t know at the time is that both mappings correspond to exponentiation.
The original mapping is just $U_{\hat{v}, \theta} = e^{i \hat{v} \vec{\sigma} \frac{\theta}{2}}$, and the phase-corrected mapping is just $U^*_{\hat{v}, \theta} = (\hat{v} \vec{\sigma})^{\theta / \pi}$.
Instead of talking about &quot;phase correction&quot;, I could have been talking about moving the $\hat{v} \vec{\sigma}$ matrix from the exponent to the base.</p>

<p>Moving the matrix to the base, and thinking in terms of raising it to a power, has other conceptual side effects.
For example, you don&#39;t have to think in terms of angles anymore; you start to think in terms of roots.
Instead of dealing with nonsense like <a href="https://en.wikipedia.org/wiki/Quantum_gate#Phase_shift_gates">the $\frac{\pi}{8}$ gate rotating by $\frac{\pi}{4}$ radians</a>, you can just talk about &quot;the [principal] $\sqrt[4]{Z}$ gate&quot; or &quot;the $Z^{0.25}$ gate&quot;.</p>

<h1>Simplified Interpolation</h1>

<p>In <a href="/quantum/2014/11/15/Interpolating-Qubit-Operations.html">the interpolation post</a>, I talk about using spherical interpolation combined with angle interpolation to smoothly move within the space of 2x2 unitary matrices.</p>

<p>Basically all of the machinery in that post can be replaced with this one equation: $U_s = U_0 \cdot \left( U_0^{\dagger} \cdot U_1 \right)^s$.
The value $U_0^{\dagger} \cdot U_1$ is unitary, because it&#39;s a product of unitary matrices, so we can use the eigendecomposition to raise it to whatever intermediate power we want.</p>

<p>Despite being conceptually much simpler than the machinery from the old post, this technique also generalizes much better.
It can interpolate between <em>any</em> two unitary matrices (of the same size), instead of just 2x2 matrices.
It&#39;s even easy to write, assuming you have a linear algebra library handy.
Slap together some python code to hit the eigenvalues of a matrix with a function, then use it to compute the interpolation:</p>
<div class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span>

<span class="k">def</span> <span class="nf">eigenterpolate</span><span class="p">(</span><span class="n">U0</span><span class="p">,</span> <span class="n">U1</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Interpolates between two matrices.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">U0</span> <span class="o">*</span> <span class="n">eigenpow</span><span class="p">(</span><span class="n">U0</span><span class="o">.</span><span class="n">H</span> <span class="o">*</span> <span class="n">U1</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">eigenpow</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Raises a matrix to a power.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">eigenlift</span><span class="p">(</span><span class="k">lambda</span> <span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">**</span><span class="n">t</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">eigenlift</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lifts a numeric function to apply it to a matrix.&quot;&quot;&quot;</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">numpy</span><span class="o">.</span><span class="n">complex128</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)):</span>
        <span class="n">eigen_val</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">eigen_vec</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">mat</span><span class="p">(</span><span class="n">v</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="n">eigen_mat</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">eigen_vec</span><span class="p">,</span> <span class="n">eigen_vec</span><span class="o">.</span><span class="n">H</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">+=</span> <span class="n">f</span><span class="p">(</span><span class="n">eigen_val</span><span class="p">)</span> <span class="o">*</span> <span class="n">eigen_mat</span>
    <span class="k">return</span> <span class="n">T</span>
</code></pre></div>
<p>All we need now is some matrices I&#39;d have considered tricky to interpolate between, and an animation of the output.
Here&#39;s what happens when we interpolate between the identity operator and the increment operator:</p>

<p><img src="/assets/2016-01-10-eigendecomposition-for-rotation-and-interpolation/identity-to-increment.gif" title="Interpolating between no-op and increment"/></p>

<p>And here&#39;s interpolating between the increment operator and the fourier transform:</p>

<p><img src="/assets/2016-01-10-eigendecomposition-for-rotation-and-interpolation/fourier-to-increment.gif" title="Interpolating between fourier transform and increment"/></p>

<p>Finally, here&#39;s interpolating between the identity operator and the fourier transform:</p>

<p><img src="/assets/2016-01-10-eigendecomposition-for-rotation-and-interpolation/identity-to-fourier.gif" title="Interpolating between no-op and fourier transform"/></p>

<p>That works pretty well, for 15 lines of code! (But do 90% of them <em>really</em> need to include the substring &quot;eigen&quot;?)</p>

<p>(There does appear to some kind of numerical accuracy issue present.
In the third animation, things don&#39;t quite line up at the pause points.
I <em>think</em> this is numpy&#39;s fault; we&#39;re at the mercy of numpy returning good accurate eigenvectors and eigenvalues.
You should have seen how bad it looked when I used $\exp(s \ln(D))$ instead of $D^s$... flickering and stuttering everywhere.)</p>

<h1>Summary</h1>

<p>Eigendecomposition and matrix exponentiation make everything easier.
Use them.</p>

</div>

<!-- IntenseDebate comments -->

  <script>
  var idcomments_acct = '7d0006bd6a016f9a2892cc2ecc64de01';
  var idcomments_post_id = '/quantum/2016/01/10/eigendecomposition-for-rotation-and-interpolation.html';
  var idcomments_post_url = 'http://algorithmicassertions.com/quantum/2016/01/10/eigendecomposition-for-rotation-and-interpolation.html';
  </script>
  <span id="IDCommentsPostTitle" style="display:none"></span>
  <script type='text/javascript' src='http://www.intensedebate.com/js/genericCommentWrapperV2.js'></script>
  <noscript>
    <hr>
    <font color=red>
      Comments script blocked. Comments won't work.
    </font>
    <br/>
    Allow scripts from <strong>algorithmicassertions.com</strong> and <strong>intensedebate.com</strong> to fix.
  </noscript>




    </div>

    <table style="width: 100%;">
      <tr>
        <td align="left">
          <a href="/quantum/2016/01/07/Delayed-Choice-Quantum-Erasure.html">&laquo; Deflating Delayed Choice Quantum Erasure</a>
        </td>
        <td align="right">
          <a href="/quantum/2016/01/19/unknown-but-equal.html">Unknowable, but Equal &raquo;</a>
        </td>
      </tr>
    </table>

    <div class="footer-container">
      <div class="site">
        <div class="footer">
          <div class="contact">
            by: Craig Gidney<br />
            more: <a href="/">All Posts</a>, <a href="/feed.xml">Posts Feed<img src="/assets/feed-icon.png" width="16px" alt="Posts Feed" title="Posts Feed" /></a><br/>
            meta: <a href="/about.html">About the Author/Blog</a><br/>
          </div>
          <div class="license">
            <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
              <img alt="Creative Commons License" style="border-width:0" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFgAAAAfCAYAAABjyArgAAAFOklEQVRo3u1aTU8bRxj2OVIs7lw4hhttlR5TpPQHkB+QiH9Q1FskqqCIVIpUCVmuoubQUKm3JrDG5sNfeA1rY3vX9noh5MpP4Ce81fOu32V2WfAHzhoTRhqx3pmdHZ595nk/ZmJEFI/FYnRfR1+J8Kf7Yye/TXvFXcqVslQ8KFDJKNFBtUxG3aAjs0r1Zo0arQZZbZOatkXNTtOttkWWbZLZanAf9K3UDX5WN0o8Vq6U47Hxjkw2TVt7KUrtaLS5vUEbmU9cP6U/0set/+5MVYC+ADev52j/sEjlik5G7ZDBarTqDGDbaVHnxCbnc4eOT4/p5Itbce18drgNfSzb4mfwLMYoV3UeE2MHQdZ2Nj2QAfAdBTnmB7daZgbWrBqzFaAB1NU3q/T056f0MP7w0lLAPbSt/r7KfdvHbf4oYHSlUWE27x/u+0BOZ7cotau5IGc2Rsbil8svaXZ29tIccQ9tYwEYsqCCC2CaHYtZmUgmaHp6um/dQd/Enwl+FhICNlc9kIueXGznMpTec0EeBYuTfyXp0ewjbx7z8/O0tLTEFddyH33QN1KAoZOQhQtwm8zEhWcLPvCmpqZocXGRVlZWSNd1rrjGPbSpffFspWZQy3FBBpMhF64mZ2m3sOOXihuweP3fDxSPx933LizQ2dkZBQvuoQ190DcKkD2AYdCgl5AFMDcILsADkOfn53RdWV9f9wENtgBkfDB8OLwDhq9QzlN2f8+VihAWD/qPCHPxodWiWHPfHGVukQGM5QujBM3F0lbBnZubC2XEVQUfAc+oTMaY0GS840IqFBbvpkjb3hxKJqCrwtwvp6c9AUYRJn9tTfYANlga6mzQoLkquL1Y2w/I0GQYPpaKukF6xWUxa3He1WKRiUEBFoM2CAnQVwxfJAAze22TpUEMGpa6bds0bAHIIhcYE2PDhRMWFw9cFqsexTAyIQYtWCAX8oGD0oEihi8SgKGPLafFrphMCpp70yJ6hwoXDitEtLjUddtUmRgWYHgKwRISVfkKnokMYERo9onNvqywV5UGeAvQLXx1VBX8YNva2prvHxEWY2xoMSK+SzKRy7jehKLDdwpgGDcsYQki1CUFAMP8XYCpaVpom/q8LFWMjYgPUlTtumyFcoG9CeiwuGt3UiKQTzg+dbwJqSwUYzUzM8PGAYDjGstf2sTTAODSFiYTCKubPh0u+Ny1YQC+zshdxd7IjRx8X+QVZEIAMTjJME3uR6/VFYB3wCc+Mo9GBrDqpvULcORu2iQDPGigIdobaaDRr0TA8MF1wzVAVSUi2BaVRExEqHydkbvOkPVj5IQxrpHr8LtGaeRUkNVkDz465oH3q0HPWJI94qZJiAzXKrjMr3LTALLcD7ahgNGqm9ZQ3LS8fnM3bSLSlRJoqGFy0J8dZaBx2A00kLqUQOOmCZ9bnXCvNsJD5UHi+3GFyhMBsJrs+fDP36NP9iQTPDaSPXiXpCzVxPuwyZ6JABh1+dWyl658/uK5D+RBkj5gfWi6sm3S6zevv8Xd5YsfS7/+wm5UZ4iEO9rQR024P/7xMUsD/Gx8wG90+95/47dXyxwMAGSVycNsGQHcVqdJ796/i+ocQmiQEewzVoA9kG130xOaPPCmZ1I2Pa3IwA2CF3Y9BnDDARa5ULftAVqvbXvsXPC2Pc5HtM3IZaFXuvJWSIRav//hO9LSGrtw8JNt7+CJoxw8cfieevAkldHoyU9PxnFU6TZJQ2+ApQKst3+8pWK5qByd6lYcnWqb3IY+4wB2Yhl8X0dQiejBPRBf73Tl/8YjNDN/aKmsAAAAAElFTkSuQmCC" />
            </a><br />
            This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
          </div>
        </div>
      </div>
    </div>
  </body>
</html>
